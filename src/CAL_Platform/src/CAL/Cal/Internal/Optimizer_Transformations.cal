/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *  
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *  
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Optimizer.cal
 * Created: August 12, 2005
 * By: Greg McClement
 */

/**
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 * WARNING WARNING WARNING WARNING WAR
 * 
 * This file is part of the compiler and not to be modified.
 * 
 * ING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 * WARNING WARNING WARNING WARNING
 * 
 * This module contains all functions that perform optimizing transformations of
 * expressions. Some of the transformations currently defined are
 * 
 * performFusion
 * 
 * This transformation can decide to create a new function that fuses two other
 * functions and in the process eliminates some data constructors.
 * 
 * transform_specialization
 * 
 * This transformation can decide to create a new specialized version of a
 * function with more specific types and possible eliminate arguments by
 * embeddeding given values.
 * 
 * transform_3_2_2
 * 
 * This transformation performs inlining of values.
 * 
 * There are a number of other transformations defined in the file, see below.
 * 
 * TODO rename all the tranformation so that they have some naming convention
 * that is consistent and so they can be easily found.
 * 
 * @author Greg McClement
 * 
 */

module Cal.Internal.Optimizer_Transformations;

import Cal.Core.Prelude using
    typeConstructor = String, Int, Boolean, JObject, JList, Double, Char, Maybe, Long;
    dataConstructor = True, False, Just, Nothing;
    typeClass = Eq, Outputable, Inputable, Ord;
    function = deepSeq, seq, max, typeOf, empty, input, output, intToString, uncurry, assert, snd, fst, error, concat, or, isNothing, isJust, compare, and, not, undefined, compose, upFrom, isEmpty, upFromTo, append, isStringType, isIntType, isBooleanType, isDoubleType, isCharType;
    ;

import Cal.Collections.List using
    function = 
        zipWith, zipWith5, find, foldLeft, foldLeft1, andList, intersect, map, zip3, 
        filter, orList, sortBy, tail, head, zip, reverse, length, take,
        removeDuplicates;
    ;
    
import Cal.Core.String using
    function = indexOfString, startsWith;
    ;
    
import Cal.Core.Debug using
    typeClass = Show;
    function = trace, show;
    ;

import Cal.Internal.Optimizer_Type using
    typeConstructor = Type, JTypeExpr;
    dataConstructor = TypeConst, TypeConstTest, TypeVar, TypeId, AndType, FunctionType, ListType, AppType;
    function = types_hasStrictArguments, type_specializeArguments, optimizerHelper_typeExpr_getName,
               type_isStrict, type_applyStrictness, type_setStrictness, 
               type_unify, type_applyBindings, inputType, flattenType, outputType, type_atLeastAsStrict,
               type_listToType, type_isFunctionType, unflattenAppTypes, optimizerHelper_newTypeVar; 
    ;
    
import Cal.Internal.Optimizer_Expression using
    typeConstructor = Expression, QualifiedName, FieldName, Alt,  
                      DataCons, Literal, CaseConst, JFunctionalAgent, JCompiler_RecordType_RecordType;
    dataConstructor = FNOrdinal, FNTextual, Alt, Alts,
                      Var, Literal, App, Lambda, Let, Switch, RecordCase, 
                      Opaque, RecordSelection, RecordExtensionLiteral,
                      Occurs_MoreThanOnce, Occurs_ZeroTimes,
                      RecordExtensionPolymorphic, DataConsSelection, DataConstructor, 
                      LetInlinable, ErrorInfo, QN, 
                      LitString, LitInt, LitBoolean, LitDouble, LitChar, LitOpaque, LitByte, LitLong,
                      CaseLiteral, CaseDataCons, DataCons;
                      
    function = flattenExpression, unflattenExpression, showExpressionStructure, 
               qualifiedName_getName, qualifiedName_isTopLevel, optimizerHelper_functionalAgent_getTypeExprExact,
               dataCons_getType, optimizerHelper_type_asRecordType, outputFieldName, 
               compiler_RecordType_RecordType_getHasFieldType, isLambdaExpression, alt_getExpr,
               expression_isWHNF, isVar, containsFree, contains, containsMatching, occursMoreThanOnce,
               substituteNoRename, dataCons_matches, dataCons_isStrict, dataCons_getFieldIndex, 
               getFunctor, expression_getArity, dataCons_getArity, getFunctorAndArity, dataCons_getOrdinal,
               dataCons_getNumberOfTypes, getOccurs, expression_getArguments, isMatchingDataConsLiteral,
               expressionIsomorphic, getSeq, prelude_seq, prelude_error,
               expression_hasStrictArguments, isSeq,
               expression_getBody, addLambdaVars, removeLambdaVars, isLiteral, expression_isConstant;
    ;
    
import Cal.Internal.Optimizer_State using
    typeConstructor = TransformState, TransformHistory, JPreludeTypeConstants;
    dataConstructor = TransformState, TransformHistory, FusionContext;
    function = newVar, substitute, transformState_isInContextBoundNames, transformState_findDef, 
               expression_isUnsaturatedExpression, transformState_getTopLevelBoundNames, 
               expression_getType, literal_getType, transformState_init, transformHistory_init,
               transformHistory_update, transformState_deeper, transformState_findType,
               inlinableState_canInlineCaseExpression, transformState_getModuleName,
               prelude_seq_expr, buildSeq2, 
               transformState_getName, transformHistory_didFusionFail, transformState_setType,
               transformHistory_fusionFailed, substituteHelper, transformState_setPerformingFusion,
               expression_couldHaveSideEffects, transformState_findKnownForm, transformState_isBeingFused,
               transformHistory_takingTooLong, transformState_findKnownDC, transformState_findKnownToNotBeForm,
               transformState_isKnownToBeWHNF, transformState_isAlreadySeqed, transformState_isTopLevelBoundName, 
               transformHistory_incrementCurrentIteration, transformHistory_setCurrentIteration;
    ;
    
import Cal.Internal.Optimizer_Traversers using
    function = transformAcc, transform, transformOnly, traverse, 
               combineTransformsWithHistory, transformer;
    ;

friend Cal.Internal.Optimizer;
friend Cal.Test.Internal.Optimizer_Test;

trace2 :: String -> a -> a;
trace2 unused v = v;

onlyRecursive_fusion :: Boolean;
onlyRecursive_fusion = False;

onlyRecursive_specialization :: Boolean;
onlyRecursive_specialization = False;

/**
 * TODO Remove this function.
 */
findString :: String -> String -> Boolean;        
findString string contains =
    indexOfString contains string != -1;

/**
 * Transformer for renaming let variables in an expression.
 */
renameLetVariables :: Boolean -> TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected renameLetVariables updateOnlyKeepable state history expression =
    case expression of    
    Let variable_name isNew isKeepable isTopLevel type expr body isRecursive arity isCoreFunction constArgs bodyWasChangedAt _ ->
        if (if updateOnlyKeepable then isKeepable || isNew else True) then
            case newVar state history variable_name "LET" of
            (history1, newVariable_name) ->
                let
                    rename :: Expression -> Expression;
                    rename expr = substituteNoRename variable_name (Var newVariable_name [] Nothing Nothing) expr;
                in
                    (history1, True, 
                         Let newVariable_name isNew isKeepable isTopLevel type (rename expr) (rename body) isRecursive arity isCoreFunction constArgs history.TransformHistory.currentIteration False);
        else
            (history, False, expression)
        ;    
    _ -> (history, False, expression);
    ;

/**
 * Transformer for renaming case variables in an expression.
 */
 
renameCaseVariables :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
renameCaseVariables state history expression =
    case expression of
    Switch expr alts ->
        let

            var_rename :: TransformHistory -> Expression -> (FieldName, QualifiedName, Type) -> (TransformHistory, Expression, (FieldName, QualifiedName, Type));
            var_rename history expr var =
                case var of
                (fn, qn, type) -> 
                    case newVar state history qn "RCV" of
                    (history1, qnPrime) ->
                        let
                            renamedExpr :: Expression;
                            renamedExpr = substituteNoRename qn (Var qnPrime [] Nothing (Just type)) expr;
                        in                        
                            (history1, renamedExpr, (fn, qnPrime, type));
                    ;
                ;
                
            vars_rename :: TransformHistory -> Expression -> [(FieldName, QualifiedName, Type)] -> (TransformHistory, Expression, [(FieldName, QualifiedName, Type)]);
            vars_rename history expr vars =
                case vars of
                [] -> (history, expr, []);
                v:vs ->
                    case var_rename history expr v of
                    (history1, expr1, vPrime) -> 
                        case vars_rename history1 expr1 vs of
                        (history2, expr2, vsPrime) -> 
                            (history2, expr2, vPrime:vsPrime);
                        ;
                    ;
                ;

            alt_rename :: TransformHistory -> Alt -> (TransformHistory, Alt);
            alt_rename history alt =
                case alt of
                Alt caseConst isPositional vars expr ->
                    case vars_rename history expr vars of
                    (history, exprPrime, varsPrime) ->
                        (history, Alt caseConst isPositional varsPrime exprPrime);
                    ;
                ;
                
            alts_rename :: TransformHistory -> [Alt] -> (TransformHistory, [Alt]);
            alts_rename history alts =
                case alts of
                [] -> (history, []);
                x:xs ->
                    case alt_rename history x of
                    (history1, xPrime) ->
                        case alts_rename history1 xs of
                        (history2, xsPrime) ->
                            (history2, xPrime:xsPrime);
                        ;
                    ;
                ;
            
        in
            case alts_rename history alts of
            (history1, altsPrime) -> (history1, True, Switch expr altsPrime);
            ;
            
    _ -> (history, False, expression);
    ;

/**
 * Transformer for renaming lambda variables in an expression.
 */
renameLambdaVariables :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
renameLambdaVariables state history expression =
    case expression of
    Lambda lvar ltype lWHNF lexpr ->
        case newVar state history lvar "RNV" of
        (history1, lvarPrime) ->
            let
                renamedOuter :: Expression;
                renamedOuter = substituteNoRename lvar (Var lvarPrime [] Nothing Nothing) lexpr;
            in
                case renameLambdaVariables state history1 renamedOuter of
                (history2, _, renamedInner) ->
                    (history2, True, Lambda lvarPrime ltype lWHNF renamedInner);
            ;
        ;    
    _ -> (history, False, expression);
    ;

renameVariables :: String -> TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
renameVariables source state history expression =
    case renameLambdaVariables state history expression of
    (history1, _, expression1) ->
        case renameCaseVariables state history1 expression1 of
        (history2, _, expression2) ->
            renameLetVariables False state history2 expression2;
        ;
    ;
            
/**
 * Will the expression be evaluated first when the given expression is evaluated.
 */

isStrictInExpression :: QualifiedName -> Expression -> Boolean;
isStrictInExpression isThisStrict inThisExpression =
    case inThisExpression of
    Var {name} -> name == isThisStrict;
    App {} ->
        let
            functor :: Expression;
            functor = getFunctor inThisExpression;
            
            matches :: Expression -> QualifiedName -> Boolean;
            matches expr qn = 
                case expr of
                Var {name} -> name == qn;
                _ -> False;
                ;
            
        in
            if matches functor isThisStrict then
                True
            else if matches functor prelude_seq then
                case flattenExpression inThisExpression [] of
                functor : args ->
                    if matches functor prelude_seq then
                        case args of
                        [] -> False;
                        x : xs ->
                            if matches x isThisStrict then
                                True
                            else
                                if isEmpty xs then
                                    False
                                else
                                    isStrictInExpression isThisStrict (head xs);
                    else
                        False;
            else
                False;
    Switch {expr} -> isStrictInExpression isThisStrict expr;
    Let {body} -> isStrictInExpression isThisStrict body;
    _ -> False;
    ;

//isStrictInExpression :: Expression -> Expression -> Boolean;
//isStrictInExpression isThisStrict inThisExpression =
//    case inThisExpression of
//    App {} ->
//        let
//            functor :: Expression;
//            functor = getFunctor inThisExpression;
//        in
//            if functor == isThisStrict then
//                True
//            else
//                case flattenExpression inThisExpression [] of
//                functor : args ->
//                    if
//                        (
//                            case functor of
//                            Var {name} -> name == prelude_seq;
//                            _ -> False;
//                        )
//                    then
//                        case args of
//                        [] -> False;
//                        a : as ->
//                            if a == isThisStrict then
//                                True
//                            else
//                                isStrictInExpression isThisStrict (head as);
//                    else
//                        False
//                    ;
//        ;
//    Switch {expr} -> expr == isThisStrict;
//    Let {body} -> isStrictInExpression isThisStrict body;
//    _ -> False;
//    ;
    
/**
 * 3.2.1 - Inlining
 * 
 * let v = ev in e
 * 
 * to
 * 
 * let v = ev in e[ev/v]
 * 
 * NOTE:
 * 
 * 1. The inliner will only work for fully saturated cases of lambda
 * expressions. This is temporary until the lambda lifter can handle code
 * generated by the specialier.
 */    


transform_3_2_2 :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_3_2_2 state history !expr =
    
    let

        noChange :: (TransformHistory, Boolean, Expression);
        noChange = (history, False, expr);
            
        /**
         * Check if the function body is a data constructor with arguments that
         * are lists. Inlining these causes slowdowns in CAL. For example
         * 
         * t42 pos shows input = ParseError pos [(SysUnExpect (shows [(head
         * input)]))];
         * 
         * Version 1 JAVA (5 newï¿½s)
         * 
         * final RTValue f3S(RTValue t42$pos$1, RTValue t42$shows$2, RTValue
         * t42$input$3, RTExecutionContext $ec) throws
         * CALExecutor.CALExecutorException { $ec.incrementNMethodCalls();
         * $ec.scCalled("Parser", "t42"); // Top level supercombinator logic
         * return new TYPE_Parse_Error.CAL_Parse_Error(t42$pos$1, new
         * TYPE_List.CAL_Cons(new
         * TYPE_Message.CAL_Sys_Un_Expect(t42$shows$2.apply(new
         * TYPE_List.CAL_Cons(new RTApp1L(i_Head_0, t42$input$3), i_Nil_0,
         * $ec)), $ec), i_Nil_0, $ec), $ec);
         * 
         * 
         */
        
        isUnwiseToInline :: Expression -> Boolean;
        isUnwiseToInline expr =
            let
                containsCons :: Expression -> Boolean;
                containsCons expr =
                    containsMatching 
                        (\!expr -> 
                            case expr of 
                            DataConstructor {dc} ->
                                case dc of
                                DataCons {name} -> name == "Cal.Core.Prelude.Cons" || name == "Cal.Core.Prelude.Nil";
                                ;
                            _ -> False;
                        ) 
                        expr;
                
            in
                containsCons expr;
            
        /**
         * Do any of the lambda vars occur more than once in the expression.
         * 
         * This is to fix inlining of DataContext.make2DOlapView in the function
         * bigDemoScriptPerfMgtView. This was making the SME1 benchmark run
         * slower.
         * 
         * TODO: This should not be a problem if the argument is a constant,
         * variable or lambda expression. So fix that detail.
         */
            
        lambaVariablesOccurMoreThanOnce :: Expression -> Boolean;
        lambaVariablesOccurMoreThanOnce !expr =
            case expr of
            Lambda lambdaVar _ _ lambdaExpr ->                
                occursMoreThanOnce lambdaVar Nothing lambdaExpr || 
                lambaVariablesOccurMoreThanOnce lambdaExpr;
            _ -> False;
            ;

        countLetExpressions :: Expression -> Int -> Int;
        countLetExpressions !expr !counter =
            let
                counter acc expr =
                    case expr of
                    Let {} -> acc+1;
                    _ -> acc;
                    ;
            in
                traverse 0 expr counter;
            
        tooManyLetExpressions :: Int;
        tooManyLetExpressions = 5;
        
        okayForInlining :: QualifiedName -> Expression -> Expression -> Boolean;
        okayForInlining letVar letExpr letBody =
            // quick check for not being in a function made by fusion
            if countLetExpressions letExpr 0 > tooManyLetExpressions then
                False
            // If the body does not reference the function then don't bother inlining. (Optimization)
            else if not (containsFree letVar letBody) then
                False
            else
                if expression_couldHaveSideEffects True state history letExpr then
                    if isStrictInExpression letVar letBody &&
                       not (occursMoreThanOnce letVar (transformState_findKnownDC state (Var letVar [] Nothing Nothing) letExpr) letBody)
                    then
                        True
                    else
                        case getOccurs letVar (transformState_findKnownDC state (Var letVar [] Nothing Nothing) letExpr) letBody of
                        Occurs_MoreThanOnce -> False;
                        Occurs_ZeroTimes -> True;
                        _ ->
                            case expression_getType state history letExpr of
                            Nothing -> False;
                            Just type -> 
                                case type of
                                FunctionType {} ->
                                    not (isLambdaExpression letExpr);
//                                    False;
                                TypeVar {} -> False;
//                                _ -> False; // HEREHEREHERE
                                _ -> True;
                                ;
                            ;
                else
                    if 
                        occursMoreThanOnce letVar (transformState_findKnownDC state (Var letVar [] Nothing Nothing) letExpr) letBody
                    then
                        if 
                            (expression_isWHNF letExpr
//                             // latest problem fix
//                             &&
//                             (
//                                 not (contains prelude_seq letBody)
////                                 (case letExpr of Lambda {} -> False; _ -> True;)
//                             )                             
                            )
                        || 
                            (transformState_isKnownToBeWHNF letExpr state && isVar letExpr)                            
                        then
                            True
                        else
                            False
                    else
                        True;

    in
        case expr of
        Let letVar isNew isKeepable isTopLevel letType letExpr letBody letIsRecursive arity isCoreFunction constVars bodyWasChangedAt inliningWasPerformed ->
            if
                inliningWasPerformed 
                || 
            // This is not working and since it is only an optimization take it out until it is fixed.
            // The problem was when specialization  made a new function the embedded let's had the
            // wrong count.
               /*
                * Lambda expression, literals and var's that are lambda variables are allowed to be inlined.
                */
               not (okayForInlining letVar letExpr letBody)
               ||
               not (inliningSafeForLambda state letVar (expression_getArity letExpr) letExpr letBody)
               || 
               (isRecursive letVar letExpr)
            then
                noChange
            else
                (case performInlining state history letVar (expression_getArity letExpr) letExpr letBody False of
                (history1, wasChanged1, letBodyPrime) ->
                    (history1, wasChanged1,
                            Let 
                                letVar 
                                isNew 
                                isKeepable
                                isTopLevel
                                letType 
                                letExpr 
                                letBodyPrime 
                                letIsRecursive 
                                arity 
                                isCoreFunction 
                                constVars
                                ( 
                                    if wasChanged1 then
                                        history.TransformHistory.currentIteration
                                    else
                                        bodyWasChangedAt
                                )
                                True);
                );    

        // LetInlinable is a flag to always inline the expression. This is for a
        // fusion attempt.
        LetInlinable letVar letType letExpr letBody arity counter constVars ->
            if okayForInlining letVar letExpr letBody then
                case
                    performInlining state history letVar (expression_getArity letExpr) letExpr letBody True of
                (history1, wasChanged1, letBodyPrime) ->
                    if True || (wasChanged1 && counter >= 4) then
                        (history1, True, letBodyPrime)
                    else
                        (history1, True, 
                             LetInlinable letVar letType letExpr letBodyPrime arity (counter+1) constVars
                        );
            else
                (history, False, expr);
            
        _ -> noChange;
        ;

performInlining :: TransformState -> TransformHistory -> QualifiedName -> Int -> Expression -> Expression -> Boolean -> (TransformHistory, Boolean, Expression);
performInlining state history !letVar arguments !letExpr letBody forceInlining = 
    // only embed lambda if the expression is saturated.
    if isLambdaExpression letExpr then
        (case transform state history letBody (inlineLambda letVar arguments (expression_hasStrictArguments letExpr) forceInlining letExpr) of
        (history1, wasChanged1, expr1) ->
            (history1, wasChanged1, expr1);
        )
    else
        (            
        case transform state history letExpr (combineTransformsWithHistory (renameLetVariables False) (renameCaseVariables)) of
        (history1, _, letExprPrime) ->
            substituteHelper (transformState_deeper state letVar) history1 letVar letExprPrime letBody;
        );    


/**
 * A lambda expression can be safely inlined if for each lambda variable either that variable
 * only occurs once in the lambda expression or the value(s) bound to that variable require 
 * no further computation.
 */
 
inliningSafeForLambda :: TransformState -> QualifiedName -> Int -> Expression -> Expression -> Boolean;
inliningSafeForLambda state functor arity lambdaExpr inlineIntoExpr =
    let
        /**
         * A list of all calls of the lambda expression in the body. Make sure
         * they are all long enough
         */
        allCalls :: [[Expression]];
        allCalls =  
            let
                isCall :: [Expression] -> Boolean;
                isCall flatExpr =
                    case flatExpr of
                    actualFunctor : actualArgs -> 
                        case actualFunctor of
                        Var {name} ->
                            if functor == name then
                                arity == length actualArgs
                            else
                                False;
                        _ -> False;
                        ;
                    ;    
                    
                selectCall :: TransformState -> [[Expression]] -> Expression -> ([[Expression]], Expression);
                selectCall state acc expr =
                    let
                        flatExpr :: [Expression];
                        flatExpr = flattenExpression expr [];
                    in
                        if (
                           case getFunctor expr of
                           Var {name} -> functor == name;
                           _ -> False;
                           ) then
                            if isCall flatExpr then
                                // tail is to get rid of the functor and only save the args
                                (tail flatExpr:acc, expr)
                            else
                                (acc, expr)
                        else
                            (acc, expr);
           in
               case transformAcc state [] inlineIntoExpr selectCall of
               (calls, _) -> calls;
               ;
        
        removeArg :: [[Expression]] -> [[Expression]];
        removeArg calls = map tail calls;

        /**
         * Make sure that for each call of the lambda expression that the variables bound to
         * are not going to be such that extra calculation is required.
         */
        lambdaIsOkay :: Expression -> [[Expression]] -> Boolean;
        lambdaIsOkay expr calls =
            case expr of
            Lambda lambdaVar _ _ lambdaExpr ->
                if orList (map isEmpty calls) then
                    False
                else if occursMoreThanOnce lambdaVar Nothing lambdaExpr then
                    andList (map (\call -> expression_isWHNF (head call) || isVar (head call)) calls) 
                    &&
                    lambdaIsOkay lambdaExpr (removeArg calls)
                else
                    lambdaIsOkay lambdaExpr (removeArg calls);
            _ -> True;
            ;
            
    in
        lambdaIsOkay lambdaExpr allCalls;
        
/* @example */
transform_3_2_2Examples :: JPreludeTypeConstants -> Boolean;
transform_3_2_2Examples typeConstants = 
    let
        nameToTypeList :: [(QualifiedName, Type)];
        nameToTypeList = [
                          (varName, (TypeConstTest "String")),
                          (fQN, FunctionType (TypeId 1 True) (TypeId 1 False) False),
                          (fQN3, FunctionType (TypeId 1 False) (TypeId 1 False) False)
                          ];

        initState :: Expression -> TransformState;
        initState expr = transformState_init (QN "ModuleName" "functionName") typeConstants nameToTypeList [] [] expr [] [];

        initHistory :: TransformHistory;
        initHistory = transformHistory_init;
        
        varName :: QualifiedName;
        varName = QN "ModuleName" "varName";
        
        lambda :: Expression;
        lambda = Lambda varName (TypeId 1 False) False (Var varName [] Nothing Nothing);
        
        helloWorldString :: Expression;
        helloWorldString = Literal (LitString "hello world");

        // Test1: let varName = "hello world" in varName
        expr1 :: Expression;
        expr1 = Let varName False False False Nothing helloWorldString (Var varName [] Nothing Nothing) False 0 False [] 1 False;
        
        check1 :: Expression -> Boolean;
        check1 !expr =
            case expr of
            Let {body} ->
                assert (body == helloWorldString);
            ;
            
        // Test2: let f !a = a in f arg1. Make sure that f is not inlined
        // because of reduced strictness
        
        fQN :: QualifiedName;
        fQN = QN "Cal.Core.Prelude" "f";
        
        fVar :: Expression;
        fVar = Var fQN [] Nothing Nothing;
        
        aQN :: QualifiedName;
        aQN = QN "Cal.Core.Prelude" "a";
        
        aVar :: Expression;
        aVar = Var aQN [] Nothing (Just (TypeId 1 True));
        
        arg1Var :: Expression;
        arg1Var = Var (QN "Cal.Core.Prelude" "arg1") [] Nothing (Just (TypeId 1 False));
        
        defExpr :: Expression;
        defExpr = Lambda aQN (TypeId 1 False) False aVar;
        
        bodyExpr :: Expression;
        bodyExpr = App fVar arg1Var; 
        
        expr2 :: Expression;
        expr2 = Let fQN False False False Nothing defExpr bodyExpr False 1 False [False] 1 False; 

        check2 :: Expression -> Boolean;
        check2 !expr =
            case expr of
            Let {body} ->
                case body of
                App app1 app2 ->
                    assert (app1 == fVar) && assert (app2 == arg1Var);
                ;
            ;

        // Test3: let f a = a in f arg1. Make sure that f is inlined because the
        // strictness is not reduced.
        
        fQN3 :: QualifiedName;
        fQN3 = QN "Cal.Core.Prelude" "f3";
        
        fVar3 :: Expression;
        fVar3 = Var fQN3 [] Nothing Nothing;
        
        aQN3 :: QualifiedName;
        aQN3 = QN "Cal.Core.Prelude" "a3";
        
        aVar3 :: Expression;
        aVar3 = Var aQN3 [] Nothing (Just (TypeId 1 True));
        
        arg1Var3 :: Expression;
        arg1Var3 = Var (QN "Cal.Core.Prelude" "arg13") [] Nothing (Just (TypeId 1 False));
        
        defExpr3 :: Expression;
        defExpr3 = Lambda aQN3 (TypeId 1 False) False aVar3;
        
        bodyExpr3 :: Expression;
        bodyExpr3 = App fVar3 arg1Var3; 
        
        expr3 :: Expression;
        expr3 = Let fQN3 False False False Nothing defExpr3 bodyExpr3 False 1 False [False] 1 False; 

        check3 :: Expression -> Boolean;
        check3 !expr =
            case expr of
//            Let {body} ->
//                case body of
                App lambda arg1 ->
                    assert (arg1 == arg1Var3) && assert (defExpr3 == lambda);
                ;
//            ;
            
        performInlining :: Expression -> Expression;
        performInlining testExpr =
            let
                transform :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
                transform = 
                    transform_3_2_2 `combineTransformsWithHistory`
                    (transform_3_2_1 False) `combineTransformsWithHistory`
                    transform_3_1;
            in
                case transform (initState testExpr) initHistory testExpr of
                (_, _, expr) -> expr;
                ;
                
    in
        assert (check1 (performInlining expr1)); //&&
//        assert (check2 (performInlining expr2));
//        assert (check3 (performInlining expr3));
                    
// /**
// * 3.3.2 - case elimination
// *
// * case v1 of v2 -> e
// *
// * to
// *
// * e [v1/v2]
// */
//    
// transform_3_3_2 :: Expression -> Expression;
// transform_3_3_2 caseExpression =
// case caseExpression of
// Switch expr alts ->
// if length alts == 1 then
// if atls.#1.#1
// alts.#1
// Alt alt::(CaseConst, [String], Expression) deriving Inputable, Outputable;
// else
// caseExpression;
// _ -> caseExpression;
// ;
    
/**
 * 3.5.1 - Case float from App
 * 
 * (case ec of alt1 -> e1; alt2 -> e2; ...) v
 * 
 * to
 * 
 * case ec of alt1 -> e1 v; alt2 -> e2 v; ...
 * 
 * @arg state Information about the current expression.
 * @arg history History of the transformation.
 * @arg expression Expression to transform
 * @return The transformed expression is applicable
 * 
 * TODO This should be renaming the alternative variables to avoid name capture.
 */

transform_3_5_1 :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_3_5_1 state history !expression =
    let   
        noChange :: (TransformHistory, Boolean, Expression);
        noChange = (history, False, expression);

        embedAlt :: TransformHistory -> Expression -> Alt -> (TransformHistory, Boolean, Alt);
        embedAlt history expr !alt =
            case alt of
            Alt caseConst ip vars altExpr -> 
                (history, True, Alt caseConst ip vars (App altExpr expr));
            ;
            
        embedAlts :: TransformHistory -> Expression -> [Alt] -> (TransformHistory, Boolean, [Alt]);
        embedAlts history expr !alts =
            case alts of
            [] -> (history, False, []);
            x:xs ->
                case embedAlt history expr x of
                (history1, wasChanged1, xPrime) -> 
                    case embedAlts history1 expr xs of
                    (history2, wasChanged2, xsPrime) -> 
                        if wasChanged1 || wasChanged2 then
                            (history2, True, xPrime : xsPrime)
                        else
                            (history, False, alts);
                    ;                                
                ;
            ;            
        in    
            case expression of
            App caseExpr appExpr ->
                case caseExpr of
                Switch switchExpr alts ->
                    case switchExpr of
                    Var {} ->
                        case embedAlts history appExpr alts of
                        (history1, wasChanged1, altsPrime) -> (history1, wasChanged1, Switch switchExpr altsPrime);
                        ;
                    _ -> noChange;
                    ;
                _ -> noChange;
                ;
        _ -> noChange;
        ;

/**
 * Embed the outer case into the inner case. See test 7-9 and 15 in Optimizer_Tests.cal
 * 
 *   TODO: What about name capture. This should be safe now right with the renaming. Check it out.
 */
 
transform_3_5_2 :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_3_5_2 state history !expression =
    case expression of
    Switch switchOuter switchOuterAlts ->
        case switchOuter of
        Switch switchInner switchInnerAlts ->
            let
                updateAlt :: TransformHistory -> Alt -> (TransformHistory, Alt);
                updateAlt history1 alt =
                    case alt of
                    Alt caseConst isPositional vars expr ->
                        case transform state history1 (Switch expr switchOuterAlts) (renameLetVariables True) of
                        (history2, _, exprPrime) ->
                            (history2, Alt caseConst isPositional vars exprPrime);
                        ;
                    ;
                
                updateAlts :: TransformHistory -> [Alt] -> (TransformHistory, [Alt]);
                updateAlts history1 alts =
                    case alts of
                    [] -> (history1, []);
                    a:as ->
                        case updateAlt history1 a of
                        (history2, aPrime) ->
                            case updateAlts history2 as of
                            (history3, asPrime) ->
                                (history3, aPrime:asPrime);
                            ;
                        ;
                    ;
            in
                case updateAlts history switchInnerAlts of
                (history1, switchInnerAltsPrime) ->
                    (history1, True, Switch switchInner switchInnerAltsPrime);
                ;

        _ -> (history, False, expression);
        ;
    _ -> (history, False, expression);
    ;
       
/**
 * let
 *      outerExpr1 = case innerExpr of <innerPattern1> -> ...;      // Inner Switch
 * in
 *      case outerExpr1 of          // Outer Switch
 *      <outerPattern1> -> ... 
 *      <outerPattern2> -> ... outerExpr1? ...
 *      
 *       =>
 *       
 * case innerExpr of
 *      <innerPattern1> ->
 *          let 
 *              outerExpr1 = innerExpr1;
 *          in
 *              case outerExpr1 of
 *              <outerPattern1> -> ...
 *              <outerPattern2> -> ... outerExpr1? ...
 */
 
transform_3_5_2_withInlining :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_3_5_2_withInlining state history !expression =
    case expression of
    Let letVar isNew isKeepable isTopLevel letType letExpr letBody letIsRecursive arity isCoreFunction constVars bodyWasChangedAt inliningWasPerformed ->
        case letBody of
        Switch switchOuter switchOuterAlts ->
            case switchOuter of
            Var {name} ->
            if 
                switchOuter.Var.name == letVar && 
                (
                    let
                        innerIsSwitch :: Expression -> Boolean;
                        innerIsSwitch expr =
                            case expr of
                            Let {body} -> innerIsSwitch body;
                            Switch {} -> True;
                            _ -> False;
                            ;
                    in
                        innerIsSwitch letExpr
                ) then
                    let                    
                        embed :: Expression -> (TransformHistory, Boolean, Expression);
                        embed expr =
                            case expr of
                            Let variable isNew isKeepable isTopLevel type expr body isRecursive arity isCoreFunction constArgs bodyWasChangedAt inliningWasPerformedhasStrictArguments ->
                                case embed body of
                                (history1, wasChanged1, bodyPrime) ->
                                    (history1, wasChanged1, Let variable isNew isKeepable isTopLevel type expr bodyPrime isRecursive arity isCoreFunction constArgs bodyWasChangedAt inliningWasPerformedhasStrictArguments);
                                ;
                            Switch switchInner switchInnerAlts ->
                                    let
                                        switchOuterAltsPrime :: QualifiedName -> [Alt];
                                        switchOuterAltsPrime letVarPrime = 
                                            case substituteNoRename name (Var letVarPrime [] Nothing Nothing) (Switch switchOuter switchOuterAlts) of
                                            Switch _ alts -> alts;
                                            ;
                                        
                                        updateAlt :: TransformHistory -> Alt -> (TransformHistory, Alt);
                                        updateAlt history alt =
                                            case newVar state history letVar "904i" of
                                            (history1, letVarPrime) ->
                                                case alt of
                                                Alt caseConst isPositional vars expr ->
                                                    (
                                                        history1, 
                                                        Alt caseConst isPositional vars
                                                        (
                                                            Let letVarPrime True False False letType expr   
                                                            (Switch (Var letVarPrime [] Nothing Nothing) (switchOuterAltsPrime letVarPrime)) False 0 False [] 0 False
                                                        )
                                                    )
                                                    ;
                                                ;
                                            ;
                                        
                                        updateAlts :: TransformHistory -> [Alt] -> (TransformHistory, [Alt]);
                                        updateAlts history alts = 
                                            case alts of
                                            [] -> (history, []);
                                            a:as ->
                                                case updateAlt history a of
                                                (history1, aPrime) ->
                                                    case updateAlts history1 as of
                                                    (history2, asPrime) ->
                                                        (history2, aPrime :asPrime);
                                                    ;
                                                ;
                                            ;
                                    in
                                        (
                                            case updateAlts history switchInnerAlts of
                                            (history1, switchInnerAltsPrime) ->
                                                (history1, True, Switch switchInner switchInnerAltsPrime);
                                        );
                            ;
                    in
                        embed letExpr
                else
                    (history, False, expression);
            _ -> (history, False, expression);
            ;
        
        // Okay try pushing the outer let into the inner let
        Let letVar2 isNew2 isKeepable2 isTopLevel2 letType2 letExpr2 letBody2 letIsRecursive2 arity2 isCoreFunction2 constVars2 bodyWasChangedAt2 inliningWasPerformed2 ->
            if containsFree letVar2 letExpr || containsFree letVar letExpr2 then
                (history, False, expression)
            else
                case transform_3_5_2_withInlining 
                        state 
                        history
                        (Let letVar isNew isKeepable isTopLevel letType letExpr letBody2 letIsRecursive arity isCoreFunction constVars bodyWasChangedAt inliningWasPerformed) of
                (history2, wasChanged2, expression2) ->
                    if wasChanged2 then
                        (history2, True, Let letVar2 isNew2 isKeepable2 isTopLevel2 letType2 letExpr2 expression2 letIsRecursive2 arity2 isCoreFunction2 constVars2 bodyWasChangedAt2 inliningWasPerformed2)
                    else
                        (history2, False, expression);
            ;
        _ -> (history, False, expression);
        ;
    _ -> (history, False, expression);
    ;

/**
 * Simplify statements such as "x `seq` x" to "x". See tests 30-32 in Optimizer_Tests.cal. 
 * Now also corresponds to tests 44 to 48, and 65, and 95.
 * 
 * The following transformations are performed.
 * 
 * 1. x `seq` x => x
 * 2. Lambda x1 (Lambda x2 ... (prelude.seq x1 y) => Lambda !x1 (Lambda x2 ... y iff the intervening lambda vars are all not strict
 * 3. (x `seq` case x of ...) => (case x of ...).
 * 4. (seq x (seq y ((f x) y))) where f :: !a -> !b -> ... => (f x) y
 * 5. y `seq` z => z iff y is known to be WHNF
 * 6. (\!x -> case x of ...) => (\x -> case x of ...) 
 *  
 */
transform_simplifySeq :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_simplifySeq state history !expression =
    case getFunctor expression of
    Lambda lVar lType lWHNF lExpr ->
        let
            /**
             * See if the first inner call to Prelude.seq is for the lVar variable. If so 
             * mark the type of lVar as strict. Another optimization will take care of removing 
             * the inner seq.
             */
            isInnerVar :: Expression -> Boolean;
            isInnerVar expr = 
                case expr of
                // (seq x ...)
                App {} ->
                    case flattenExpression expr [] of
                    functor : args -> 
                        case functor of
                        Var {name} ->
                            if name == prelude_seq then
                                case args of
                                [] -> False;
                                x : _ ->
                                    case x of
                                    Var {name} -> name == lVar;
                                    _ -> False;
                                    ;
                            else
                                False;
                        _ -> False;
                        ;
                    ;                
                Lambda {expr, type} ->
                    if type_isStrict type then 
                        False
                    else
                        isInnerVar expr;
                _ -> False; // TODO This can have more cases 
                ;
        in
            case flattenExpression expression [] of
            functor : args ->
                // 2. Lambda x1 (Lambda x2 ... (prelude.seq x1 y) => Lambda !x1 (Lambda x2 ... y iff the intervening lambda vars are all not strict
                if isInnerVar lExpr && not (type_isStrict lType) then
                    if type_isStrict lType then
                        (history, False, expression)
                    else
                        (history, True, unflattenExpression ((Lambda lVar (type_applyStrictness lType True) lWHNF lExpr):args))
                // 6. (\!x -> case x of ...) => (\x -> case x of ...)
                else if (
                    case lExpr of
                    Switch {expr} ->
                        case expr of
                        Var {name} -> name == lVar;
                        _ -> False;
                        ;
                    _ -> False;
                ) then
                    if type_isStrict lType then
                        (history, True, unflattenExpression ((Lambda lVar (type_setStrictness lType False) lWHNF lExpr):args))
                    else
                        (history, False, expression)
                else
                    (history, False, expression);
        ;
    
    Var {name} ->
        // 3, 4 or 5
        if name == prelude_seq then
            case flattenExpression expression [] of
            functor : args ->
                case 
                    functor of
                Var {name} ->
                    if name == prelude_seq then
                        case args of
                        a1:args1 ->
                            // seq a1 ...
                            if (
                                if transformState_isKnownToBeWHNF a1 state 
                                    || transformState_isAlreadySeqed a1 state
                                then
                                    not (isEmpty args1) && 
//                                    && isVar a1
                                    (
                                        case a1 of
                                        Var {} -> True;
                                        Literal {} -> True;
                                        Lambda {} -> True;
                                        ErrorInfo {} -> True;
                                        DataConstructor {} -> True;
                                        _ -> False;
                                    )
                                else
                                    False
                                ) 
                            then
                                    // #5. the a1 expression is known to be strict already. 
                                (history, True, unflattenExpression args1)
                            else
                                case args1 of
                                a2:args2 ->
                                    case a1 of
                                    Var {} ->
                                        if a1 == a2 then
                                            (history, True, unflattenExpression (a2:args2))
                                        else
                                            /*
                                             * #3. This is for converting (x `seq` case x of ...) to (case x of ...).
                                             * This also allows for lambda's to be wrapping the case. The lambdas
                                             * must not be strict though.
                                             */
                                            let
                                                helper expr =
                                                    case expr of
                                                    Lambda lVar lType lWHNF lExpr ->
                                                        if type_isStrict lType then
                                                            False
                                                        else
                                                            helper lExpr;
                                                    
                                                    Switch switchExpr switchAlts -> switchExpr == a1;
                                                    _ -> False;
                                                    ;
                                            in
                                                if helper a2 then
                                                    (history, True, unflattenExpression (a2:args2))
                                                else
                                                    simplifySeq_case4 state history expression;

                                    Literal {} -> (history, True, unflattenExpression (a2:args2));
                                    Lambda {} -> (history, True, unflattenExpression (a2:args2));
                                    ErrorInfo {} -> (history, True, unflattenExpression (a2:args2));
                                    DataConstructor {} -> (history, True, unflattenExpression (a2:args2));
                                    _ -> simplifySeq_case4 state history expression;
                                    ;                            
                                _ -> simplifySeq_case4 state history expression;
                            ;
                        _ -> (history, False, expression);
                    else
                        (history, False, expression)
                    ;
                
                _ -> (history, False, expression);
                ;
        else
            (history, False, expression);
    _ -> (history, False, expression);
    ;

// 4. (seq x (seq y (((f x) c) y))) where f :: !a -> !b -> ... => ((f x) c) y   c's are constant arguments

simplifySeq_case4 :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
simplifySeq_case4 state history expression =
    let
        
        inExpression :: Expression;
        inExpression = expression;
        
        noChange :: (TransformHistory, Boolean, Expression);
        noChange = (history, False, expression);
        
//        inSameOrder :: Boolean;
//        inSameOrder seqedVars argVars =
//            case argVars of
//            [] -> seqedVars == [];
//            av:avs ->
//                if head seqedVars == av then
//                    inSameOrder tail seqedVars avs
//                else
//                    inSameOrder seqedVars avs;
            
        /**
         * @arg history
         * @arg expression
         * @arg seqVars The list contains the seq'ed expressions. The expression may contain Just <expression>
         * which is a variable. Or Nothing which means that the seq'ed expression is known to be in WHNF
         * so it can be safely ignore when checking argument strictness.
         */
        helper history expression seqVars = 
            case flattenExpression expression [] of
            functor : args ->
                // (seq ...
                if isSeq functor then
                    case args of
                    [] -> noChange;
                    a1 : args1 ->
                        // (seq a1 ...
                        if isVar a1 && not (isEmpty args1) then
                            helper history (unflattenExpression args1) (a1:seqVars)
                        else
                            noChange;
                else
                    if isEmpty seqVars then
                        noChange
                    // have a list of seq'ed vars x, y ... . See if the function call has strict args in the right order
                    else
                        let
                            /**
                             * The order of the seqed vars must match the order of the arguments
                             * to the functions. The arguments of the function corresponding to the
                             * seqed vars must be strict. The other arguments must correspond to 
                             * non-strict arguments or already be in WHNF
                             */
//                            checkStrictnessAndOrder :: []
                            checkStrictnessAndOrder argVars argTypes seqVars =
                                case argVars of
                                [] -> seqVars == [];
                                av : avs ->
                                    case argTypes of
                                    at : ats ->
                                        case seqVars of
                                        // no more seq'ed var so what ever happens with the args is okay
                                        [] -> True;   
                                        sv : svs ->
                                            // If the current arg matches the next seq'ed var
                                            if sv == av then
                                                // make sure that av is strict
                                                if type_isStrict at then
                                                    // okay matches and strict 
                                                    checkStrictnessAndOrder avs ats svs
                                                else
                                                    // the arg is not strict so removed the seq and using f would fail
                                                    False
                                            else
                                                if type_isStrict at then
                                                    // if the expression passed is constant that is okay else not okay
                                                    if expression_isConstant av then
                                                        checkStrictnessAndOrder avs ats seqVars
                                                    else
                                                        False
                                                else
                                                    // arg is not strict so continue.
                                                    checkStrictnessAndOrder avs ats seqVars;
                                        ;
                                    ;
                                ;
                        in
                            case expression_getType state history functor of
                            Nothing -> noChange;
                            Just type ->
                                if
                                    checkStrictnessAndOrder args (flattenType type) (reverse seqVars) then
                                    (history, True, expression)
                                else
                                    noChange;
                ;
            ;
            
    in
        helper history expression [];
    
    
/**
 * Looks for expression of the form "<DataConstructor> arg1 arg2 ... argk",
 * <Literal> or a switch where all the alternative have the former two patterns.
 * 
 * @arg expression The expression to check.
 * @arg recursiveCallChecker If the value of the inner case is a recursive call to the same function then it can be left unchanged in the body and the embedding will succeed. This is to handle the optimization of Prelude.isNothing (List.find (\x -> x == 1) [1::Int]);
 * @return Returns true iff the expression returns a known kind of value.
 */

expressionIsExplicitDC :: Expression -> (Expression -> Boolean) -> Boolean; 
expressionIsExplicitDC !expression recursiveCallChecker =
    case expression of
        DataConstructor {} -> True;
        Literal {} -> True;
        App e1 e2 -> expressionIsExplicitDC e1 recursiveCallChecker;
        Switch expr alts -> altsAllHaveExplicitDC alts recursiveCallChecker;
        Let {body} -> expressionIsExplicitDC body recursiveCallChecker; 
        _ -> False;
    ;
    

/**
 * Checks if the expression of this Alt has an known kind of value.
 * 
 * @arg alt The Alt to check.
 * @arg recursiveCallChecker If the value of the inner case is a recursive call to the same function then it can be left unchanged in the body and the embedding will succeed. This is to handle the optimization of Prelude.isNothing (List.find (\x -> x == 1) [1::Int]);
 * @return Returns true iff the alt returns a known kind of value.
 */
    
altHasExplicitDC :: Alt -> (Expression -> Boolean) -> Boolean;
altHasExplicitDC !alt recursiveCallChecker =
    case alt of
    Alt {expr} ->
        if recursiveCallChecker expr then
            True
        else
            expressionIsExplicitDC expr recursiveCallChecker;
    ;    
        
/**
 * Checks if the atls all return values of a known kind.
 * 
 * @arg alts The alternatives to check.
 * @arg recursiveCallChecker If the value of the inner case is a recursive call to the same function then it can be left unchanged in the body and the embedding will succeed. This is to handle the optimization of Prelude.isNothing (List.find (\x -> x == 1) [1::Int]); 
 * @return Returns true iff the alls all return a known kind of value.
 */

altsAllHaveExplicitDC :: [Alt] -> (Expression -> Boolean) -> Boolean;
altsAllHaveExplicitDC alts recursiveCallChecker =
    foldLeft (\cur alt -> cur && altHasExplicitDC alt recursiveCallChecker) True alts;

/**
 * Checks if the case constant (from the outer alternative) matches the return
 * expression from the inner alternative.
 * 
 * Example True == isMatching (Cons a b) (CaseDataCons "Cons")
 * 
 * @arg expri The inner expression to match
 * @arg cco The case constant from the outer expression to match.
 * @return True if the out case constant matches the inner return expression.
 */
    
isMatching :: Expression -> CaseConst -> Boolean;
isMatching !expri !cco =
    case expri of
    Literal {value=li} -> 
        case cco of
        CaseLiteral lo -> li == lo;
        // Special case for booleans. TODO see if this can be removed.
        CaseDataCons dco -> isMatchingDataConsLiteral dco li;
        _ -> False;
        ;
    DataConstructor dci -> 
        case cco of
        CaseDataCons dco -> dci == dco;
        CaseLiteral li -> isMatchingDataConsLiteral dci li; // switch them around to reused the above case
        _ -> False;
        ;
    App e1 e2 ->
        isMatching e1 cco;
    _ -> 
        False;
    ;

isMatchingAlt :: Alt -> Alt -> Boolean;
isMatchingAlt !alti !alto = isMatching alti.Alt.expr alto.Alt.caseConst;

/**
 * Search for an alternative in alts with the same functor as alt
 * 
 * @arg alti The alternative to match.
 * @arg altso The list of alternatives to search for a match.
 * @return An alternative in altso that has the same functor as alti.
 */

findMatchingAlt :: Alt -> [Alt] -> Alt;
findMatchingAlt !alti !altso =
    // always finds a match
    case (find (isMatchingAlt alti) altso) of
    Just match -> match;
    Nothing -> error ("findMatchingAlt:\n" ++ "    alti: " ++ show alti ++ "\n" ++ "    altso:" ++ show altso ++ "\n");
    ;
    
    
/**
 * Convert the fieldNameToVar list to a straight list of variables.
 */                                                 
getVars :: [(FieldName, QualifiedName)] -> [Maybe QualifiedName];
getVars fnqns = getVarsHelper fnqns 1;

getVarsHelper :: [(FieldName, QualifiedName)] -> Int -> [Maybe QualifiedName];
getVarsHelper !fnqns counter =
    case fnqns of
    [] -> [];
    fnqn : rest ->
        case fnqn of
        (fn, qn) ->
            if fn.FNOrdinal.ordinal == counter then
                Just qn : getVarsHelper rest (counter+1)
            else
                Nothing : (getVarsHelper fnqns (counter+1));
        ;    
    ;                

/**
 * Convert straight list of variables to a fieldNameToVarList.
 */                                                 
 
fromVars :: [Maybe QualifiedName] -> [(FieldName, QualifiedName)];
fromVars qns = fromVarsHelper qns 1;
 
fromVarsHelper :: [Maybe QualifiedName] -> Int -> [(FieldName, QualifiedName)];
fromVarsHelper !qns counter =
    case qns of
    [] -> [];
    qn : rest ->
        case qn of
        Nothing -> fromVarsHelper rest (counter + 1);
        Just qn_Just_value ->
            (FNOrdinal counter, qn_Just_value) : fromVarsHelper rest (counter+1);
        ;    
    ;                

/* @example */
/**
 * 3.5.5 - Lambda floating through case. This is another one I made up and it
 * not part of the original paper but would go here if it was.
 * 
 * case (\v1 v2 ... vk -> <expr>) of <alts>
 * 
 * to
 * 
 * \v1 v2 ... vk -> case expr of <alts>
 * 
 * TODO Rename the variables raised to avoid name capture.
 */
        
transform_3_5_5 :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_3_5_5 state history !caseExpr =
    let
        noChange :: (TransformHistory, Boolean, Expression);
        noChange = (history, False, caseExpr);
    in
        case caseExpr of
        Switch lambdaExpr ao ->
            case lambdaExpr of
            Lambda lambdaVar lambdaType lambdaWHNF lambdaExpr ->
                case newVar state history lambdaVar "" of
                (history1, newLambdaVar) ->
                    case substituteHelper state history1 lambdaVar (Var newLambdaVar [] Nothing Nothing) (Switch lambdaExpr ao) of
                    (history2, wasChanged2, lambdaExprPrime) ->
                        if wasChanged2 then
                            (history2, True, Lambda newLambdaVar lambdaType lambdaWHNF lambdaExprPrime)
                        else
                            noChange;
                    ;
                ;    
            _ -> noChange;
            ;
        _ -> noChange;
        ;

/**
 * Try to figure out what data value corresponds to this value. Either the value is
 * a data constructor or a literal or the type can be inferred from the context.
 */
 
getForm :: TransformState -> Expression -> Expression -> [Expression] -> (Expression, [Expression], [(FieldName, QualifiedName, Type)], Boolean);
getForm state expr functor args = 
    case functor of
    Literal {} -> (functor, args, [], False);
    DataConstructor {} -> (functor, args, [], False);
    _ -> 
        case transformState_findKnownForm state expr of
        Just caseConst ->
            case caseConst of
            (_, head, vars) ->
                case head of
                CaseLiteral literal -> (Literal literal, [], [], True);
                CaseDataCons dataCons -> (DataConstructor dataCons, [], vars, True);
            ;
            ;
        _ -> (functor, args, [], False); // no change
        ;
    ;

/**
 * Evaluate case expression with known values. See tests 22-29, 64, 66 and 88 in Optimizer_Test.cal for examples. 
 */
transform_evaluateCase :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_evaluateCase state history !caseExpr =
    case caseExpr of
    Switch switchExpr alts ->
        case
            (
                case flattenExpression switchExpr [] of
                head : tail -> getForm state switchExpr head tail;
            )
        of
        (functor, actualArgs, inferredVars, isInferred) ->
            case functor of
            Literal {value=literal} ->
                // args == []
                let
                    /**
                     * Does the given alt match the switch expression literal?
                     */
                    matchAlt :: Alt -> Boolean;
                    matchAlt !alt =
                        case alt of
                        Alt {caseConst, vars} -> 
                            if matchCaseConstAndLiteral caseConst literal then
                                True
                            else
                                False;
                        ;                
                        
                in
                    case find matchAlt alts of
                    Nothing -> (history, False, caseExpr);
                    Just alt ->
                        case alt of
                        Alt {expr} ->
                            (history, True, expr);
                        ;
                    ;    
            DataConstructor switchDC ->
                let
                    /**
                     * Does the current Alt match the data constructor of the switch expression.
                     */
                    matchAlt :: Alt -> Boolean;
                    matchAlt !alt =
                        case alt of
                        Alt {caseConst, vars} -> 
                            if matchCaseConstAndDataConstructor caseConst switchDC then
                                True
                            else
                                False;
                        ;

                    /**
                     * Converts a given field name/qualified name pair to a qualified name and the expression
                     * fomr the Switch expression that correspondings to the given field name. 
                     */
                    varNameToExpr_actualArgs :: (FieldName, QualifiedName, Type) -> (QualifiedName, Expression, Type);
                    varNameToExpr_actualArgs var =
                        case var of
                        (fieldName, varName, type) ->
                            let
                                index :: Int;
                                index = dataCons_getFieldIndex switchDC fieldName;
                                
                                varExpr :: Expression;
                                varExpr = List.subscript actualArgs index;
                            in
                                (varName, varExpr, type);
                        ;

                    // TODO Should we add the type to the output. Currently not used.
                    varNameToExpr_inferredArgs :: (FieldName, QualifiedName, Type) -> (QualifiedName, Expression, Type);
                    varNameToExpr_inferredArgs var =
                        case var of
                        (fieldName, varName, type) ->
                            let
                                varExpr :: Expression;
                                varExpr =
                                    case find (\entry -> matchFN switchDC fieldName entry.#1) inferredVars of
                                    Just match -> Var match.#2 [] Nothing Nothing;
                                    ;
                            in
                                (varName, varExpr, type);
                        ;
                            
                            
                    /**
                     * Get a list that maps the alt variable to the corresponding expression.
                     */
                    varNameToExprs :: ((FieldName, QualifiedName, Type) -> (QualifiedName, Expression, Type)) -> [(FieldName, QualifiedName, Type)] -> [(QualifiedName, Expression, Type)];
                    varNameToExprs varNameToExpr fieldNameToQualifiedNames =
                        map varNameToExpr fieldNameToQualifiedNames;
                                            
                    /**
                     * The pattern has variables that correspond to expressions in the switch expressions.
                     * Build a series of let expression that map the alt variables to the corresponding expression.
                     * For example,
                     * 
                     *  case Thing x y z of
                     *  Thing a b c -> ...
                     *  
                     *  Converts to
                     *  
                     *  let
                     *      a = x;
                     *      b = y;
                     *      c = z;
                     *  in
                     *      ...
                     *      
                     * @arg varNameToExprs List of the variables in the pattern
                     * @arg altExpr The expression that is the body of the alt expression that the pattern is matched on.
                     * @arg argVars23 The values of the arguments to the data constructor in the correct order. 
                     */
                    buildLetExpr :: [(QualifiedName, Expression, Type)] -> Expression -> [Expression] -> Expression;
                    buildLetExpr varNameToExprs altExpr argVars23 =                        
                        let
                            argVars :: [Expression];
                            argVars = map (\fnqn -> Var fnqn.#1 [] Nothing Nothing) varNameToExprs;
                            
                            /**
                             * @arg varNameToExprs A list of the vars in the pattern.
                             * @arg value The inner expression
                             * This is used to construct strictness.
                             */
                            letExpr :: [(QualifiedName, Expression, Type)] -> Expression -> Expression;
                            letExpr varNameToExprs value = 
                                case varNameToExprs of
                                [] -> selectStrictArguments state history switchDC argVars 0 value;
                                vn : vns ->
                                    case vn of
                                    (vName, vExpr, vType) -> 
                                        let
                                            type :: Maybe [Type];
                                            type = 
                                                case expression_getType state history vExpr of
                                                Nothing -> Just (flattenType vType);
                                                Just type -> Just (flattenType type);
                                                ;
                                        in
                                            Let vName True
                                                // Should the body be lifted?
                                                False False
                                                type vExpr 
                                                (letExpr vns value)
                                                False 0 False [] 0 False; 
                                            ;
                                ;    

                        in
                            letExpr varNameToExprs altExpr;
                            
                    /**
                     * Maybe the alt that matches the data constructor from the switch expression.
                     */
                    match :: Maybe Alt;
                    match = find matchAlt alts;
                    
                    /**
                     * Rename the let vars to avoid name capture.
                     */
                    renameVars :: TransformState -> TransformHistory -> [(FieldName, QualifiedName, Type)] -> Expression -> (TransformHistory, [(FieldName, QualifiedName, Type)], Expression); 
                    renameVars state history vars expr =
                        let
                            renameVar :: TransformHistory -> FieldName -> QualifiedName -> Expression -> (TransformHistory, FieldName, QualifiedName, Expression);
                            renameVar history fieldName varName expr =
                                case newVar state history varName "EVCS" of
                                (historyPrime, varNamePrime) ->
                                    (historyPrime, fieldName, varNamePrime, substituteNoRename varName (Var varNamePrime [] Nothing Nothing) expr);
                                ;
                        in
                            case vars of
                            [] -> (history, [], expr);
                            fnqn : fnqns ->
                                case fnqn of
                                (fn, qn, type) ->
                                    case renameVar history fn qn expr of
                                    (history1, fn1, qn1, expr1) ->
                                        case renameVars state history1 fnqns expr1 of
                                        (history2, vars2, expr2) ->
                                            (history2, (fn1, qn1, type) : vars2, expr2);
                                        ; 
                                    ;
                                ;
                            ;
                             
                in
                    case match of
                    Nothing -> (history, False, caseExpr);
                    Just alt ->
                        case alt of
                        Alt {vars, expr} ->
                            let                                
                                /**
                                 * Use the inferred names instead of the actual names in the alt expression.
                                 */        
                                updateVarNames :: [(FieldName, QualifiedName, Type)] -> [(FieldName, QualifiedName, Type)] -> [(FieldName, QualifiedName, Type)] -> Maybe ([(FieldName, QualifiedName, Type)]);
                                updateVarNames current inferred varsAcc =
                                    case current of
                                    [] -> Just varsAcc;
                                    fnqn:fnqns ->                                        
                                        case fnqn of
                                        (fn, qn, type) ->
                                            case find (\entry -> matchFN switchDC fn entry.#1) inferred of
                                            Nothing -> Nothing;
                                            Just inferredFNQN ->
                                                case inferredFNQN of
                                                (ifn, iqn, itype) ->
                                                    updateVarNames fnqns inferred ((fn, iqn, itype):varsAcc);
                                                ;
                                            ;
                                        ;
                                   ;
                                
                                isMatchingAlt :: Alt -> Boolean;
                                isMatchingAlt alt = alt.Alt.caseConst.CaseDataCons.value == switchDC;

                            in
                            
                            if isInferred then  
                            (
                            case updateVarNames vars inferredVars [] of
                            Nothing ->
                                if length alts == 1 then
                                    (history, False, caseExpr)
                                else
                                    (history, True, Switch switchExpr (filter isMatchingAlt alts));
                            Just updatedVars ->
                                case renameVars state history vars expr of
                                (historyPrime, varsPrime, exprPrime) ->
                                    // the argVars parameters is empty because in the inferred case the data constructor 
                                    // still exists and so there is not loss of strictness info.
                                    (historyPrime, True, buildLetExpr (varNameToExprs varNameToExpr_inferredArgs varsPrime) exprPrime []);
                                ;
                                )
                            else                            
                                case renameVars state history vars expr of
                                (historyPrime, varsPrime, exprPrime) ->
                                    (historyPrime, True, buildLetExpr (varNameToExprs varNameToExpr_actualArgs varsPrime) exprPrime actualArgs);
                                ;
                        ;
                    ;    
            _ ->                
                case alts of
                a:as ->
                    if isEmpty as then
                        // If there is only one alt and that is '_' then we can match it
                        case a of
                        Alt {caseConst, expr=altExpr} ->
                            case caseConst of
                            CaseLiteral {value} ->
                                case value of
                                LitString {} -> (history, True, (App (App (prelude_seq_expr state) switchExpr) altExpr));     
                                _ -> (history, False, caseExpr);
                                ;
                            CaseDataCons {} -> (history, False, caseExpr);
                            ;
                    else
                        case transformState_findKnownToNotBeForm state switchExpr of
                        Nothing -> (history, False, caseExpr);
                        Just knb ->                            
                            let
                                onesThatDoNotMatch :: [CaseConst];
                                onesThatDoNotMatch = knb.#2; 
                                    
                                /**
                                 * The alt might match if it is not in the list of ones that are know to not match.
                                 */
                                mightMatch :: Alt -> [CaseConst] -> Boolean;
                                mightMatch alt seenCCs =
                                    case alt of
                                    Alt {caseConst=altCC} ->
                                        let
                                            defaultCheck :: Boolean;
                                            defaultCheck = not (orList (map (\cc -> cc == altCC) onesThatDoNotMatch));
                                        in
                                            case altCC of
                                            CaseLiteral literal ->
                                                case literal of
                                                LitString {} ->
                                                    // This is the default case. Let see if all of other cases
                                                    // seen mean that hitting the default case is not possible.
                                                    let
                                                        allSeen :: [CaseConst];
                                                        allSeen = removeDuplicates (append onesThatDoNotMatch seenCCs);
                                                        
                                                        numberSeen :: Int;
                                                        numberSeen = length allSeen;
                                                    in
                                                        case a of
                                                        Alt {caseConst} ->
                                                            case caseConst of
                                                            CaseLiteral {} -> True;
                                                            CaseDataCons {value=dc} ->
                                                                not (numberSeen == dataCons_getNumberOfTypes dc);
                                                            ;
                                                    ;
                                                _ -> defaultCheck;
                                                ;
                                            CaseDataCons {} -> defaultCheck;
                                        ;
                                    ;
                                
                                /**
                                 * Using the list of patterns that are known to not match the expression,
                                 * eliminate a bunch of alts that cannot happen.
                                 * 
                                 * Notes
                                 * 
                                 * 1. If the last is a default case and it was eliminated and there is only one 
                                 * alt left then the value must match that alt. So just eliminate the switch 
                                 * expression entirely.
                                 * 
                                 * @return A list of the alts that could possibly match. The boolean is true if 
                                 * there is only one alt and that expression MUST match the value.
                                 */

                                altsPrime :: ([Alt], Boolean);
                                altsPrime =
                                    let
                                        helper :: [Alt] -> [CaseConst] -> Boolean -> ([Alt], Boolean);
                                        helper alts seenCCs eliminateSwitch = 
                                            case alts of
                                            [] -> ([], eliminateSwitch);
                                            a:as ->
                                                let
                                                    isDefault :: Boolean;
                                                    isDefault = 
                                                        case a.Alt.caseConst of
                                                        CaseLiteral literal ->
                                                            case literal of
                                                            LitString {} -> True;
                                                            _ -> False;
                                                            ;
                                                        _ -> False;
                                                        ;
                                                    
                                                    altMightMatch :: Boolean;
                                                    altMightMatch = mightMatch a seenCCs;
                                                    
                                                    rest :: ([Alt], Boolean);
                                                    rest = 
                                                        helper 
                                                            as 
                                                            (a.Alt.caseConst:seenCCs)
                                                            // If we are eliminating the default case then
                                                            // then switch can be eliminated (assuming that
                                                            // there is only one alternative).
                                                            (
                                                                if altMightMatch then
                                                                    False   // not being eliminated so no opportunity.
                                                                else
                                                                    isDefault
                                                            );
                                                    
                                                in
                                                    case rest of
                                                    (asPrime, eliminateSwitch) ->                                                    
                                                        if altMightMatch then
                                                            (a : asPrime, eliminateSwitch)
                                                        else
                                                            (asPrime, eliminateSwitch);
                                                        ;
                                            ;
                                    in
                                        helper alts [] False;
                                
                            in
                                case altsPrime of
                                (alts, eliminateSwitch) ->
                                    if eliminateSwitch then
                                        case head alts of
                                        Alt {vars, expr=altExpr} ->
                                            // If there was a default case and it was eliminated and
                                            // there is only one alternative left and there is not variables
                                            // selected in the alt then the switch can be eliminated.
                                            if
                                                // non of the alt vars are used in the expression
                                                andList (map (\var -> not (containsFree var.#2 altExpr)) vars) &&
//                                                isEmpty vars && 
                                                length alts == 1 then
                                                (history, True, altExpr)
                                            else
                                                (history, True, Switch switchExpr alts);
                                    else
                                        (history, True, Switch switchExpr alts);
                                ;
                    ;
                ;
            ;
        ;
    _ -> (history, False, caseExpr);
    ;

/**
 * Determine if the given pair of field names refer to the same field.
 */
matchFN :: DataCons -> FieldName -> FieldName -> Boolean;
matchFN dc fn1 fn2 =
    case fn1 of
    FNOrdinal o1 ->                                    
        case fn2 of
        FNOrdinal o2 -> o1 == o2; 
        FNTextual t2 -> (dataCons_getFieldIndex dc fn2) == o1;
        ;
    FNTextual t1 ->
        case fn2 of
        FNOrdinal o2 -> (dataCons_getFieldIndex dc fn1) == o2; 
        FNTextual t2 -> t1 == t2;
        ;
    ;

isErrorCall :: Expression -> Boolean;
isErrorCall expr = 
    case getFunctor expr of
    Var {name} -> prelude_error == name;
    _ -> False;
    ;

/**
 * case x of True -> True; False -> False; => x
 * case error arg of ... => error arg 
 */
 
transform_simplifyCase :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_simplifyCase state history !caseExpr =
    case caseExpr of
    Switch expr alts ->
        if isErrorCall expr then
            (history, True, expr)
        else
            case alts of
            a1 : a1s ->
                case a1s of
                a2 : a2s ->
                    case a2s of
                    [] ->
                        let
                            patternAndExprMatch :: Boolean -> Alt -> Boolean;
                            patternAndExprMatch value alt =
                                case alt of
                                Alt {expr=altExpr} ->
                                    if matchesBoolean value alt then
                                        expressionMatchesBoolean value altExpr
                                    else
                                        False;
                                ; 
                        in
                            if patternAndExprMatch True a1 && patternAndExprMatch False a2 || patternAndExprMatch False a1 && patternAndExprMatch True a2 then
                                (history, True, expr)
                            else
                                (history, False, caseExpr);                                   
                    _ -> (history, False, caseExpr);
                    ;
                _ -> (history, False, caseExpr);
                ;
            _ -> (history, False, caseExpr);
        ;
    _ -> (history, False, caseExpr);
    ; 

/**
 * Evaluate the given various arithmetic expression. 
 * 
 * 1. Integer comparisons involving constants.
 * 2. x + 0 
 * 
 * TODO Work with vars
 */
    
transform_evaluateArithmeticExpressions :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_evaluateArithmeticExpressions state history !expr =
    let
        getComparison :: QualifiedName -> Maybe (Int -> Int -> Boolean); 
        getComparison name =
            case name of
            QN moduleName functionName ->
                if moduleName == "Cal.Core.Prelude" then
                    if functionName == "lessThanEqualsInt" then
                        Just (\x y -> x <= y)
                    else if functionName == "lessThanInt" then
                        Just (\x y -> x < y)
                    else if functionName == "equalsInt" then
                        Just (\x y -> x == y)
                    else if functionName == "greaterThanEqualsInt" then
                        Just (\x y -> x >= y)
                    else if functionName == "greaterThanInt" then
                        Just (\x y -> x > y)
                    else if functionName == "notEqualsInt" then
                        Just (\x y -> x != y)
                    else
                        Nothing
                else
                    Nothing;
            ;                        
    in
        case getFunctor expr of // Optimization 
        Var {name} ->
            case getComparison name of
            Nothing ->
                    case flattenExpression expr [] of 
                    functor : args -> 
                        case args of
                        a1:a1s ->
                            case a1s of
                            a2:a2s ->
                                case a2s of
                                [] ->
                                    case a2 of
                                    Literal {value=l2} ->
                                        case l2 of
                                        LitDouble {value=v2} ->
                                            if v2 == 0.0 then
                                                if name == QN "Cal.Core.Prelude" "multiplyDouble" then
                                                    if expression_couldHaveSideEffects True state history a1 then
                                                        (history, False, expr)
                                                    else
                                                        // x * 0 => 0
                                                        (history, True, Literal (LitDouble 0.0))
                                                else if name == QN "Cal.Core.Prelude" "addDouble" then
                                                    // x + 0 => 0
                                                    (history, True, a1) 
                                                else if name == QN "Cal.Core.Prelude" "subtractDouble" then
                                                    // x - 0 => 0
                                                    (history, True, a1) 
                                                else
                                                    (history, False, expr)
                                            else
                                                case name of
                                                QN name_moduleName name_functionName ->
                                                    if name_moduleName == "Cal.Core.Prelude" then
                                                        case a1 of
                                                        Literal l1 ->
                                                            case l1 of
                                                            LitDouble v1 ->
                                                                if name_functionName == "addDouble" then
                                                                    (history, True, Literal (LitDouble (v1 + v2)))
                                                                else if name_functionName == "subtractDouble" then
                                                                    (history, True, Literal (LitDouble (v1 - v2)))
                                                                else if name_functionName == "multiplyDouble" then
                                                                    (history, True, Literal (LitDouble (v1 * v2)))
                                                                else if name_functionName == "divideDouble" && v2 != 0 then
                                                                    (history, True, Literal (LitDouble (v1 / v2)))
                                                                else
                                                                    (history, False, expr);
                                                            _ -> (history, False, expr);
                                                            ;
                                                        _ -> (history, False, expr);
                                                    else
                                                        (history, False, expr);
                                                    ;
                                        LitInt {value=v2} ->
                                            if  
                                            v2 == 0 then
                                                if
                                                name == QN "Cal.Core.Prelude" "multiplyInt" then
                                                    if expression_couldHaveSideEffects True state history a1 then
                                                        (history, False, expr)
                                                    else
                                                        // x * 0 => 0
                                                        (history, True, Literal (LitInt 0))
                                                else if name == QN "Cal.Core.Prelude" "addInt" then
                                                    // x + 0 => 0
                                                    (history, True, a1) 
                                                else if name == QN "Cal.Core.Prelude" "subtractInt" then
                                                    // x - 0 => 0
                                                    (history, True, a1) 
                                                else
                                                    (history, False, expr)
                                            else
                                                case name of
                                                QN name_moduleName name_functionName ->
                                                    if name_moduleName == "Cal.Core.Prelude" then
                                                        case a1 of
                                                        Literal l1 ->
                                                            case l1 of
                                                            LitInt v1 ->
                                                                if name_functionName == "addInt" then
                                                                    (history, True, Literal (LitInt (v1 + v2)))
                                                                else if name_functionName == "subtractInt" then
                                                                    (history, True, Literal (LitInt (v1 - v2)))
                                                                else if name_functionName == "multiplyInt" then
                                                                    (history, True, Literal (LitInt (v1 * v2)))
                                                                else if name_functionName == "divideInt" && v2 != 0 then
                                                                    (history, True, Literal (LitInt (v1 / v2)))
                                                                else
                                                                    (history, False, expr);
                                                            _ -> (history, False, expr);
                                                            ;
                                                        _ -> (history, False, expr);
                                                    else
                                                        (history, False, expr);
                                                    ;
                                        _ -> (history, False, expr);
                                        ;
                                    _ -> 
                                        case a1 of
                                        Literal {value=l1} ->
                                            case l1 of
                                            LitDouble {value=v1} ->                                            
                                                if v1 == 0.0 then
                                                    if name == QN "Cal.Core.Prelude" "multiplyDouble" then
                                                        if expression_couldHaveSideEffects True state history a2 then
                                                            (history, False, expr)
                                                        else
                                                            // 0 * x => 0
                                                            (history, True, Literal (LitDouble 0.0))
                                                    else if name == QN "Cal.Core.Prelude" "divideDouble" then
                                                        if expression_couldHaveSideEffects True state history a2 then
                                                            (history, False, expr)                                                           
                                                        else
                                                            // 0 / x => 0
                                                            (history, True, Literal (LitDouble 0.0))
                                                    else if name == QN "Cal.Core.Prelude" "addDouble" then
                                                        // 0 + x  => 0
                                                        (history, True, a2) 
                                                    else
                                                        (history, False, expr)
                                                else
                                                    (history, False, expr);
                                            LitInt {value=v1} ->                                            
                                                if v1 == 0 then
                                                    if name == QN "Cal.Core.Prelude" "multiplyInt" then
                                                        if expression_couldHaveSideEffects True state history a2 then
                                                            (history, False, expr)
                                                        else
                                                            // 0 * x => 0
                                                            (history, True, Literal (LitInt 0))
                                                    else if name == QN "Cal.Core.Prelude" "divideInt" then
                                                        if expression_couldHaveSideEffects True state history a2 then
                                                            (history, False, expr)                                                           
                                                        else
                                                            // 0 / x => 0
                                                            (history, True, Literal (LitInt 0))
                                                    else if name == QN "Cal.Core.Prelude" "addInt" then
                                                        // 0 + x  => 0
                                                        (history, True, a2) 
                                                    else
                                                        (history, False, expr)
                                                else
                                                    (history, False, expr);
                                            _ -> (history, False, expr);
                                            ;
                                        _ -> (history, False, expr);
                                        ;
                                    ;
                                _ -> (history, False, expr);
                                ;
                            [] -> (history, False, expr);
                            ;
                        [] -> (history, False, expr);
                        ;
                ;
            Just comparison ->
                case flattenExpression expr [] of
                functor : args ->
                    case args of
                    a1:a1s ->
                        case a1s of
                        a2:a2s ->
                            case a2s of
                            [] -> 
                                case a1 of
                                Literal {value=literal1} ->
                                    case a2 of
                                    Literal {value=literal2} ->
                                        case literal1 of
                                        LitInt int1 ->
                                            case literal2 of
                                            LitInt int2 -> 
                                                (history, True, Literal (LitBoolean (comparison int1 int2)));
                                            _ -> (history, False, expr);
                                            ;
                                        _ -> (history, False, expr);
                                        ;
                                    _ -> (history, False, expr);
                                    ;
                                _ -> (history, False, expr);
                                ;
                            _ -> (history, False, expr);
                            ;
                        _ -> (history, False, expr);
                        ;
                    _ -> (history, False, expr);
                    ;    
                ;
            ;
        _ -> (history, False, expr);
        ;
    
/**
 * Given a list of arguments passed to this call, inline the arguments that have
 * a constant value.
 * 
 * TODO: Make this notice if the inlining is bad in that it can calculate values
 * multiple times.
 * 
 * @arg state The context of the transformation.
 * @arg history The history of the current transformation.
 * @arg wasChanged An accumulator for keeping track of whether or not the expression was changed.
 * @arg isConstArgs A list with one entry for each argument. If the argument is
 *      constant in the recursive call then the corresponding element is True.
 * @arg actualArguments The arguments used by the caller to an instance of this
 *      function.
 * @arg actualTypes The types of the actual arguments.
 * @arg body The body of the function that is being specialized.
 * @arg unusedArgumentsR The arguments that are not used (in reverse order).
 * @arg unusedTypesR The corresponding type of the arguments unusedArgumentsR.
 */

inlineConstantArguments :: TransformState -> TransformHistory -> Boolean -> [Boolean] -> [Expression] -> [Type] -> Expression -> [Expression] -> [Type] -> [Boolean] -> (TransformHistory, Boolean, ([Expression], Expression, [Type], [Boolean]));
inlineConstantArguments state history !wasChanged !isConstArgs actualArguments actualTypes !body unusedArgumentsR unusedTypesR unusedIsConstArgsR =
    case body of
    Lambda lambdaVar lambdaType lambdaWHNF lambdaExpr ->
        // if the arg should be inlined
        if not (isEmpty isConstArgs) && (head isConstArgs) then
            case actualArguments of
            actualArguments_head : actualArguments_tail ->
            case isConstArgs of
            isConstArgs_head : isConstArgs_tail ->
                case substituteHelper state history lambdaVar actualArguments_head lambdaExpr of
                    (history1, wasChanged1, lambdaExprPrime) ->
                        inlineConstantArguments state history1 (wasChanged || wasChanged1) isConstArgs_tail actualArguments_tail (safeTail actualTypes) lambdaExprPrime unusedArgumentsR unusedTypesR unusedIsConstArgsR;
//                        let
//                            maybeAddSeq :: Expression -> Expression;
//                            maybeAddSeq expr = 
//                                if type_isStrict lambdaType then
//                                    makeSeqCall state history actualArguments_head expr 
//                                else
//                                    expr;
//                        in
//                            case inlineConstantArguments state history1 isConstArgs_tail actualArguments_tail (safeTail actualTypes) lambdaExprPrime unusedArgumentsR unusedTypesR unusedIsConstArgsR of
//                            (history2, result) ->
//                            case result of
//                            (result_1, result_2, result_3, result_4) ->
//                                (history2, (result_1, maybeAddSeq result_2, result_3, result_4));
//                                ;
//                            ;
                ;
            ;    
        else
            let                
                result1 :: (TransformHistory, Boolean, ([Expression], Expression, [Type], [Boolean]));
                result1 = inlineConstantArguments state history wasChanged
                        (safeTail isConstArgs) 
                        (safeTail actualArguments) 
                        (safeTail actualTypes) 
                        lambdaExpr 
                        (head actualArguments : unusedArgumentsR) 
                        (head actualTypes : unusedTypesR) 
                        (head isConstArgs : unusedIsConstArgsR);
        
            in
                case result1 of
                (history1, wasChanged, result) ->
                case result of
                (result_1, result_2, result_3, result_4) ->
                    (history1, wasChanged, (result_1, Lambda lambdaVar lambdaType lambdaWHNF result_2, result_3, result_4));
                    ;
                ;
    _ -> (history, wasChanged, (append (reverse unusedArgumentsR) actualArguments, body, (append (reverse unusedTypesR) actualTypes), (append (reverse unusedIsConstArgsR) isConstArgs)));
    ;
        
/**
 * Remove all the constant arguments from the recursive calls in the body since
 * these value will be embedded in the specialized function.
 * 
 * @arg oldFunctor The functor of the function that is specialized.
 * @arg newFunctor The name of the new specialized function.
 * @arg isConstArgs Information about the arguments that are constants. The nth
 *      element of the list is True iff the nth argument is a constant.
 * @arg state The state pass during the transformation.
 * @arg history The history of the tranformation.
 * @arg expr The expression to remove the constant arguments from.
 * 
 */
    
removeConstantArguments :: QualifiedName -> Expression -> [Boolean] -> TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
removeConstantArguments oldFunctor newFunctor isConstArgs state history expr =
    let
        call :: [Expression];
        call = flattenExpression expr [];
        
        matches :: Expression -> QualifiedName -> Boolean;
        matches !expr !name =
            case expr of
            Var {name=exprName} -> exprName == name;
            _ -> False;
            ;
        
        arity :: Int;
        arity = length isConstArgs;
        
        lengthCall :: Int;
        lengthCall = length call;
        
        /**
         * Remove the constant arguments from the call.
         */
        
        reducedExpr :: Expression;
        reducedExpr = 
            unflattenExpression 
                (newFunctor : (map snd (filter (\isConstArgTuple -> not isConstArgTuple.#1) (zip isConstArgs (tail call)))));
    in
        if
            // The current expression is a call to the specialized function
            matches (getFunctor expr) oldFunctor &&
            // There is at least one argument.
            lengthCall > 1 && 
            // The call is fully saturated.
            lengthCall - 1 == arity then
            (history, True, reducedExpr)
        else
            (history, False, expr);
    
/**
 * Look for functions to create specializations of.
 * 
 * Input:
 * 
 * let f a1 a2 ï¿½ ak = ï¿½ (f a1 a2ï¿½ ï¿½ aiï¿½ ï¿½ ak) ï¿½ in ï¿½ (f e1 e2 ï¿½ ei ï¿½ ek) ï¿½
 * 
 * The function f calls itself recursively. A number of arguments are passed
 * unchanged so they are constant for any given call.
 * 
 * Output:
 * 
 * fï¿½ a2 ï¿½ai = ï¿½ f a2ï¿½ ï¿½ aiï¿½ [e1/a1]ï¿½[ek/ak]
 * 
 * fï¿½ e2 ï¿½ ei
 * 
 * Embed the constant values into the function f and remove the arguments from
 * the calls. Change the call to call f1 instead of f.
 * 
 * Notes: 
 * 
 * This makes two passes at specialization. The first pass will try embedding arguments even if
 * the argument is not constant in the recursive function. If the function body reduces so there is
 * no recursive call then the new function will be kept. For example, 
 * 
 *      test11 = test11_andListMap noStrictId [];
 *      
 *      test11_andListMap nToTest !list =
 *          case list of
 *              [] -> True;
 *              head : tail -> nToTest head && test11_andListMap nToTest tail;
 *          ;
 *          
 *      answer11 = True;    
 *      
 * If the reduction fails then the old specialization will be applied.
 */

transform_specialization :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_specialization state history !expr =
    case expr of
    App e1 e2 ->
        let
            noChange :: (TransformHistory, Boolean, Expression);
            noChange = (history, False, expr);
        
            call :: [Expression];
            call = flattenExpression expr [];
        in
            case call of
            functor : actualArguments -> 
            case functor of
            Var {name} ->
                if
                   transformState_isBeingFused state name ||
                   name == state.TransformState.currentFunctionName
                then 
                    (history, False, expr)
                else
                    let
                        /**
                         * Get the definition of the function
                         */
                        definition :: Maybe (QualifiedName, Expression, Maybe [Type], Boolean, [Boolean]);
                        definition =
                            // don't specialize the recursive calls to a function
                                transformState_findDef state history name;
                    in
                        case definition of
                        Nothing ->
                            noChange;
                        Just definitionTuple ->
                        case definitionTuple of
                        (defName, defExprNotRenamedWithoutSeq, defType, defRecursive, defConstArgs23) ->
                            let
                                /*
                                 * For all the plinged arguments add an seq of the var
                                 */
                                defExprNotRenamed = 
                                    let
                                        helper expr seqVars = 
                                            case expr of
                                            Lambda variable type isWHNF expr ->
                                                    Lambda 
                                                        variable 
                                                        (type_setStrictness type False)
                                                        isWHNF
                                                        (helper 
                                                             expr 
                                                             (if type_isStrict type then
                                                                 (Var variable [] Nothing (Just type):seqVars)
                                                              else
                                                                  seqVars
                                                             ) 
                                                         );
                                            _ -> buildSeq2 state (reverse seqVars) expr;
                                            ;
                                    in
                                        helper defExprNotRenamedWithoutSeq [];
                                
                                defTypeList :: [Type];
                                defTypeList = defType.Just.value;

                                defArgs :: [QualifiedName];
                                defArgs = expression_getArguments defExprNotRenamed;
                                
                                /**
                                 * Arguments that have the save value throught the calls of the function being specialized.
                                 */
                                defConstArgs :: [Boolean];
                                defConstArgs = 
                                    constVars defName state.TransformState.typeConstants defArgs defExprNotRenamed;
                                
                                /**
                                 * If the argument occurs more than once.
                                 */
                                defOccursMoreThanOnce :: [Boolean];
                                defOccursMoreThanOnce =
                                    map (\defArg ->
                                            occursMoreThanOnce defArg Nothing (removeLambdaVars defExprNotRenamed)
                                            ) defArgs;
                                
                                /**
                                 * True iff the corresponding actual argument has
                                 * free variables.
                                 */
                                actualArgHasFreeVariables :: [Boolean];
                                actualArgHasFreeVariables =
                                    map tooManyUnboundVars actualArguments; 
    
                                actualArgIsConstant :: [Boolean];
                                actualArgIsConstant =
                                    map expression_isConstant actualArguments; 
    
                                /**
                                 * A flag indication if the actual argument is WHNF
                                 * and not just a var.
                                 */
                                actualArgIsWHNF :: [Boolean];
                                actualArgIsWHNF = 
                                    map 
                                        (\arg -> 
                                            expression_isWHNF arg && 
                                            (
                                                if isVar arg then
                                                    qualifiedName_isTopLevel arg.Var.name
                                                else
                                                    True
                                            )
                                        ) 
                                        actualArguments;

                                /**
                                 * A flag indication if the actual argument could have
                                 * side effects.
                                 */
                                actualArgCouldHaveSideEffects :: [Boolean];
                                actualArgCouldHaveSideEffects = 
                                    map (\arg ->
                                        case expression_getType state history arg of
                                        Nothing -> expression_couldHaveSideEffects False state history arg;
                                        Just type ->                                            
                                            expression_couldHaveSideEffects (type_isFunctionType type) state history arg;
                                        ) actualArguments;
                                    
                                /**
                                 * All the arguments to the function are non-top level vars.
                                 * 
                                 * TODO: Uncommented out the not seems to make sense but a number
                                 * of tests ran slower. Maybe check this out again after some
                                 * other bugs are fix.
                                 */
                                allArgsAreNotTopLevelVars :: Boolean;
                                allArgsAreNotTopLevelVars =
                                    let
                                        check :: Expression -> Boolean;
                                        check arg =
                                            case arg of
                                            Var {name} ->
                                                True;
//                                                not (transformState_isTopLevelBoundName state name);
                                            _ -> False;
                                            ;
                                    in
                                        andList (map check actualArguments);
                                
                                actualArgIsSafe :: [Boolean];
                                actualArgIsSafe = 
                                    let
                                        functionBeingSpecialized :: Expression;
                                        functionBeingSpecialized = defExprNotRenamed;
                                        
                                        expectedArgs :: [QualifiedName];
                                        expectedArgs = expression_getArguments functionBeingSpecialized;
                                    in
                                        map 
                                        (uncurry (\actualArg expectedArg -> 
                                            if isLambdaExpression actualArg then
                                                inliningSafeForLambda state expectedArg (expression_getArity actualArg) actualArg functionBeingSpecialized 
                                            else
                                                True
                                        )) 
                                        (zip actualArguments expectedArgs);
                                
                                /**
                                 * If the actual argument contains free variable
                                 * then that arg will not be inlined. This will be
                                 * true iff the argument is constant in the
                                 * recursive calls in the body AND the actual
                                 * argument in the call has no free variables.
                                 * 
                                 * @arg onlyUseConstArgs Only use arguments that are constants in the recursive function. 
                                 */
                                usableConstArgs :: Boolean -> [Boolean];
                                usableConstArgs onlyUseConstArgs =
                                    List.zipWith7 (\isConst isWHNF isConstant couldHaveSideEffects isSafe defArgOccursMoreThanOnce actualArgument -> 
                                                (isConst ||
                                                    (if not onlyUseConstArgs then
                                                        isConstant
                                                    else
                                                        False)
                                                ) && 
    //                                            not hasFree &&

                                                isSafe &&
                                                ( 
                                                    isWHNF || 
                                                    (
                                                    (
                                                        (
                                                            if couldHaveSideEffects then
                                                                not defArgOccursMoreThanOnce
                                                            else
                                                                True
                                                        )
                                                        &&
                                                        // Don't bother embedding a var if it will just
                                                        // have to be lifted later.
                                                        (
                                                            if isVar actualArgument then
                                                                transformState_isTopLevelBoundName state actualArgument.Var.name 
                                                            else
                                                                True
                                                        )
                                                    )
                                                    )
                                                ))
                                                defConstArgs actualArgIsWHNF actualArgIsConstant actualArgCouldHaveSideEffects actualArgIsSafe defOccursMoreThanOnce actualArguments;
                                
                                /**
                                 * Get a list of the unbound variables in the
                                 * expression.
                                 * 
                                 * TODO fix this to call hasFreeVariablesInBody
                                 */
                                tooManyUnboundVars :: Expression -> Boolean;
                                tooManyUnboundVars !expr =
                                    let
                                        isUnboundVar :: TransformState -> [QualifiedName] -> Expression -> ([QualifiedName], Expression);
                                        isUnboundVar state qns !expr =
                                            case expr of
                                            Var name _ _ _ ->
                                                if isJust (find (\tlname -> tlname == name) (transformState_getTopLevelBoundNames state)) then
                                                    (qns, expr)
                                                else if isJust (find (\accName -> accName == name) qns) then
                                                    (qns, expr) // already in the
                                                                // list
                                                else
                                                    (name : qns, expr);        
                                            _ -> (qns, expr);
                                            ;
                                            
                                        numberOfFreeVars :: Int;
                                        numberOfFreeVars =
                                            length (transformAcc state [] expr isUnboundVar).#1; 
                                    in
                                        // > 0 for
                                        // OlapData.makeIntListFromArray$loopHelper$2
                                        numberOfFreeVars > (if expression_isUnsaturatedExpression state history expr then 1 else 0);  
                                    
                                /**
                                 * If any of the constant arguements are unbound
                                 * vars then this is not worth specializing since
                                 * there would be no variables removed from the
                                 * function def.
                                 */
                                isWorthSpecializing :: Boolean -> Boolean;
                                isWorthSpecializing onlyUseConstArgs =
                                    orList (
                                            map (uncurry (\arg isConst -> not isConst || not (tooManyUnboundVars arg))) 
                                                (zip actualArguments (usableConstArgs onlyUseConstArgs))
                                            );
                                
                                performSpecialization :: Boolean -> Maybe (TransformHistory, Boolean, Expression);
                                performSpecialization onlyUseConstantArgs =
                                    let
                                    
                                    actualTypes :: [Type];
                                    actualTypes = defTypeList;
        
                                    /**
                                     * The types of the arguments in the call of
                                     * the function being specialized.
                                     */
                                    actualArgumentTypes :: [Maybe Type];
                                    actualArgumentTypes =
                                            map (\expr -> expression_getType state history expr) actualArguments;
                                                                        
                                    /**
                                     * More specific type bindings for the
                                     * actual argument types.
                                     */
                                    specializedActualArgumentTypes :: [Type];
                                    specializedActualArgumentTypes =
                                        type_specializeArguments actualTypes actualArgumentTypes;
                                    
                                    /**
                                     * The arguments of the new specialized
                                     * funcion. The type of the arguments that
                                     * were removed are no longer in the list.
                                     * The removeArgs list is one shorted than
                                     * the args list that is why I wrote a
                                     * special function. The missing value is
                                     * the return type.
                                     */
                                    
                                    specializedArgumentTypesHelper :: [Boolean] -> [Type] -> [Type];
                                    specializedArgumentTypesHelper !removeArgs args =
                                        case removeArgs of
                                        [] -> args;
                                        remove:ras ->
                                            case args of
                                            args_head:args_tail ->
                                                if remove then
                                                    specializedArgumentTypesHelper ras args_tail
                                                else
                                                    args_head : specializedArgumentTypesHelper ras args_tail;
                                                ;
                                        ;
                                        
                                    specializedArgumentTypes :: [Type];
                                    specializedArgumentTypes =
                                        specializedArgumentTypesHelper (usableConstArgs onlyUseConstantArgs) specializedActualArgumentTypes;
                                    
                                    in
                                        case newVar state history name "SPEC" of
                                        (history1, newFunctionName) ->
                                            let
                                                newFunctor :: Expression;
                                                newFunctor = Var newFunctionName [] Nothing Nothing;
                                                
                                                /*
                                                 * The function body of the expression being
                                                 * specialied with extra arguments in the
                                                 * recursive call removed.
                                                 * 
                                                 * TODO: Make sure the arguments are
                                                 * exactely the same so that if there is two
                                                 * recursive calls with different arguments
                                                 * this will not cause a problem.
                                                 */
                                                
        
                                            in
                                                case transform state history1 defExprNotRenamed (combineTransformsWithHistory (renameLetVariables True) renameLambdaVariables) of
                                                (history2, _, defExprRenamed) ->
                                                    let 
    
                                                        reducedExpr :: Expression;
                                                        reducedExpr =
                                                            (transform state transformHistory_init defExprRenamed (removeConstantArguments name newFunctor (usableConstArgs onlyUseConstantArgs))).#3;
                                                
                                                    in
                                                        case inlineConstantArguments state history2 False (usableConstArgs onlyUseConstantArgs) actualArguments actualTypes reducedExpr [] [] [] 
                                                        of
                                                        (history3, wasChanged3, result2) ->
                                                            case result2 of
                                                                (unusedArguments, letExprPrime, typePrime, isConstVarsPrime) ->
                                                                let
                                                                    getLetExpr :: TransformHistory -> Maybe (TransformHistory, Expression);
                                                                    getLetExpr history = 
                                                                        if not onlyUseConstantArgs then
                                                                            case optimizeExplicit transformations state history 8 letExprPrime of
                                                                            (history1, wasChanged1, letExprPrimeOptimized) ->
                                                                                let
                                                                                    typePrime :: Maybe Type;
                                                                                    typePrime = expression_getType state history letExprPrimeOptimized;
                                                                                in
                                                                                if
                                                                                    not (wasChanged1) ||
//                                                                                    not (wasChanged1 || wasChanged3) ||
                                                                                    (
                                                                                        containsFree newFunctionName letExprPrimeOptimized 
//                                                                                        containsFree newFunctionName letExprPrimeOptimized && (not wasChanged3)
//                                                                                        &&
//                                                                                        not (containsFree newFunctionName letExprPrime)
                                                                                    )
//                                                                                    ||
//                                                                                    // This is needed because when the seq is added because of the
//                                                                                    // plinged type. The result of simplification can look like a 
//                                                                                    // change but not really be a change.
//                                                                                    expressionIsomorphic letExprPrimeOptimized defExprNotRenamedWithoutSeq
                                                                                then
                                                                                    Nothing
                                                                                else
                                                                                    Just (history1, letExprPrimeOptimized);
                                                                        else
                                                                            case optimizeExplicit transformations state history 8 letExprPrime of
                                                                            (history1, _, letExprPrimeOptimized) ->
                                                                                Just (history1, letExprPrimeOptimized);
                                                                            ;
//                                                                                Just (history, letExprPrime);
                                                                in    
                                                                    case 
                                                                        getLetExpr history3 of
                                                                    Nothing ->
                                                                        Nothing;
                                                                    Just result ->
                                                                    case result of
                                                                    (history4, letExprPrime) ->
                                                                        let
                                                                            letBodyPrime :: Expression;
                                                                            letBodyPrime = unflattenExpression (newFunctor:unusedArguments);
                                                                            
                                                                            bodyPrime :: Expression;
                                                                            bodyPrime =
                                                                                Let  
                                                                                    newFunctionName 
                                                                                    True
                                                                                    True
                                                                                    False
                                                                                    (Just specializedArgumentTypes)
                                                                                    letExprPrime
                                                                                    letBodyPrime
                                                                                    True
                                                                                    (expression_getArity letExprPrime)
                                                                                    False
                                                                                    isConstVarsPrime
                                                                                    history.TransformHistory.currentIteration
                                                                                    False;
                        
                                                                            history5 :: TransformHistory;
                                                                            history5 =          
                                                                                transformHistory_update newFunctionName letExprPrime (Just specializedArgumentTypes) isConstVarsPrime history3;
                                                                        in
                                                                            if expressionIsomorphic (removeLambdaVars defExprNotRenamedWithoutSeq) (removeLambdaVars letExprPrime) then
                                                                                Just noChange
                                                                            else
                                                                                Just (history5, True, bodyPrime);
                                                                        ;
                                                                    ;
                                                                ;    
                                                            ;
                                                    ;    
                                        ;
                                        
                            in
                                if (onlyRecursive_specialization && not defRecursive) then
                                    noChange
                                else if
                                    // There is not type information OR
                                    isNothing defType || 
                                    // The call is not fully saturated OR
                                    length defTypeList - 1 != length actualArguments then
                                        noChange    // do nothing
                                else
                                    case performSpecialization False of
                                    Just result ->
                                        result;                                     
                                    _ -> 
                                        if 
                                            // There are no constant arguments. OR
                                            not (orList (usableConstArgs True)) ||
                                            allArgsAreNotTopLevelVars ||
                                            // just inlining one var for another
                                            not (isWorthSpecializing True) then
                                            noChange
                                        else
                                            (performSpecialization True).Just.value;
                                    ;    
                        ;;
            _ ->
                noChange;
            ;;
        
    _ -> (history, False, expr);
    ;

transformations :: [TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression)];
transformations = [
      transform_3_2_2        // inlining
    , transform_3_5_5 // lambda floating
    , transform_3_5_1
    , transform_3_5_2
    , transform_3_5_2_withInlining
    , transform_simplifyCase
    , transform_3_1          // beta reduction
    , transform_3_4_2
    , transform_redundantCases
    , transform_evaluateCase
    , transform_letFloatingFromCaseScrutinee
    , transform_evaluateRecordSelection
    , (transform_3_2_1 False)       // dead code elimination
    , transform_evaluateArithmeticExpressions
    , transform_canonizeSeq
    , transform_simplifySeq  // after canonize seq for test41
];

/**
 * If onlyConstArgs is set then the specialization will just occur at this point.
 * If not onlyConstArgs then we will try specializing and then optimize the result
 * to see if the recurive calls are eliminated if so then we will keep this try. See 
 * note one for the top level function.
 */
getLetExpr :: TransformState -> TransformHistory -> Boolean -> QualifiedName -> Expression -> Maybe Expression;
getLetExpr state history onlyUseConstantArgs newFunctionName letExprPrime = 
    if not onlyUseConstantArgs then
        let
            result :: (TransformHistory, Boolean, Expression);
            result = optimizeExplicit transformations state history 6 letExprPrime;
        in
            case result of
            (history1, wasChanged1, letExprPrimeOptimized) ->
                if containsFree newFunctionName letExprPrimeOptimized then
                    Nothing
                else
                    Just letExprPrimeOptimized;
    else
        Just letExprPrime;

//helper :: TransformState -> TransformHistory -> QualifiedName -> Expression -> Maybe Expression;
//helper state history newFunctionName expr =
//let
//    result :: (TransformHistory, Boolean, Expression);
//    result = optimizeExplicit transformations state history 5 expr;
//in
//    case result of
//    (history1, wasChanged1, letExprPrimeOptimized) -> Nothing;
//    ;

/**
 * Convert if/then/else's into case expression. This is to avoid having to write
 * special transformations for the 'if' expressions.
 * 
 * @arg state The context of the current expression.
 * @arg expr The expression to transforms
 * @return The expression with if/then/else call changed to a case expression if
 *         applicable.
 * 
 * TODO - rewrite this using flattenExpression;
 */ 
    
transform_if_to_case :: TransformState -> Expression -> Expression;    
protected transform_if_to_case state !expr =
    case expr of
    App expr1 elseExpr ->
        case expr1 of
        App expr11 thenExpr ->
            case expr11 of
            App functor ifExpr ->
                case functor of 
                Var {name=varName} ->
                    if varName == QN "Cal.Core.Prelude" "if" then
                        Switch ifExpr [Alt (CaseLiteral (LitBoolean True)) False [] thenExpr, Alt (CaseLiteral (LitBoolean False)) False [] elseExpr]
                    else
                        expr;
                _ -> expr;
            ;
            _ -> expr;
            ;
        _ -> expr;
        ;
    _ -> expr;
    ;

matchCaseConstAndDataConstructor :: CaseConst -> DataCons -> Boolean;
matchCaseConstAndDataConstructor !cc !dc =
    case cc of
    CaseLiteral literal ->
        case literal of
        LitString string -> 
            if string == "_" then
                True
            else
                isMatchingDataConsLiteral dc literal;
        _ -> isMatchingDataConsLiteral dc literal;
        ;
    CaseDataCons ccdc -> ccdc == dc;
    ;


matchCaseConstAndLiteral :: CaseConst -> Literal -> Boolean;
matchCaseConstAndLiteral !cc literal =
    case cc of
    CaseLiteral caseLiteral ->
        case caseLiteral of
        LitString {} -> True;   // must be a _ since strings are not allowed in case expressions.
        _ -> caseLiteral == literal;
        ;
    CaseDataCons dc -> isMatchingDataConsLiteral dc literal;
    ;
    
/**
 * 3.2.1 - Dead code removal
 * 
 * let v = ev in e (where v is not found in e)
 * 
 * to
 * 
 * e
 */ 

transform_3_2_1 :: Boolean -> TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);    
protected transform_3_2_1 removeOldOnesAsWell state history !expr =
    case expr of
        Let {variable=letVar, isNew=isNew, expr=letExpr, body=letBody} ->
        // isNew - Removed to make test9 work correctly.
            if (isNew || removeOldOnesAsWell) && not (containsFree letVar letBody) then
                (history, True, letBody)
            else
                (history, False, expr)
            ;
        LetInlinable {variable=letVar, expr=letExpr, body=letBody} ->
                if not (containsFree letVar letBody) then
                    (history, True, letBody)
                else
                    (history, False, expr)
                ;
        _ ->
            (history, False, expr)
            ;
        ;

/* @example */
transform_3_2_1Examples :: JPreludeTypeConstants -> Boolean;
transform_3_2_1Examples typeConstants = 
    let
        initState :: Expression -> TransformState;
        initState expr = transformState_init (QN "ModuleName" "functionName") typeConstants [] [] [] expr [] [];
        
        initHistory :: TransformHistory;
        initHistory = transformHistory_init;
        
        helloWorldString :: Expression;
        helloWorldString = Literal (LitString "hello world"); 
        
        // Test1 ((\varName -> varName) "hello world") == "hello world"
        expr1 :: Expression;
        expr1 = Let (QN "Cal.Core.Prelude" "unusedVar") True False False Nothing helloWorldString helloWorldString False 0 False [] 1 False;
        
        check1 :: Expression -> Boolean;
        check1 expr = assert (expr == helloWorldString); 
    in
        assert (check1 ((transform_3_2_1 False) (initState expr1) initHistory expr1).#3);

/**
 * Use the type of the lambda expression variable to try to make the type of the given expression
 * more specific. Currently only working for expressions that are Var's.
 */
specializeType :: Type -> Expression -> Expression; 
specializeType lambdaType expr =
    case expr of
    Var name inliningContext entity maybeType ->
        Var name inliningContext entity (Just (head (type_specializeArguments [lambdaType] [maybeType])));
    _ -> expr;
    ;    

/**
 * 3.1 - Beta reduction
 * 
 * (\v -> e) x
 * 
 * to
 * 
 * e (x/v)
 * 
 * @arg state Information about the current expression.
 * @arg history Information about the history of the transformation.
 * @arg application expression The expression to transform
 * @return The transformed expression.
 * 
 * TODO: Check the if there are any strictness issues.
 */

transform_3_1 :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_3_1 state history !application =
    let
        noChange :: (TransformHistory, Boolean, Expression);
        noChange = (history, False, application);
    in
        case application of
        App lambda givenArg ->
            case lambda of        
            Lambda lambdaVar lambdaType lambdaArgIsWHNF lambdaExpr ->
                let
                    arg :: Expression;
                    arg = specializeType lambdaType givenArg;
                in
                    if type_isStrict lambdaType then
                        if isVar arg then
                            case substituteHelper state history lambdaVar arg lambdaExpr of
                            (history, wasChanged, lambdaExprPrime) -> (history, True, (unflattenExpression [prelude_seq_expr state, arg, lambdaExprPrime]));
                        else
                            case newVar state history lambdaVar "BETA" of
                            (history2, letVar2) ->
                                case substituteHelper state history2 lambdaVar (Var letVar2 [] Nothing (Just lambdaType)) lambdaExpr of
                                (history3, wasChanged, lambdaExprPrime) -> 
                                    // If the type is strict then seq the lambda variable.
                                    (
                                        history3, 
                                        True,
                                        Let  
                                        letVar2 
                                        True 
                                        True 
                                        False 
                                        (Just (flattenType lambdaType))
                                        arg  
                                        (unflattenExpression [prelude_seq_expr state, Var letVar2 [] Nothing (Just lambdaType), lambdaExprPrime])
                                        False 
                                        0
                                        False
                                        []
                                        0
                                        False
                                    );
                                ;
                    else
                        case substituteHelper state history lambdaVar arg lambdaExpr of
                        (history, wasChanged, lambdaExprPrime) -> (history, True, lambdaExprPrime);
                ;
            _ -> noChange;
            ;
        _ -> noChange;
    ;

/* @example */
transform_3_1Examples :: JPreludeTypeConstants -> Boolean;
transform_3_1Examples typeConstants = 
    let
        initState :: Expression -> TransformState;
        initState expr = transformState_init (QN "ModuleName" "functionName") typeConstants [] [] [] expr [] [];
        
        initHistory :: TransformHistory;
        initHistory = transformHistory_init;
        
        varName :: QualifiedName;
        varName = QN "ModuleName" "varName";
        
        lambda :: Expression;
        lambda = Lambda varName (TypeId 1 False) False (Var varName [] Nothing Nothing);
        
        helloWorldString :: Expression;
        helloWorldString = Literal (LitString "hello world"); 
        
        expr :: Expression;
        expr = App lambda helloWorldString;
    in
        // ((\varName -> varName) "hello world") == "hello world"
        assert ((transform_3_1 (initState expr) initHistory expr).#3 == helloWorldString);

/**
 * Inline the given lambda expression iff it is satured and the expression body
 * is at least as strict as the function being inlined in the arguments of the
 * function being inlined.
 * 
 * @arg functor The name of the variable corresponding to the lambda expression.
 * @arg expectedArity The arguments of the expression corresponding to the let
 *      var.
 * @arg hasStrictArguments Does the lamba expression have strict arguments. If
 *      so the inlining can only happen if the body is at least as strict for
 *      the arguments.
 * @arg forceInlining Ignore heuristics and inline that lambda expression. This
 *      is used for fusion currently.
 * @arg inlinedExpr The expression to inline.
 * @arg state The context of the current expression.
 * @arg history The history of the current transformation.
 * @arg expr The expression to perform the inlining in.
 * @return The expression with the inlining performed.
 * 
 * TODO Should this be renaming variables?
 */
 
inlineLambda :: QualifiedName -> Int -> Boolean -> Boolean -> Expression -> TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
inlineLambda !functor expectedArity hasStrictArguments forceInlining inlinedExpr state history expr =
    let
        matches :: Expression -> Boolean;
        matches !expr =
            case expr of
            Var {name=exprName} -> exprName == functor;
            _ -> False;
            ;
    in
    if 
            not (matches (getFunctor expr)) 
        ||
        /*
         * If we are in code that was created directly or indirectly by inlining this function then
         * don't inline it again. 
         */
        (
            (isJust (find (\icVar -> icVar == functor) state.TransformState.inlinedContext)) &&
            not forceInlining
        )
    then // This is an optimization.
        (history, False, expr)
    else
        case flattenExpression expr [] of
        call_head : call_tail ->
            let
                
                /**
                 * Arity of the call.
                 */
                actualArity :: Int;
                actualArity = length call_tail;
                
                /**
                 * Get a list of the lambda vars and the leftover part of the
                 * expression.
                 */
                lambdaVarsHelper :: Expression -> [QualifiedName] -> (Expression, [QualifiedName]);
                lambdaVarsHelper !expr lVars = 
                    case expr of
                    Lambda lVar lType lWHFN lExpr ->
                        lambdaVarsHelper lExpr (lVar:lVars);
                    _ -> (expr, reverse lVars);
                    ;

                // A list of values indicating the strictness of the lambda variables.
                strictnessOfInlinedExprArgs :: [Boolean];
                strictnessOfInlinedExprArgs =
                    let                    
                        helper :: Expression -> [Boolean] -> [Boolean];
                        helper expr strictness = 
                            case expr of
                            Lambda {type=lType, expr=lExpr} -> helper lExpr (type_isStrict lType:strictness);
                            _ -> reverse strictness;
                            ;
                    in
                        helper inlinedExpr [];
                

                /**
                 * The lambda vars of the inlined expression.
                 */
                lambdaVarsAndInnerExpression :: (Expression, [QualifiedName]);
                lambdaVarsAndInnerExpression = lambdaVarsHelper inlinedExpr [];
                
                strictnessOfArgumentsInExpression :: [(QualifiedName, Type)];
                strictnessOfArgumentsInExpression = expression_getArgumentType state history lambdaVarsAndInnerExpression.#1;
        
                /**
                 * If the lambda expression was inlined will the variables in the
                 * arguments be at least as strict. However if the arg is a literal
                 * or lambda expression the strictness is ignored.
                 */
                
                atLeastAsStrict :: Boolean;
                atLeastAsStrict =
                    let
                        // Type of the function being inlined
                        maybeType :: Maybe (QualifiedName, Type);
                        maybeType = transformState_findType state history functor;
                    in
                        case maybeType of
                        // no type info so must assume this is not
                        // safe
                        Nothing -> False;
                        Just nameAndType -> 
                            let
                                type :: [Type];
                                type = flattenType nameAndType.#2;

                                // Strictness of the arguments of the function call. 
                                strictnessOfActualArgs :: [Boolean];
                                strictnessOfActualArgs = map type_isStrict type;
                                
                                // If the expected argument is strict then the actual argument must be 
                                // strict in its context.
                                argsAreAtLeastAsStrict :: [Boolean];
                                argsAreAtLeastAsStrict =
                                    zipWith 
                                        (\actual expected -> if expected then actual else True) 
                                        strictnessOfActualArgs 
                                        strictnessOfInlinedExprArgs;
                                
                                lambdaVars :: [QualifiedName];
                                lambdaVars = lambdaVarsAndInnerExpression.#2;
                                
                                typeOfArguments :: [(QualifiedName, Type)];
                                typeOfArguments = zip lambdaVars type;
                                
                                argIsLiteralOrLambda :: [Boolean];
                                argIsLiteralOrLambda =
                                    map (\expr -> isLiteral expr || isLambdaExpression expr) call_tail;
        
                                atLeastAsStrict :: QualifiedName -> Type -> Boolean;
                                atLeastAsStrict name type =
                                    let
                                        inExpression :: Maybe (QualifiedName, Type);
                                        inExpression = find (\tuple -> tuple.#1 == name) strictnessOfArgumentsInExpression;
                                    in
                                        case inExpression of
                                        Nothing -> False;
                                        Just inExpression_Just_value ->
                                            type_atLeastAsStrict type inExpression_Just_value.#2;
                                        ;    
                            in
                                andList (zipWith or argsAreAtLeastAsStrict argIsLiteralOrLambda);
//                                andList (zipWith or (map (uncurry atLeastAsStrict) typeOfArguments) argIsLiteralOrLambda);
                    ;
                                
                /**
                 * Return a map from variable name to the type of the variable in the
                 * expression. A variable may not appear in the list if the type is not
                 * known.
                 * 
                 * @arg state The context of the current expression.
                 * @arg history The history of the transformation.
                 * @arg expr The expression to get the strictness map for
                 * @return A list of pairs of variable names and their type.
                 * 
                 * TODO: This currently only works for straight-up applications.
                 */
                expression_getArgumentType :: TransformState -> TransformHistory -> Expression -> [(QualifiedName, Type)];
                expression_getArgumentType state history !expr =
                    let
                        call :: [Expression];
                        call = flattenExpression expr [];
                    in
                        case call of
                        functorExpr : arguments ->
                        case functorExpr of
                        Var {name=functorName} ->
                            let
                                maybeType :: Maybe (QualifiedName, Type);
                                maybeType = transformState_findType state history functorName;
                            in
                                if isNothing maybeType then
                                    []
                                else
                                    let
                                        type :: [Type];
                                        type = flattenType maybeType.Just.value.#2;
                                        
                                        /**
                                         * List that maps expression to type.
                                         */
                                        expressionAndTypeList :: [(Expression, Type)];
                                        expressionAndTypeList = filter (\tuple -> isVar tuple.#1) (zip arguments type);
                                        
                                        /**
                                         * List that maps qualified name to strictness.
                                         */
                                        varAndTypeList :: [(QualifiedName, Type)];
                                        varAndTypeList = 
                                            map 
                                            (\tuple ->
                                                case tuple of
                                                (tuple_1, tuple_2) ->
                                                    (tuple_1.Var.name, tuple_2);
                                            ) expressionAndTypeList;
                                    in
                                        varAndTypeList;
        
                        _ -> [];
                        ;;
                        
                safeForCaseInlining = inlinableState_canInlineCaseExpression state.TransformState.inlinableState;
                
            in
                // If this expression is a saturated call to the lambda expression then
                // inline the lambda expression.
                if 
                    matches (call_head) && 
//was commented out for pOrT 
                    actualArity == expectedArity && 
                    (not hasStrictArguments || atLeastAsStrict) &&
                    (inliningSafeForLambda state functor expectedArity inlinedExpr expr || isJust state.TransformState.fusionContext) &&
                    /*
                     * If the expression is going to be a recursive call to the soon to be created fusion
                     * function then do not do the inlining. 
                     */
                    (
                        case state.TransformState.fusionContext of
                        Nothing -> True;
                        Just fusionContext ->
                            case fusionContext of
                            FusionContext {isFusionCall} ->
                                if isFusionCall expr then
                                    False
                                else
                                    True;
                            ;
                    ) 
                    then
                     case
                         transform state history inlinedExpr (combineTransformsWithHistory renameLambdaVariables (combineTransformsWithHistory (renameLetVariables False) (renameCaseVariables))) of
                    (history1, _, inlinedExprPrime) ->
                        (case transform state history1 inlinedExprPrime renameLambdaVariables of
                        (history2, wasChanged, inlinedExprRenamed) ->
                            (history2, True, unflattenExpression (inlinedExprPrime : call_tail));
                        );                    
                else
                    (history, False, expr);
            ;

/**
 * Returns true if the expression contains a switch expression. TODO is this
 * necessary? Bugs arose compiling Format.cal
 */
expression_containsSwitch :: TransformState -> Expression -> Boolean;    
expression_containsSwitch state expr =
    let
        isLet :: TransformState -> Boolean -> Expression -> (Boolean, Expression);
        isLet state flag !expr =
            case expr of
            Switch {} -> (True, expr);
            _ -> (flag, expr);
            ;
    in
        (transformAcc state False expr isLet).#1;
        
/**
 * Takes the tail of a list where the tail of the empty list is the empty list.
 * 
 * @arg list The list to take the tail of.
 * @return If the list is empty the empty list is returned otherwise the tail of
 *         the list is returned. TODO Get rid of this function.
 */

safeTail :: [a] -> [a];
safeTail !list =
    case list of
    [] -> [];
    _ : tail -> tail;
    ;

/**
 * Determines if expr is recursive.
 * 
 * @arg self The name of the variable that is defined as expr
 * @arg expression The functions that defines self.
 * @return True iff expr calls self
 */

isRecursive :: QualifiedName -> Expression -> Boolean;
isRecursive !self !expression =
    case expression of    
    Var {name} -> name == self;
    DataConstructor {} -> False;
    DataConsSelection {dcValueExpr} -> isRecursive self dcValueExpr;
    Literal {} -> False;
    ErrorInfo _ -> False;
    App expr1 expr2 ->
        isRecursive self expr1 || isRecursive self expr2;
    Lambda lambdaVar _ _ lambdaExpr ->
        if lambdaVar == self then
            False
        else
            isRecursive self lambdaExpr;
        
    Let {variable=letVar, type=letType, expr=letExpr, body=letBody} ->
        isRecursive self letExpr || 
        (if letVar == self then
            False
        else
            isRecursive self letBody
        );
    LetInlinable {variable=letVar, expr=letExpr, body=letBody} ->
        isRecursive self letExpr || 
        (if letVar == self then
            False
        else
            isRecursive self letBody
        );
    Switch switchExpr switchAlts ->
        let
            isRecursiveAlt :: Alt -> Boolean;
            isRecursiveAlt alt = 
                case alt of
                (Alt | Alts) {expr} -> isRecursive self expr;
                ;
        in
            isRecursive self switchExpr || foldLeft (\cur alt -> cur || isRecursiveAlt alt) False switchAlts; 
        
    Opaque {} ->
            // make sure none of these have variables defined in them.
        False;
    RecordExtensionLiteral recordExtension ->
        foldLeft (\acc reTuple -> acc || (isRecursive self reTuple.#2)) False recordExtension;
    RecordExtensionPolymorphic body recordExtension ->
        foldLeft (\acc reTuple -> acc || (isRecursive self reTuple.#2)) (isRecursive self body) recordExtension;
    RecordSelection {expr} -> isRecursive self expr;
    ;
    

/**
 * Returns true if the expression contains a let/letinlinable expression. TODO
 * is this necessary? Bugs arose compiling Format.cal
 */
expression_containsLet :: TransformState -> Expression -> Boolean;    
protected expression_containsLet state expr =
    let
        /**
         * TODO make this stop when true.
         */
        isLet :: TransformState -> Boolean -> Expression -> (Boolean, Expression);
        isLet state flag !expr =
            case expr of
            Let {} -> (True, expr);
            LetInlinable {} -> (True, expr);
            _ -> (flag, expr);
            ;
    in
        case (transformAcc state False expr isLet) of
        (containsLet, _) -> containsLet;
        ;

/**
 * 3.3.1 - Fusion (not in the original paper but this is where it seems it would
 * go)
 * 
 * (f1 e1 e2 ï¿½ ek (f2 ek+1 ek+2 ï¿½ ek+m) ek+m+1 ï¿½ ek+m+n
 * 
 * to
 * 
 * let f1$f2 = eBodyï¿½ï¿½ in f1$f2 e1 e2 ï¿½ ek ek+1 ek+2 ï¿½ ek+m ek+m+1 ï¿½ ek+m+n
 * 
 * The optimizer looks for patterns as shown in the input pattern. If found the
 * optimizer makes an expression of the form
 * 
 * eBody: f1 a1 a2 ï¿½ ak (f2 ak+1 ak+2 ï¿½ ak+m) ak+m+1 ï¿½ ak+m+n
 * 
 * a<n> is a newly created variable name. The expression eBody is then
 * optimized. For all occurrences of the pattern eBody in eBodyï¿½ a call to f1$f2
 * is used instead. This produces the expression eBodyï¿½ï¿½. If there are no calls
 * to f1 or f2 in the expression eBodyï¿½ï¿½ then the fusion is successful and the
 * specified output is used as the new expression otherwise there is no change
 * to the expression and the output equals the input.
 */  

performFusion :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected performFusion state history0 !expr = 
    let
    
        currentFunctionName :: QualifiedName;
        currentFunctionName = state.TransformState.currentFunctionName;
        
        /**
         * Look for an expression of the pattern matching f1 as described above.
         * 
         * @arg state The context of the current expression.
         * @arg expr The expression so check for f1
         * @return The function definition for f1.
         * 
         * TODO: Change defs to use core function.
         */
        
        findF1 :: TransformState -> Expression -> Maybe (QualifiedName, Expression, Maybe [Type], Boolean, [Boolean]);
        findF1 state !expr =
            case getFunctorAndArity expr of
            (functor, arity) ->
                case functor of
                    Var {name=varName} ->
                        let
                            def :: Maybe (QualifiedName, Expression, Maybe [Type], Boolean, [Boolean]);
                            // TODO This should be an arg?
                            def = transformState_findDef state history0 varName;
                            defArity :: Int;
                            defArity = length def.Just.value.#5;
                            isSaturated :: Boolean;
                            isSaturated = defArity == arity;                         
                        in
                            if 
                               currentFunctionName == varName  || // don't try to fuse a function in its own body.
                               isNothing def || 
                               not isSaturated ||
                               arity == 0
                            then
                                Nothing
                            else
                                def;
                    _ -> Nothing;
                    ;
                ;
        
        maybeF1 :: Maybe (QualifiedName, Expression, Maybe [Type], Boolean, [Boolean]);
        maybeF1 = findF1 state expr;

        /**
         * Some expression of the form
         * 
         * f1 e1 e2 ... (f2 ei ei+1 ...) ej ... em
         * 
         * has been found. Where e stands for expression.
         * 
         * This function generalizes the call to an expression of the form
         * 
         * f l1 l2 (f2 li li+i ...) lj .. lm.
         * 
         * Where l stand for a local variable name. The types used and the local
         * variable names created are kept track of as well.
         * 
         * Example: Take an expression like (f1 (1+2) ("a" ++ "b") (f2 (77*3))
         * "hi") and create an expression like (f1 a1 a2 (f2 a3 a4) a5).
         * 
         * @arg f2 The name of the 'f2' function.
         * @arg fusionName The name of the fusion function being created. This
         *      is used to generate local variable names.
         * @arg expression The expression to generalize.
         * @return (<The generalized expression>, <The type of the expression>,
         *         <The number of arguments added>, <The names of the arguments
         *         added>)
         */
        
        generalizeCall :: QualifiedName -> QualifiedName -> Expression -> (Expression, Type, Int, [QualifiedName]);
        generalizeCall f2 fusionName expression =
//            let 
//                expressionAndCount :: ([Expression], [Type], Int, [QualifiedName]);
//                expressionAndCount = generalizeCallHelper f2 fusionName True 1 [] (flattenExpression expression []);
//            in
                case generalizeCallHelper f2 fusionName True 1 [] False (flattenExpression expression []) of
                (expression, type, count, args) ->
                    (unflattenExpression expression, unflattenAppTypes type, count, reverse args);
                ;    
        
        generalizeCallHelper :: QualifiedName -> QualifiedName -> Boolean -> Int -> [(QualifiedName)] -> Boolean -> [Expression] -> ([Expression], [Type], Int, [(QualifiedName)]);        
        generalizeCallHelper f2 fusionName isFirst counter rArgs alreadyFoundF2 !expressions =
            let
                functionName :: String;
                functionName = 
                    case fusionName of
                    QN {functionName} -> functionName;
                    ;
                    
                /**
                 * Replacing expressions with local variable names. Basically
                 * the trick here is to decide if the current expression is a
                 * call to f2. If so replace the arguments of that call with new
                 * local variables if not then replace the whole expression with
                 * a new variable.
                 * 
                 * Example: Take an expression like (f1 (1+2) ("a" ++ "b") (f2
                 * (77*3)) "hi") and create an expression like (f1 a1 a2 (f2 a3
                 * a4) a5). 
                 * 
                 * @arg f2 The name of f2
                 * @arg counter A counter for numbering the generalized argument names.
                 * @arg rArgs The arguments added in reverse order.
                 * @arg alreadyFoundF2 The f2 being subsituted is already found just substitute a var for the whole expression.
                 * @arg head The expression to generalize.
                 * @return (<The generalized expression>, <The type of the
                 *         expression>, <The number of arguments added>, <WasTheExpressionACallToF2> <The
                 *         names of the arguments added>)
                 */
            
                generalizeF2 :: QualifiedName -> Int -> [(QualifiedName)] -> Boolean -> Expression -> (Expression, Type, Int, Boolean, [(QualifiedName)]);
                generalizeF2 f2 counter rArgs alreadyFoundF2 !head =
                    let
                        flatHead :: [Expression];
                        flatHead = flattenExpression head [];
                        varName :: QualifiedName;
                        varName = QN (transformState_getModuleName state) (functionName ++ "$local" ++ show counter);
                        
                        /**
                         * If the expression contains additional type information then return a type
                         * expression that combines the given type information with the information from
                         * the expression.
                         * 
                         * @arg varType The known type of the variable.
                         * @arg expr The expression that is passed as an argument for the var and so could have additional type information.
                         * @return A type that contains as much type information as possible.
                         */
                         
                        getReturnType :: Type -> Expression -> Type;
                        getReturnType varType expr =
                            // todo this should be an arg
                            case expression_getType state history0 expr of
                            Just type -> AndType varType type;
                            Nothing -> varType;
                            ;
                    in
                        case flatHead of
                        functor : tail ->
                            case functor of
                            Var {name=functorName} ->
                                if functorName == f2 && not alreadyFoundF2 then
                                    let
                                        indexes :: [Int];
                                        indexes = upFromTo counter (counter+(length tail)-1);
                                        argNames :: [QualifiedName];
                                        argNames = map (\index -> 
                                                            QN (transformState_getModuleName state) (functionName ++ "$local" ++ show index)
                                                        ) indexes;
                                        argVars :: [Expression];
                                        argVars = map (\name -> Var name [] Nothing Nothing) argNames;
                                        
                                        argTypes :: [Type];
                                        argTypes = 
                                            map 
                                                (\ctrExpr ->
                                                    case ctrExpr of
                                                    (ctr, expr) -> getReturnType (TypeId ctr False) expr;
                                                ) 
                                                (zip indexes tail);
                                        
                                        argNamesAndRArgs :: [QualifiedName];
                                        argNamesAndRArgs = foldLeft (\cur arg -> arg : cur) rArgs argNames;
                                    in
                                        (
                                                unflattenExpression (Var f2 [] Nothing Nothing: argVars),
                                                (getReturnType  
                                                    (unflattenAppTypes
                                                        (
                                                            (
                                                                // todo this should be an arg
                                                                case transformState_findType state history0 f2 of
                                                                Just t -> t;
                                                                Nothing ->
                                                                    error ("Could not find " ++ show f2 ++ " in in function types list so not performing optimization");
                                                            ).#2 
                                                                : argTypes
                                                        )
                                                    ) 
                                                    head   
                                                ),  
                                                counter + length tail,
                                                True, 
                                                argNamesAndRArgs
                                        )
                                else
                                        (Var varName [] Nothing Nothing, getReturnType (TypeId counter False) head, counter+1, False, varName : rArgs);
                            _ -> 
                                (Var varName [] Nothing Nothing, getReturnType (TypeId counter False) head, counter+1, False, varName : rArgs);
                            ;
                        ;
                    
            in
                case expressions of
                [] -> ([], [], counter, rArgs);
                head : tail ->
                    let
                        newArgAndCounter :: (Expression, Type, Int, Boolean, [QualifiedName]);
                        newArgAndCounter =
                            if isFirst then
                                (head, (transformState_findType state history0 head.Var.name).Just.value.#2, counter, False, rArgs)
                            else
                                generalizeF2 f2 counter rArgs alreadyFoundF2 head;

                    in
                        case newArgAndCounter of
                        (newArgAndCounter_1, newArgAndCounter_2, newArgAndCounter_3, wasTheExpressionACallToF2, newArgAndCounter_4) ->
                            case generalizeCallHelper f2 fusionName False newArgAndCounter_3 newArgAndCounter_4 wasTheExpressionACallToF2 tail of
                            (expression, type, count, args) ->
                                (newArgAndCounter_1 : expression, newArgAndCounter_2 : type, count, args);
                            ;
                        ;    
                ;
        

        /**
         * Search for an 'f2' in the current expression.
         */
                
        findF2 :: TransformState -> Expression -> Maybe (QualifiedName, Expression, Maybe [Type], Boolean, [Boolean]);
        findF2 state !expr =
        let
            findF2Helper :: TransformState -> Int -> [Expression] -> Maybe (QualifiedName, Expression, Maybe [Type], Boolean, [Boolean]);
            findF2Helper state distance !exprs =
                case exprs of
                [] -> Nothing;
                e : es ->                     
                    let 
                        maybeF2 :: Maybe (QualifiedName, Expression, Maybe [Type], Boolean, [Boolean]);
                        maybeF2 =
                            findF1 state e;
                    in
                        case maybeF2 of
                        Nothing -> 
                            findF2Helper state (distance+1) es;
                        Just se -> maybeF2;
                        ;
                _ -> Nothing;
                ;
            in
                findF2Helper state 1 (tail (flattenExpression expr []));
        
        maybeF2 :: Maybe (QualifiedName, Expression, Maybe [Type], Boolean, [Boolean]);
        maybeF2 = findF2 state expr;

    in
        // look for an f1
        case maybeF1 of
        Just f1 ->
            // look for an f1
            case maybeF2 of
            Just f2 ->
                case f1 of
                (f1_name, f1_exprOriginal, f1_type, f1_isRecursive, f1_constArgs) ->
                case f2 of
                (f2_name, f2_exprOriginal, f2_type, f2_isRecursive, f2_constArgs) ->
                let
                    fusionTransformations :: [TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression)];
                    fusionTransformations = [
                                     transform_3_2_2        // inlining
                                   , transform_3_5_5        // lambda floating
                                   , transform_3_5_2
                                   , transform_3_5_2_withInlining
                                   , transform_simplifyCase
                                   , transform_3_1          // beta reduction
                                   , transform_evaluateCase
                                   , transform_redundantCases
                                   // Why is this here? Optimizer_Tests.test12                                                   
                                   , transform_specialization
                                   , transform_3_5_1
                                   , transform_canonizeSeq
                                   , transform_simplifySeq
                                   , transform_3_4_2
                                   , transform_evaluateArithmeticExpressions
                                   , transform_evaluateRecordSelection
                                   , transform_letFloatingFromCaseScrutinee
                                   , (transform_3_2_1 False)       // dead code elimination
                                  ];

                    /**
                     * The name of the function create by fusion of f1 and f2
                     */
                    fusionNameRoot :: QualifiedName;
                    fusionNameRoot =
                        QN (transformState_getModuleName state) (qualifiedName_getName f1_name ++ "$$$" ++ qualifiedName_getName f2_name);
                    
                    getNewNames history =
                        case transform state history f1_exprOriginal (renameVariables "3785") of
                        (history1, _, f1_expr) ->
                            case transform state history1 f2_exprOriginal (renameVariables "3787") of
                            (history2, _, f2_expr) -> 
                                case newVar state history2 fusionNameRoot "FUS" of
                                (history3, fusionName) -> 
                                    (history3, f1_expr, f2_expr, fusionName);
                                ;
                            ;
                        ;
                    
                    defPath :: [QualifiedName];
                    defPath = state.TransformState.debugPath;
                in
//                    // No fusion of a function from within it's own definition.
//                    if isJust (find (\name -> f1_name == name || f2_name == name) defPath) then
//                        (history0, False, expr)
//                    else
                    case getNewNames history0 of
                    (history, f1_expr, f2_expr, fusionName) ->
    //                /**
    //                 * Takes the current expression and generalizes it by
    //                 * turning all the argument expressions into local variable
    //                 * names.
    //                 */
    //                generalizedExprAndArgCount :: (Expression, Type, Int, [QualifiedName]);
                    case generalizeCall f2_name fusionName expr of
                    (generalizedExprAndArgCount_1, generalizedExprAndArgCount_2, generalizedExprAndArgCount_3, generalizedExprAndArgCount_4) ->
                        let
                            /**
                             * LetInlinable tells the inliner that it is allowed to
                             * inline this function once even though it is recursive.
                             * The inliner would normally not inline recursive
                             * functions.
                             */
                        
                            inner :: Expression;
                            inner =
                                if f1_name == f2_name then
                                    LetInlinable f2_name f2_type f2_expr generalizedExprAndArgCount_1 0 0 f2_constArgs
                                else
                                    LetInlinable f1_name f1_type f1_expr (LetInlinable f2_name f2_type f2_expr generalizedExprAndArgCount_1 0 0 f2_constArgs) 0 0 f1_constArgs;
                            
                            /**
                             * If the current call is a recursive call to the soon to be created 
                             * fusion function then call it now. 
                             */
                            transform_updateRecursiveCall :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
                            transform_updateRecursiveCall state history expr =
                                case useNewFunction expr of
                                (wasChanged, exprPrime) ->
                                    if wasChanged then
                                        (history, True, exprPrime)
                                    else
                                        (history, False, expr);
                                ;
                            
                            /**
                             * If the current expression is of the form (f1 ...
                             * (f2 ...) ...) then the expression is changed to
                             * call the fusion function instead.
                             * 
                             * @return (A flag indicating if the expression was changed, The possibly new functions)
                             */
                            
                            useNewFunction :: Expression -> (Boolean, Expression);
                            useNewFunction expr =
                                let
                                
                                    getArgs :: [Expression] -> ([Expression], Boolean);
                                    getArgs !args =
                                        case args of
                                        [] -> ([], False);
                                        a:as ->
                                            let
                                                innerArgs :: [Expression];
                                                innerArgs = flattenExpression a [];
                                                combine :: Expression -> ([Expression], Boolean) -> ([Expression], Boolean);
                                                combine head !ga = 
                                                    case ga of
                                                    (es, b) -> (head : es, b);
                                                    ;
                                            in
                                                case innerArgs of
                                                functor : rest ->
                                                    case functor of
                                                    Var {name=varName} ->
                                                        if varName == f2_name then
                                                            // stop calling 'getArgs as' since we used up the f2
                                                           (append rest as, True)
                                                        else
                                                            combine a (getArgs as);
                                                    _ ->                                                         
                                                        combine a (getArgs as);
                                                    ;
                                                ;
                                        ;
                                        
                                    flatExpr :: [Expression];
                                    flatExpr = flattenExpression expr [];

                                    /**
                                     * The type of the given expression. This is used for cases were one of
                                     * the function is not recursive and so will be eliminated during the 
                                     * fusion. The substitution of this call with a recursive one will only
                                     * be done if actual type and the expected type match.
                                     */
                                    
                                    maybeExpectedReturnType :: Maybe Type;
                                    maybeExpectedReturnType = expression_getType state history expr;
                                    
                                    /**
                                     * If the newExpr has the same return type as the old expression then
                                     * the substitution can occur. This is for the case that one of the 
                                     * functions fused is not recursive and will disappear from the resulting
                                     * function.
                                     */
                                    selectReturnExpression :: Expression -> (Boolean, Expression);
                                    selectReturnExpression newExpr =
                                        case maybeExpectedReturnType of
                                        Nothing -> (False, expr); // no change
                                        Just expectedReturnType ->
                                            let
                                                statePrime :: TransformState;
                                                statePrime = transformState_setType state fusionName generalizedExprAndArgCount_2;
                                                
                                                maybeNewExprType :: Maybe Type;
                                                maybeNewExprType = expression_getType statePrime history newExpr;
                                            in
                                                case maybeNewExprType of
                                                Nothing -> (False, expr);
                                                Just newExprType ->
                                                    if newExprType == expectedReturnType then
                                                        (True, newExpr)
                                                    else
                                                        (False, expr);
                                                ;   
                                        ;
                                    
                                in
                                    // if this is the expression being generalized then don't replace the call.
                                    if expr == generalizedExprAndArgCount_1 then
                                        (False, expr)
                                    else
                                        case flatExpr of
                                        functor : args ->
                                            case functor of
                                            Var {name=functorName} ->
                                                if functorName == f2_name && not f1_isRecursive && f2_isRecursive then
                                                    selectReturnExpression (unflattenExpression (Var fusionName [] Nothing Nothing:args))
                                                else if functorName == f1_name then
                                                    let
                                                        ga :: ([Expression], Boolean);
                                                        ga = getArgs args;
                                                    in
                                                        case ga of
                                                        (es, b) ->
                                                            if b then
                                                                (True, unflattenExpression (Var fusionName [] Nothing Nothing:es))
                                                            else
                                                                (False, expr);
                                                else
                                                    (False, expr);
                                            _ -> (False, expr);
                                            ;
                                        ;
                            
                            fusionArgs :: [QualifiedName]; 
                            fusionArgs = generalizedExprAndArgCount_4;

                            fusionType :: [Type]; 
                            fusionType =
                                let
                                    typeIdsFirst :: (Type, Type) -> (Type, Type);
                                    typeIdsFirst pair =
                                        case pair of
                                        (t1, t2) ->
                                            case t1 of
                                            TypeId {} -> pair;
                                            _ ->
                                                case t2 of
                                                TypeId{} -> (t2, t1);
                                                _ -> pair;
                                                ;
                                            ;
                                        ;
                                    /**
                                     * Unify the type variables
                                     */
                                    unification :: [(Type, Type)];
                                    unification =
                                        map typeIdsFirst
                                        (type_unify [(TypeId (length fusionArgs + 1) False, generalizedExprAndArgCount_2)]);
                                    
                                    /**
                                     * Substitute the most specific known
                                     * type for each of the variables.
                                     */
                                    applied :: [(Type, Type)];
                                    applied = type_applyBindings unification unification;
                                in
                                    type_listToType applied;
                            
                            /**
                             * The result of running the optimizer on the generalized
                             * expression.
                             */
                            innerPrime :: Expression;
                            innerPrime =
                                let
                                    statePrime :: TransformState;
                                    statePrime = transformState_deeper state fusionName;
                            
                                    isRecursiveCall :: Expression -> Boolean;
                                    isRecursiveCall expr =
                                        if f1_isRecursive && f2_isRecursive then
                                            False   // TODO fix this later
                                        else if not f1_isRecursive && f2_isRecursive then
                                            case (flattenExpression expr []) of
                                            functor : args ->
                                                case functor of
                                                Var {name} ->
                                                    name == f2_name &&
                                                    length args == length f2_constArgs;
                                                _ -> False;
                                                ;
                                        else
                                            False;

                                in
                                    case 
                                        (optimizeExplicitTwoStage 
                                             fusionTransformations 
                                             transform_updateRecursiveCall 
                                             (transformState_setPerformingFusion statePrime isRecursiveCall f1_name f2_name) 
                                             transformHistory_init 
                                             (16::Int) 
                                             (addLambdaVars (zip fusionArgs fusionType) inner)
                                             ) of
                                    (history1, wasChanged1, expr1) ->
                                        case expr1 of
                                        LetInlinable {body} -> 
                                            case body of
                                            LetInlinable {body} -> body;
                                            _ -> body;
                                            ;
                                        _ -> expr1;
                                        ;
                                    ;
                        in
                                let
                                    /**
                                     * The result of replacing all calls of the form (f1
                                     * ... (f2 ...) ...) with a recusive call to the
                                     * fusion function being created.
                                     * 
                                     * TODO: Make sure this is doing matches on arity.
                                     */
                                
                                    innerPrimeGeneralized :: Expression;
                                    innerPrimeGeneralized =
                                            (transform
                                                (transformState_init (transformState_getName state) state.TransformState.typeConstants [] [] [] innerPrime [] [])
                                                transformHistory_init
                                                innerPrime 
                                                (\ts th expr ->
                                                    case useNewFunction expr of
                                                    (wasChanged, exprPrime) -> (th, wasChanged, exprPrime);
                                                 )).#3;

                                    /**
                                     * Is the expression a recursive call to the soon to be defined fusion function.
                                     * This is used to prevent inlining from inlining function definitions.
                                     */
                                    isRecursiveCall :: Expression -> Boolean;
                                    isRecursiveCall expr = (useNewFunction expr).#1;
                                                           
                                    generalization :: Expression;
                                    generalization = (useNewFunction expr).#2;
                                    
                                    fusionDef :: Expression;
                                    fusionDef = innerPrimeGeneralized;
                                    
                                in  
                                    let
                                        arity :: Int;
                                        arity = length fusionArgs;
                                        
                                        functionArguments :: [QualifiedName];
                                        functionArguments = generalizedExprAndArgCount_4;
                                        functionBody :: Expression;
                                        functionBody = innerPrimeGeneralized;
        
                                        functionConstVars :: [Boolean];
                                        functionConstVars = constVars fusionName state.TransformState.typeConstants functionArguments functionBody;
                     
                                        historyPrime :: TransformHistory;
                                        historyPrime =                                             
                                            transformHistory_update fusionName fusionDef (Just fusionType) functionConstVars history;
        
                                        /**
                                         * Is the body just a recursive call to the fusion function itself
                                         */
                                        trivialDefinition :: Boolean;
                                        trivialDefinition =
                                            let
                                                flat :: [Expression];
                                                flat = flattenExpression (removeLambdaVars fusionDef) [];
                                            in
                                                case flat of
                                                functor : args ->
                                                    // enough of a test to figure this out
                                                    case functor of
                                                    Var {name} -> fusionName == name;
                                                    _ -> False;
                                                    ;
                                            ;
                                        
                                        /**
                                         * The fusion calls itself and no longer call
                                         * the functions that it is based upon.
                                         */
                                        
                                        isFusionOk :: Boolean;
                                        isFusionOk =
                                            not trivialDefinition &&
                                            // The fusion calls itself
//                                            (containsFree fusionName fusionDef || f1_isRecursive || f2_isRecursive) &&
                                            (
                                                if f1_isRecursive || f2_isRecursive then
                                                    containsFree fusionName fusionDef 
                                                else
                                                    False
                                            ) &&
                                            // The fusion does not call f1
//                                            (not (containsFree f1_name fusionDef) || not f2_isRecursive) &&
                                            (
                                                if containsFree f1_name fusionDef then
                                                    True || not f1_isRecursive
                                                else
                                                    True
                                            ) &&
                                            // The fusion does not call f2
//                                            (not (containsFree f2_name fusionDef) || not f1_isRecursive) &&
                                            (
                                                if containsFree f2_name fusionDef then
                                                    True || not f2_isRecursive
                                                else
                                                    True
                                            ) // &&
//                                            (
//                                                (f1_isRecursive && f2_isRecursive) ||
//                                                (not f1_isRecursive && f2_isRecursive)
//                                            ) &&
//                                            (not (transform_hasBadStructure "" True (removeLambdaVars fusionDef)))
                                            ;
                                in                                  
                                        if (onlyRecursive_fusion && (not f1_isRecursive || not f2_isRecursive))
//                                        || (f1_name.QN.functionName ==  "spiral$spiral$$$tail1FUS" && f2_name.QN.functionName == "tail")
//                                        || (f1_name.QN.functionName ==  "spiral$spiral$$$tail13FUS" && f2_name.QN.functionName == "tail")
                                        then
                                            (history, False, expr)
                                        else if (transformHistory_didFusionFail history f1_name f2_name) then
                                            (history, False, expr)
                                        else if isFusionOk then
                                        // If the fusion was performed successfully then
                                        // keep it otherwise
                                        // the result of combining the functions did not
                                        // produce a new
                                        // recursive function. TODO Should this check
                                        // for occurences of
                                        // f1 and f2 as well?
                                            (historyPrime, True, (Let fusionName True False False (Just fusionType) fusionDef generalization True (length functionConstVars) False functionConstVars history.TransformHistory.currentIteration False))
                                        else
                                            // Oh bummer, the fusion failed.
                                            (
                                                transformHistory_fusionFailed history f1_name f2_name,
                                                False, 
                                                expr
                                            );
                        ;;
                    ;
                ;    
            Nothing -> (history0, False, expr);
            ;
        Nothing -> (history0, False, expr);
        ;
        
tShower :: String -> 
    (TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression)) -> 
    (TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression));
protected tShower label transform state history expression =
//    transform state history expression;
    case transform state history expression of
    (history1, wasChanged1, expr1) ->
        trace (
            if 
//                   wasChanged1 &&
                   (
                       (String.indexOfString "pear" (show expression)) != -1 &&
                       (String.indexOfString "pear" (show expr1)) == -1
                   )
//                   && (label == "f") 
//                   (expressionIsomorphic expr1 expression)
//                   && startsWith "(Cal.Core.Prelude.seq 1 (Cal.Core.Prelude.seq Optimizer_Test.test12$end$3 (case (Cal.Core.Prelude.greaterThanInt Optimizer_Test.test12$tes" (show expression)
            then
                label ++ "\n" ++ "" ++
//                "   counter: " ++ show history.TransformHistory.counter ++ "/" ++ show history1.TransformHistory.counter ++ "\n" 
                "============================\n" ++
                "    before: " ++ show expression ++ "\n" ++
                "    parent: " ++ show state.TransformState.parentExpr ++ "\n" ++
                "    grandparent: " ++ show state.TransformState.grandParentExpr ++ "\n" ++
//                "============================\n" ++
//                "    debugPath: " ++ show state.TransformState.debugPath ++ "\n" ++
                "============================\n" ++
                "    after: " ++ show expr1 ++ "\n" 
            else
                ""
        )        
        (history1, wasChanged1, expr1);
    ;

/**
 * Helper function for showing the input and output of a transformation if the
 * transformation changes the expression.
 */

tShower3 :: String ->  
    (TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression)) -> 
    (TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression));
protected tShower3 label transform =   
    (\state history expr ->
        let
            r = transform state history expr;
        in
            case r of
            (_,wasChanged,exprPrime) ->
                trace2 (
                let
                    checkIt2 :: Boolean;
                    checkIt2 = 
                        let
                            name1 :: QualifiedName;
                            name1 = QN "Parser" "pOrT3a$pOrT3a$pOrT$reply2$98LET59LET";
                            
                            name2 :: QualifiedName;
                            name2 = QN "Parser" "pOrT3a$pOrT$reply2$98LET";
                            
                            findOuterInner :: Expression -> Boolean;
                            findOuterInner expr = 
                                Optimizer_Traversers.traverseTopDownAcc False state expr findOuterHelper;
                                 
                            findOuterHelper :: Boolean -> TransformState -> Expression -> (Boolean, Boolean);
                            findOuterHelper wasFound state expr =
                                case expr of
                                Let {variable, body} ->
                                    if variable == name1 then
                                        (True, (Optimizer_Traversers.traverseTopDownAcc wasFound state body findInnerHelper))
                                    else
                                        (True, wasFound);
                                _ -> (True, wasFound);
                                ;

                            findInnerHelper :: Boolean -> TransformState -> Expression -> (Boolean, Boolean);
                            findInnerHelper wasFound state expr =
                                case expr of
                                Let {variable, body} ->
                                    if variable == name2 then
                                        (False, True)
                                    else
                                        (True, wasFound);
                                _ -> (True, wasFound);
                                ;
                            
                        in 
                            (not (findOuterInner expr)) && (findOuterInner exprPrime);
                        
//                    lookFor :: String;
//                    lookFor =
//                        "Parser.pOrT3a$pOrT$reply2$98LET"; 
//                        "(Let((substNoRename) 3) Parser.pOrT3a$pOrT$reply2$85LET/-1OLD KEEP ";
//                        "(Let((substNoRename) 3) Parser.pOrT3a$pOrT$reply2$85LET/-1OLD KEEP(App (DataConsSelection (Var Parser.pOrT3a$parser3$3) (Parser.Parser).0) (Var Parser.pOrT$state$3)";
//                        "(App (DataConsSelection (Var Parser.pOrT3a$parser3$3) (Parser.Parser).0) (Var Parser.pOrT$state$3)) InLet(Parser.pOrT3a$pOrT$reply2$85LET) (App (App (Var Cal.Core.Prelude.seq) (Var Parser.pOrT3a$pOrT$consumed1$66RCV)) (App (DataConsSelection (Var Parser.pOrT3a$parser3$3)";
                    
                    goesAway :: String;
//                    goesAway = "reply2$85LET)); \"_\"  -> (Var Parser.pOrT3a$pOrT$reply1$48LET);] )";
//                    goesAway = "Parser.pOrT3a$pOrT3a$pOrT$reply1$48LET20904i";
//                    goesAway = "[ Parser.Ok  2/Parser.pOrT3a$mergeErrorReply$x$4116RCV 3/Parser.pOrT3a$mergeErrorReply$state$5117RCV";
                    goesAway = 
//                        "of [ Parser.Ok  2/Parser.pOrT3a$mergeErrorReply$x$4116RCV";
//                        "M2.sieveBasedGetNthPrime2$primes$2";
                    "(\\M2.testDerivedEnumIndependence$testDerivedEnumIndependence$testDerivedEnumIndependence$testDerivedEnumIndependence$equalsEBNOList$y$233RNV35RNV37RNV50RNV -> (case M2.testDerivedEnumIndependence$testDerivedEnumIndependence$testDerivedEnumIndependence$testDerivedEnumIndependence$equalsEBNOList$y$233RNV35RNV37RNV50RNV of [ []  -> Cal.Core.Prelude.True; \"_\"  -> Cal.Core.Prelude.False;] )) M2.testDerivedEnumIndependence$equalsEBNOList$restY$615RCV";
                    
                    checkGoesAway :: String -> Boolean;
                    checkGoesAway goesAway =
                        String.indexOfString goesAway es != -1 &&
                        String.indexOfString goesAway esp == -1;

                    checkAppears :: String -> Boolean;
                    checkAppears appears = 
                        String.indexOfString appears es == -1 &&
                        String.indexOfString appears esp != -1;
                    
                    appears :: String;
                    appears = //"(case Parser.pOT3a$pOrT$consumed2$1610RCV of [ Parser.Consumed  -> (Parser.Error 1 (Parser.mergeError Parser.pOrT3a$pOrT3a$pOrT$err1$715RCV170EVCS Parser.pOrT3a$$_11RCV ) ); \"_\"  -> Parser.pOrT3a$pOrT$reply2$1413LET;";
//                        "Parser.pOrT3a$pOrT$reply2$1413LET";
//                        "Parser.pOrT3a$mergeErrorReply$x$4116RCV";
//                        "(Parser.Ok 1 Parser.pOrT3a$mergeErrorReply$x$4116RCV";
//                        "Parser.pOrT3a$mergeErrorReply$x$4116RCV";
//                    "(case (Parser.Ok 1 Parser.pOrT3a$mergeErrorReply$x$4116RCV";
//                    "(Optimizer_Test.andList$$$map Optimizer_Test.andList$$$map$$$upFromByUpToInt$local1 [] )";
//                    "(case (Optimizer_Test.andList$$$map$$$upFromByUpToInt$local1 Optimizer_Test.test12$test12$test12$map$listHead$31RCV5RCV9EVCS ) of [ Cal.Core.Prelude.True  -> (Optimizer_Test.andList$$$map Optimizer_Test.andList$$$map$$$upFromByUpToInt$local1 Optimizer_Test.test12$test12$test12$map$listTail$42RCV6RCV10EVCS ); Cal.Core.Prelude.False  -> Cal.Core.Prelude.False;] )";
//                        "M2.sieveBasedGetNthPrime2$rank$1 M2.sieveBasedGetNthPrime2$rank$1";
                        "(\\M2.testDerivedEnumIndependence$testDerivedEnumIndependence$testDerivedEnumIndependence$testDerivedEnumIndependence$equalsEBNOList$y$233RNV35RNV37RNV50RNV";
//                    "Cal.Core.Prelude.seq Optimizer_Test.test12$end$3 (case (Cal.Core.Prelude.greaterThanInt";
//                        "(Cal.Core.Prelude.seq Optimizer_Test.test12$test12$test12$test12$andList$$$map19FUS$$$upFromByUpToInt38FUS$local254RNV58RNV ";
//                              "(case Parser.pOrT3a$pOrT$consumed2$1610RCV of [ Parser.Consumed  -> (Parser.Error 1 (Parser.mergeError Parser.pOrT3a$pOrT3a$pOrT$err1$715RCV170EVCS Parser.pOrT3a$$_11RCV ) );";                         

                    es :: String;
                    es = show expr;
                    
                    esp :: String;
                    esp = show exprPrime;
                in
                    if
//                        wasChanged && 
                        (String.length es) > 1 && (String.length esp) > 1 &&
//                        True
//                        checkIt
//                        checkAppears appears 
                        checkGoesAway goesAway 
                    then
                        "HAPPENING\n" ++
                        "   label:" ++ show label ++ "\n" ++
                        "    expr: " ++ show expr ++ "\n" ++
                        "    prim: " ++ show exprPrime ++ "\n" ++
                        "    boundNames: " ++ show state.TransformState.inContextBoundNames ++ "\n" ++
                        "exprstru: " ++ showExpressionStructure expr ++ "\n" ++
                        "primstru: " ++ showExpressionStructure exprPrime ++ "\n"
                        
                    else 
                        ""
//                        if String.indexOfString "Parser.pOrT3a$pOrT$reply2$85LET" (showExpressionStructure exprPrime) != -1 then
//                            label ++ "/" ++ showExpressionStructure exprPrime ++ "\n"
//                        else
//                            ""
                )
                r;
    );

functorMatches :: Expression -> QualifiedName -> Boolean;
functorMatches !expr !functorName =
    case expr of
    Var {name=exprName} -> exprName == functorName;
    _ -> False;
    ;

/**
 * For the function f a1 a2 a3 ... ak look in the body for recursive calls. The
 * recursive called will be of the form f a1 a2' ... ai' ... ak . The non-primed
 * arguments are constant throughout the call. This means that the values can be
 * bound and the arguments removed the caller.
 * 
 * The constVars is a list with the same arity as f.
 */
        
constVars :: QualifiedName -> JPreludeTypeConstants -> [QualifiedName] -> Expression -> [Boolean];
protected constVars !functionName typeConstants !functionArguments !functionBody =
    let
        arity :: Int;
        arity = length functionArguments;

        /**
         * Used to get the expression in an expression that are calls to the
         * function being fused. The purpose is to find out the arguments that
         * are passed unchanged. For example in
         * 
         * f a e2 c ... f e1 e3 c
         * 
         * The 3rd argument is the only one passed unchanged.
         */

        collectCalls :: TransformState -> [[Expression]] -> Expression -> ([[Expression]], Expression);
        collectCalls state calls expr  =
            let
                noChange :: ([[Expression]], Expression);
                noChange = (calls, expr);
                
                currentCall :: [Expression];
                currentCall = flattenExpression expr [];                
            in
                case currentCall of
                currentCall_head : currentCall_tail ->
                    if functorMatches currentCall_head functionName && arity == length currentCall_tail then
                        (currentCall:calls, expr)
                    else
                        noChange;
                ;    
         
        /**
         * Takes the given expression and converts it to a list of the ordinals
         * of arguments that are passed unchanged to the recursive call of the
         * function. For example, [True, False, True] is the vector for
         * 
         * f a b c = ... f a bPrime c ...
         */
            
        constArgs :: [Expression] -> [Boolean];
        constArgs expr =
            let
                isConstArg :: (Expression, QualifiedName) -> Boolean;
                isConstArg !exprArgOrdinalTuple =
                    let
                        matches :: Expression -> QualifiedName -> Boolean;
                        matches !expr !argName =
                            case expr of
                            Var {name=exprName} -> argName == exprName;
                            _ -> False;
                            ;
                    in
                        case exprArgOrdinalTuple of
                        (expr, arg) -> matches expr arg;
                        ;
            in
                map isConstArg (zip (tail expr) functionArguments);
        
        /**
         * Takes the list of calls and figures out what arguments are always
         * passed unchanged to the recursive call. For example [True, False,
         * True] would be the vector for
         * 
         * f a b c = ... f a bPrime c ...
         */
            
        unchangedOrdinals :: [Boolean];
        unchangedOrdinals =
            let
                calls :: [[Expression]];
                calls = (transformAcc (transformState_init functionName typeConstants [] [] [] functionBody [] []) [] functionBody collectCalls).#1;
                                                                
                callsConstArgs :: [[Boolean]];                                        
                callsConstArgs = map constArgs calls;
                
                andTuples :: [[Boolean]] -> [Boolean];
                andTuples !tuples =
                    case tuples of
                    [] -> [];
                    t1 : ts1 ->
                        case ts1 of
                        [] -> t1;
                        t2 : ts2 ->
                            andTuples ((zipWith and t1 t2):ts2);
                        ;
                    ;
            in
                andTuples ( (map (\ignored -> True) functionArguments) : callsConstArgs );
    in
        unchangedOrdinals;
        
    
/**
 * Performs a bottom up tranversal of the expression. The given set of
 * transformations are performed on the sub-expressions. The expression is
 * traverse nIterations number of times.
 *
 * @arg transformations The set of transformations to perform on the
 *      sub-expressions.
 * @arg transformState Information about the current context of the expression
 *      traversal.
 * @arg transformHistory Information about the history of the current
 *      transformation.
 * @arg nIterations The number of times to traverse the expression performing
 *      optimization. There could be fancier control but currently that seems no
 *      necessary.
 * @arg expr The expression to transform.
 * @return The result of performing the given transformations on the input
 *         expression.
 */

//protected optimizeExplicit transformations transformState transformHistory !nIterations expr =
//    optimizeExplicit False transformations transformState transformHistory nIterations expr;

protected optimizeExplicit transformations transformState transformHistory !nIterations expr =
    let

        /**
         * Applies the transformations to the expression a specified number of
         * times.
         * 
         * @arg history The history of the transformation.
         * @arg expr The expression to transform.
         * @arg ctr The number of times to apply the transformations.
         * @arg wasChangedAcc Flag indicating if the expression has been changed.
         * @return The result of applying the transformations the given number of times.
         */

        helper :: TransformHistory -> Expression -> Int -> Boolean -> (TransformHistory, Boolean, Expression);
        helper history !expr !ctr !wasChangedAcc =            
            if ctr > 0 && not (transformHistory_takingTooLong history) then 
                let
                    historyExpr :: (TransformHistory, Boolean, Expression);
                    historyExpr =
                        transform transformState history expr (transformer transformations);
                in
                    case historyExpr of
                    (history1, wasChanged1, expr1) ->
                    // TODO Does this still need to be here after I fixed that stack problem?
                        expr1 `deepSeq` history1 `deepSeq`
                        ( 
                            // the ctr tests are to because the inlining is separate do we cannot stop
                            // until both the inlining and all the other transformations are done.
                        if wasChanged1 then
                            (helper (transformHistory_incrementCurrentIteration history1) expr1 (ctr - 1) wasChanged1)
                        else
                            (history1, wasChangedAcc, expr1));
            else
                (history, wasChangedAcc, expr);            
    in
        helper transformHistory expr nIterations False;

optimizeExplicitTwoStage :: 
    [TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression)] ->
    (TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression)) ->
    TransformState -> TransformHistory -> Int -> Expression -> (TransformHistory, Boolean, Expression);    
protected optimizeExplicitTwoStage transformations stateTwo transformState transformHistory !nIterations expr =
    let

        /**
         * Applies the transformations to the expression a specified number of
         * times.
         * 
         * @arg history The history of the transformation.
         * @arg expr The expression to transform.
         * @arg ctr The number of times to apply the transformations.
         * @arg wasChangedAcc Flag indicating if the expression has been changed.
         * @return The result of applying the transformations the given number of times.
         */

        helper :: TransformHistory -> Expression -> Int -> Boolean -> (TransformHistory, Boolean, Expression);
        helper history !expr !ctr !wasChangedAcc =            
            if ctr > 0 && not (transformHistory_takingTooLong history) then
                let
                    historyExpr :: (TransformHistory, Boolean, Expression);
                    historyExpr = transform transformState history expr (transformer transformations);
                in
                    case historyExpr of
                    (history1, wasChanged1, expr1) ->
                        case transform transformState history1 expr1 stateTwo of
                        (history2, wasChanged2, expr2) -> 
                            expr2 `deepSeq` history2 `deepSeq`
                            ( 
                            if wasChanged1 || wasChanged2 then        
                                (helper (transformHistory_incrementCurrentIteration history2) expr2 (ctr - 1) (wasChanged1 || wasChanged2))
                            else
                                (history2, wasChangedAcc, expr2));
                        ;
            else
                (history, wasChangedAcc, expr);            
    in
        helper transformHistory expr nIterations False;

/**
 * Evaluate record selection if possible. See tests 17-21 in Optimizer_Tests.cal
 *
 * For example, (Just x).Just.value => x.
 */
 
transform_evaluateRecordSelection :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_evaluateRecordSelection state history expression =
    case expression of
    DataConsSelection dcExpr dcsDataCons fieldIndex _ ->
        case flattenExpression dcExpr [] of
        functor : args ->
            case functor of
            DataConstructor {dc} ->
                let
                    field :: Expression;
                    field = List.subscript args fieldIndex;
                in
                    // Some tests have deliberate errors in them so the data constructor must be checked
                    if 
                        dcsDataCons == dc &&
                        canSelectStrictArguments state history dc args 0 field 
                    then
                        (history, True, selectStrictArguments state history dc args 0 field)
                    else
                        (history, False, expression);
            _ -> (history, False, expression);
            ;
        ;
    _ -> (history, False, expression);
    ;

/**
 * Build a Prelude.seq call with the given arguments.
 */
makeSeqCall :: TransformState -> TransformHistory -> Expression -> Expression -> Expression;
makeSeqCall state history a b = 
    (App (App (prelude_seq_expr state) a) b);
                        
/**
 * For the given list of args build a collection if Prelude.seq statements for the given
 * type if necessary.
 *
 * @arg state The context of the current transformation.
 * @arg history Information from the history of the transformation.
 * @arg dc The data constructor that the args are applied to.
 * @arg args The args of the given data constructor.
 * @arg counter The index of the first arg in the args list.
 * @arg answer The expression that is the value of the final expression.
 */                        
selectStrictArguments :: TransformState -> TransformHistory -> DataCons -> [Expression] -> Int -> Expression -> Expression;
selectStrictArguments state history dc !args !counter answer = 
    case args of
    [] -> answer;
    x:xs ->
        if dataCons_isStrict dc counter then
            makeSeqCall state history x (selectStrictArguments state history dc xs (counter+1) answer)
        else    
            selectStrictArguments state history dc xs (counter+1) answer;
    ;

/**
 * Helper function to determine if selectStrictArguments will work when
 * calling selectStrictArguments.
 */
canSelectStrictArguments :: TransformState -> TransformHistory -> DataCons -> [Expression] -> Int -> Expression -> Boolean;
canSelectStrictArguments state history dc !args !counter answer = 
    case args of
    [] -> True;
    x:xs ->
        if dataCons_isStrict dc counter then
            if isLiteral x || isVar x then                
                canSelectStrictArguments state history dc xs (counter+1) answer
            else
                False
        else    
            canSelectStrictArguments state history dc xs (counter+1) answer;
    ;

/**
 * Lift let definitions higher up to open the expression up for other optimizations.
 * 
 * Input:
 * 
 *      (e1 (let v=d in e2))
 *  
 * Output:
 * 
 *      (let v=d in (e1 e2)) as long as v is not free in e1.
 *      
 * Input:
 * 
 *      ((let v=d in e1) e2)
 *      
 * Output:
 * 
 *      (let v=d in (e1 e2))
 *      
 */    

transform_3_4_2 :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_3_4_2 state history !expr =
    case expr of
    App expr1 expr2 ->
        case expr2 of
        Let variable isNew isKeepable isTopLevel type defExpr expr2 isRecursive arity isCoreFunction constArgs _ z_ ->
            if contains variable expr1 then
                (history, False, expr) // no change
            else
                (history, True, Let variable isNew isKeepable isTopLevel type defExpr (App expr1 expr2) isRecursive arity isCoreFunction constArgs history.TransformHistory.currentIteration False);
        _ ->
            case expr1 of
            Let variable isNew isKeepable isTopLevel type defExpr expr1 isRecursive arity isCoreFunction constArgs _ _ ->
                if contains variable expr2 then
                    (history, False, expr) // no change
                else
                    (history, True, Let variable isNew isKeepable isTopLevel type defExpr (App expr1 expr2) isRecursive arity isCoreFunction constArgs history.TransformHistory.currentIteration False);
            _ -> (history, False, expr); // no change    
            ;
        ;
        
//    Switch switchExpr alts ->
//        case alts of
//        a:as -> 
//            case as of
//            [] ->
//                case a of
//                Alt caseConst isPositional vars altExpr ->
//                    case altExpr of
//                    Let variable isNew isKeepable type defExpr expr2 isRecursive arity isCoreFunction constArgs _ _ ->
//                        if contains variable switchExpr || not (isEmpty vars) then
//                            (history, False, expr) // no change
//                        else
//                            let
//                                altPrime :: Alt;
//                                altPrime = Alt caseConst isPositional vars expr2;
//                                
//                                altsPrime :: [Alt];
//                                altsPrime = [altPrime];
//                            in
//                                (history, True, Let variable isNew isKeepable type defExpr (Switch switchExpr altsPrime) isRecursive arity isCoreFunction constArgs history.TransformHistory.currentIteration False);
//                             
//                    _ -> (history, False, expr);
//                    ;
//                ;                
//            _ -> (history, False, expr);
//            ;
//        ;
//        
//    Lambda lVar lExpr ->
//        case lExpr of
//        Let variable isNew isKeepable type defExpr expr2 isRecursive arity isCoreFunction constArgs _ _ ->
//            if contains lVar expr2 then
//                (history, False, expr) // no change
//            else
//                (history, True, Let variable isNew isKeepable type defExpr (Lambda lVar expr2) isRecursive arity isCoreFunction constArgs history.TransformHistory.currentIteration False);
//        _ -> 
//            (history, False, expr); // no change    
//        ;
    _ -> (history, False, expr); // no change    
    ;    

/**
 * Lift let definitions higher up to open the expression up for other optimizations. (3.4.3)
 * 
 * Input:
 * 
 *      case (let v = ev in e) of alts
 *  
 * Output:
 * 
 *      let v = ev in (case e of alts) where v is not free in alts.
 *      
 */    
    
transform_letFloatingFromCaseScrutinee :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_letFloatingFromCaseScrutinee state history !expr =
    case expr of
    Switch letExpr alts ->
        case letExpr of
        Let variable isNew isKeepable isTopLevel type defExpr expr2 isRecursive arity isCoreFunction constArgs _ _ ->
            if containsFree variable (Switch (Literal (LitString "")) alts) then
                (history, False, expr) // no change
            else
                (history, True, Let variable isNew isKeepable isTopLevel type defExpr (Switch expr2 alts) isRecursive arity isCoreFunction constArgs history.TransformHistory.currentIteration False);
        _ -> 
            (history, False, expr); // no change    
        ;
    _ -> (history, False, expr); // no change    
    ;    

/**
 * This a hack. This will return true iff
 * 
 * 1. The expression contains non-top level cases. 
 * 2. The expression contains lambda expressions.
 * 
 * @arg isTopLevelExpr Is this expression starting at the top level or lower. If lower then lambda's and case expressions are not allowed.
 * @arg expr The expression to check for bad structure. 
 */    
    
transform_hasBadStructure :: Boolean -> Expression -> Boolean;
protected transform_hasBadStructure isTopLevelExpr !expr =
    let

        /**
         * @arg isTop If the expression is at the top level.
         * @arg allowCaseExpr Should case expression still be allowed.
         * @arg allowLambdaExpr If the current expression is in a let definition and so lambda's are allowed.
         * @arg exprIn The expression to check.
         */
        helper :: Boolean -> Boolean -> Boolean -> Expression -> Boolean;
        helper !isTop allowCaseExpr allowLambdaExpr !exprIn =
            case exprIn of
            App expr1 expr2 ->
                if isTop && allowCaseExpr then
                    let
                        calls :: [Expression];
                        calls = flattenExpression exprIn [];
                    in
                        case calls of
                        head : tail -> 
                            helper True False False head || 
                            orList (map (helper False False False) tail);
                else
                    helper False False False expr1 || helper False False False expr2;
                
            Lambda {expr} ->
                if allowLambdaExpr then
                    helper True True True expr
                else
                    True;
            
            Let {isNew, isKeepable, expr, body} ->
                if ((not isTop) && isNew) && isKeepable then
                /*
                 * If the let is going to be lifted then the expression does not automatically have bad structure.
                 */
                    if helper False True False expr then
                        helper isTop False True body
                    else
                        True
                else
//                    helper False True True expr || helper isTop False True body; 
                    if helper False True False expr then
                        helper isTop False True body
                    else
                        True;
                
            Switch expr alts ->
                let
                    altHasBadStructure :: Alt -> Boolean;
                    altHasBadStructure !alt =
                        helper True False False (alt_getExpr alt);
                in
                    if isTop then
                        helper False False False expr || foldLeft (\curr alt -> curr || altHasBadStructure alt) False alts
                    else
                        // switches that will be converted back to if's are safe
                        let
                            convertedExpr :: Expression;
                            convertedExpr = transform_convertToIfs exprIn;
                        in
                            case convertedExpr of 
                            Switch {} -> True;
//                            _ -> transform_hasBadStructure allowCaseExpr convertedExpr;
                            _ -> helper isTop allowCaseExpr allowLambdaExpr convertedExpr;
                            ;
                
            RecordSelection {expr} -> helper False False False expr;  
                    
            RecordExtensionLiteral {fieldsMap} -> orList (map (\fne -> helper False False False fne.#2) fieldsMap); 
                                      
            RecordExtensionPolymorphic {expr, fieldsMap} ->
                helper False False False expr || orList (map (\fne -> helper False False False fne.#2) fieldsMap); 

            DataConsSelection {dcValueExpr} -> helper False False False dcValueExpr;
            
            RecordCase {expr, resultExpr} -> helper False False False expr || helper False False False resultExpr;

            _ -> False;
            ;
    in
        helper isTopLevelExpr isTopLevelExpr isTopLevelExpr expr;
    
/**
 * Look for expressions of the form 
 * 
 *      switch expr of True -> altExpr1; False -> altExpr2;
 *      
 * and convert them to If applications
 *
 * @arg expression The expression to check for switch to if conversions.
 * 
 *  Note: Only does the conversion of the switch expression is not another switch expression.
 */
    
transform_convertToIfs :: Expression -> Expression;
protected transform_convertToIfs !expression =
    case expression of
    Switch expr alts ->
        let
            isSwitch :: Expression -> Boolean;
            isSwitch expr = case expr of Switch{} -> True; _ -> False; ;
        in
            // Two alts, no cases in the switch expr or the alts
            if length alts == 2 && not (isSwitch expr) then
                case alts of
                alt1 : alts1 ->
                case alts1 of
                alt2 : alts2 ->
                    if (isSwitch (alt_getExpr alt1) || isSwitch (alt_getExpr alt2)) then
                        expression
                    else if matchesBoolean True alt1 && matchesBoolean False alt2 then
                        (App (App (App (Var (QN "Cal.Core.Prelude" "if") [] Nothing Nothing) expr) alt1.Alt.expr) alt2.Alt.expr)
                    else if matchesBoolean True alt2 && matchesBoolean False alt1 then
                        (App (App (App (Var (QN "Cal.Core.Prelude" "if") [] Nothing Nothing) expr) alt2.Alt.expr) alt1.Alt.expr)
                    else
                        expression
                ;;
            else
                expression;
    _ -> expression;
    ;

/**
 * Check if the given alt matches the given value. This only works for Boolean values.
 * 
 * @arg expectedValue The value to look for
 * @arg alt The alt to check
 * @return True iff the given alt matches the given boolean value.
 */    
    
matchesBoolean :: Boolean -> Alt -> Boolean;
matchesBoolean !expectedValue !alt =    
    case alt of
    Alt {caseConst=caseConst} ->
        matchesCaseConst expectedValue caseConst;
    Alts {caseConst=caseConsts} ->
        orList (map (matchesCaseConst expectedValue) caseConsts);
    ;

matchesCaseConst :: Boolean -> CaseConst -> Boolean;
matchesCaseConst expectedValue !caseConst = 
    case caseConst of
    CaseLiteral literal ->
        case literal of
        LitBoolean value -> value == expectedValue;
        _ -> False;
        ;
    CaseDataCons dc ->
        case dc of
        DataCons {name} ->
            dataCons_matches dc expectedValue; 
        ;    
    ;
    
expressionMatchesBoolean :: Boolean -> Expression -> Boolean;
expressionMatchesBoolean expectedValue expression = 
    case expression of
    Literal {value=literal} ->
        case literal of
        LitBoolean value -> value == expectedValue;
        _ -> False;
        ;
    DataConstructor dc ->
        case dc of
        DataCons {name} ->
            dataCons_matches dc expectedValue; 
        ;    
    _ -> False;
    ;
/**
 * This transformation is tested be test 74. Removed redundant case checks. 
 */
 
transform_redundantCases :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_redundantCases state history !expression =
    case expression of
    Switch switchOuter switchOuterAlts ->
        let
            transformAlt :: Alt -> (Boolean, Alt);
            transformAlt alt = 
                case alt of
                Alt oCaseConst oIsPositional oVars oExpr ->
                    case oExpr of
                    Switch switchInner switchInnerAlts ->
                        if switchOuter == switchInner then
                            case switchInnerAlts of
                            ai:ais ->
                                case ais of
                                [] -> 
                                    case ai of
                                    Alt iCaseConst _ iVars iExpr ->
                                        if iCaseConst == oCaseConst && iVars == oVars then
                                            (True, Alt oCaseConst oIsPositional oVars iExpr)
                                        else
                                            (False, alt);
                                    ;
                                _ -> (False, alt);
                                ;
                        else
                            (False, alt);
                    _ -> (False, alt);
                    ;
                ;

            transformAlts :: [Alt] -> (Boolean, [Alt]);
            transformAlts alts = 
                case alts of
                [] -> (False, []);
                a:as ->
                    case transformAlts as of
                    (wasChanged1, as1) ->
                        case transformAlt a of
                        (wasChanged2, a1) ->
                            if wasChanged1 || wasChanged2 then
                                (True, a1:as1)
                            else
                                (False, alts);
                        ;
                    ;
                ;
        in
            case transformAlts switchOuterAlts of
            (wasChanged, switchOuterAltsPrime) ->
                if wasChanged then
                    (history, True, Switch switchOuter switchOuterAltsPrime)
                else
                    (history, False, expression);
            ;
    _ ->
        (history, False, expression);
    ;

/**
 * The `seq` and the seq type expression have a different form. This converts all of the expression so that
 * they have the same form, the seq form. 
 * 
 * These are the transformation that are performed : 
 * 
 *       1. NOT VALID ((f (seq (seq x y) x)) y) => ((seq x (seq y (f x))) y) iff f is a variable and of type lambda expression
 *       2. ((seq x y) z) => (seq x (y z))
 *       3. (seq (seq x y) z) => (seq x (seq y z))
 */

transform_canonizeSeq :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_canonizeSeq state history !expression =
    case flattenExpression expression [] of
    functor : args ->
        if isSeq functor then
            (
                case args of
                [] -> (history, False, expression);
                // ((seq x y) z) => (seq x (y z)) OR
                // (seq (seq x y) z) => (seq x (seq y z))
                x : y_z ->
                    case flattenExpression x [] of
                    x_functor : x_args ->
                        if isSeq x_functor then
                            // (seq (seq x y) z) => (seq x (seq y z))
                            if length x_args >= 2 then
                                case x_args of
                                x : x_y ->
                                    (history, True, unflattenExpression [prelude_seq_expr state, x, unflattenExpression (prelude_seq_expr state : append x_y y_z)]);
                            else
                                (history, False, expression)
                        else
                            // ((seq x y) z) => (seq x (y z))
                            if length y_z >= 2 then
                                (history, True, unflattenExpression [prelude_seq_expr state, x, unflattenExpression y_z])
                            else
                                (history, False, expression);
                    ;
            )
        else
            case args of
            [] -> (history, False, expression);
            a1 : args1 ->
                let
                    getSeqs :: [Expression];
                    getSeqs = flattenSeqs a1;
                in
                    if length getSeqs == 1 then
                        (history, False, expression)
                    else
                        // 1. ((f (seq (seq x y) x)) y) => ((seq x (seq y (f x))) y) iff f is a variable and of type lambda expression
                        if 
                            isVar functor && 
                            // if f is a variable and of type lambda expression
                            (
                                (
                                    (
                                        case expression_getType state history functor of
                                        Nothing -> False;
                                        Just type -> 
                                            type_isFunctionType type &&
                                            (not (orList (map (\argType -> type_isStrict argType) (flattenType type))));
                                    )
                                ) 
                                ||
                                // f is a primitive or foreign function
                                (
                                    isJust (find (\qn -> qn == functor.Var.name) state.TransformState.nonCalFunctions)
                                )
                            )
                        then
                            
//                          This case: ((addInt (seq (seq x y) x)) y) => ((seq x (seq y (addInt x))) y)
                            (history, True, buildSeq state getSeqs functor args1)
                        else
                            (history, False, expression);
        ;
    ;

flattenSeqs :: Expression -> [Expression];
protected flattenSeqs expr =
    let
        flattenSeqsHelper :: Expression -> [Expression] -> [Expression];
        flattenSeqsHelper expr acc =
            case getSeq expr of
            Nothing -> expr:acc;
            Just arg1_arg2 ->
                case arg1_arg2 of
                (arg1, arg2) -> flattenSeqsHelper arg1 (arg2:acc);
                ;
            ;
    in                        
        flattenSeqsHelper expr [];

/**
 * Take the given list of seq'ed expression and the given inner expression and build an expression of 
 * the form (seq e1 (seq e2 (... )))
 */

buildSeq :: TransformState -> [Expression] -> Expression -> [Expression] -> Expression;
protected buildSeq state seqedExprs functor args = 
    case seqedExprs of
    se1 : ses1 ->
        case ses1 of
        [] -> unflattenExpression (functor : se1 : args);
        se2 : ses2 ->
            (App (App (prelude_seq_expr state) se1) (buildSeq state ses1 functor args));
        ;        
    ;

/**
 * For patterns that do not have all the variables defined. Complete the patterns with dummy variables.
 * This makes pattern matching easier. For example
 * 
 * data d1 x y x
 * 
 * case value of
 * d1 {x} -> ...
 * 
 * becomes
 * 
 * case value of
 * d1 {x, y=dummy1, z=dummy2} ->
 * 
 */
transform_defineAllAltVariables :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected transform_defineAllAltVariables state history expression =
    case expression of
    Switch expr alts ->
        let
            updateAlts :: TransformHistory -> [Alt] -> Boolean -> [Alt] -> (TransformHistory, Boolean, [Alt]);
            updateAlts history !alts !wasChanged acc =
                case alts of
                [] -> (history, wasChanged, reverse acc);
                a:as ->
                    case defineAllAltVariables state history a of
                    (history2, wasChanged2, a2) ->
                        updateAlts history2 as (wasChanged || wasChanged2) (a2:acc);
                    ;
                ;
        in
            case updateAlts history alts False [] of
            (history2, wasChanged2, alts2) -> 
                 if wasChanged2 then
                     (history2, True, Switch expr alts2)
                 else
                     (history, False, expression);
        ;
    _ -> (history, False, expression);
    ;

/**
 * Updates the cached type of the let expression with a calculated type.
 */
 
adjustTypeForLetExpression :: TransformState -> TransformHistory -> Expression -> (TransformHistory, Boolean, Expression);
protected adjustTypeForLetExpression state history expression =
    case expression of
    Let variable isNew isKeepable isTopLevel type expr body isRecursive arity isCoreFunction constArgs bodyWasChangedAt inliningWasPerformed ->
        case expression_getType state history expr of
        Nothing -> (history, False, expression);
        Just calculatedType -> 
        	(
        		history, 
        		True, 
        		Let variable isNew isKeepable isTopLevel 
        			(
        			case type of
        			Nothing -> Just (flattenType calculatedType);
        			Just extantTypes ->
	        			(Just 
		        			(
	    	    				zipWith 
	        						(\calcType extantType -> type_applyStrictness calcType (type_isStrict extantType)) 
	        						(flattenType calculatedType)
	        						extantTypes
	        				)
    	    		    );
        		    )
        			expr body isRecursive arity isCoreFunction constArgs bodyWasChangedAt inliningWasPerformed);  
        ;
    _ -> (history, False, expression);
    ;

/**
 * For any positional pattern make sure that all of the variables are defined. This is to 
 * make pattern matching more successful in the transformation stage.
 */

defineAllAltVariables :: TransformState -> TransformHistory -> Alt -> (TransformHistory, Boolean, Alt);
defineAllAltVariables state history alt =
    case alt of
    Alt caseConst isPositional vars expr ->
        case caseConst of
        CaseDataCons dc ->
            if isPositional then
                let
                    arity :: Int;
                    arity = dataCons_getArity dc;
                    
                    helper :: TransformHistory -> Int -> [(FieldName, QualifiedName, Type)] -> Boolean -> [(FieldName, QualifiedName, Type)] -> (TransformHistory, Boolean, [(FieldName, QualifiedName, Type)]); 
                    helper history !argNo vars wasChanged acc = 
                        if argNo > arity then
                            (history, wasChanged, reverse acc)
                        else
                            case find (\fnqn -> fnqn.#1.FNOrdinal.ordinal == argNo) vars of
                            Nothing ->
                                case newVar state history (QN state.TransformState.name.QN.moduleName "generatePattern") "DAV" of
                                (history2, newVar) ->
                                    helper history2 (argNo+1) vars True (((FNOrdinal argNo, newVar, TypeVar optimizerHelper_newTypeVar False)):acc);
                                ;
                            Just fnqn ->
                                helper history (argNo+1) vars wasChanged (fnqn:acc);
                        ;
                in
                    case helper history 1 vars False [] of
                    (history2, wasChanged2, vars2) ->
                        (history2, wasChanged2, Alt caseConst isPositional vars2 expr);
            else
                (history, False, alt);
        _ -> (history, False, alt);
        ;
    ;

/**
 * Remove unused variables from Alt patterns.
 */

transform_removeUnusedAltVariables :: Expression -> Expression;
protected transform_removeUnusedAltVariables expression =
    case expression of
    Switch expr alts ->
        let
            updateAlts :: [Alt] -> [Alt] -> [Alt];
            updateAlts !alts acc =
                case alts of
                [] -> reverse acc;
                a:as -> updateAlts as ((removeUnusedAltVariables a):acc);
                ;
        in
            Switch expr (updateAlts alts []);
        
    _ -> expression;
    ;
            

/**
 * Remove any unused alt pattern variables.
 */

removeUnusedAltVariables :: Alt -> Alt;
removeUnusedAltVariables alt =
    case alt of
    Alt caseConst isPositional vars expr ->
        case caseConst of
        CaseDataCons dc ->
            if isPositional then
                let
                    isUsed :: (FieldName, QualifiedName, Type) -> Boolean;
                    isUsed fnqn =
                        case fnqn of
                        (fn, qn, type) -> containsFree qn expr;
                        ;
                in
                    Alt caseConst isPositional (filter isUsed vars) expr
            else
                alt;
        _ -> alt;
        ;
    ;

/**
 * First pass at converting an expression to a type. This can be used to unify all the types and
 * transfer type information across expressions.
 */
    
unitTests :: JPreludeTypeConstants -> Boolean;
protected unitTests typeConstants = 
    assert (transform_3_1Examples typeConstants) 
 && assert (transform_3_2_1Examples typeConstants) 
 && assert (transform_3_2_2Examples typeConstants);
