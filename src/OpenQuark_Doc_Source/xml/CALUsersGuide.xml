<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
 
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
 
    * Neither the name of Business Objects nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.
 
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-->
<!--
    CALUsersGuide.xml
    Creation date: Jun 11, 2007.
    By: Edward Lam
-->
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY euro "&#8364;">
<!ENTITY % dbcent PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/dbcentx.mod">
%dbcent;

<!ENTITY legal SYSTEM "LegalNotice.xml">
]>
<book version="5.0" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <title>CAL User's Guide</title>

  <info>
    <releaseinfo>Last modified: August 13, 2007</releaseinfo>

    <authorgroup>
      <author>
        <personname>Magnus Byne</personname>
      </author>

      <author>
        <personname>Bo Ilic</personname>
      </author>

      <author>
        <personname>Edward Lam</personname>
      </author>

      <author>
        <personname>Joseph Wong</personname>
      </author>

      <author>
        <personname>James Wright</personname>
      </author>
    </authorgroup>

    &legal;
  </info>

  <chapter xml:id="Overview">
    <title>Overview</title>

    <para>This is intended to be the primary document describing the use of the CAL language. It
    contains both introductory material and reference material.</para>

    <para>CAL is a lazy functional language influenced by Haskell. It has an expression-based syntax
    akin to other formula languages (such as those found in Excel and Crystal Reports). It also
    features a powerful and flexible type system which allows the compiler to perform precise
    compile-time checking of function calls. In addition, it has a simple syntax for accessing Java
    objects, methods, and fields from within CAL.</para>

    <para>Lazy evaluation means that the values of expressions are computed only when they are
    required by other expressions. This increases efficiency, as unnecessary calculations are
    avoided. It also allows for the definition of infinite data structures (such as the list of all
    even integers, for example), since only those parts of the data structure that are used will be
    computed. This makes it practical to divide a program into a generator that constructs many
    possible answers and a selector which chooses the appropriate ones.</para>

    <section>
      <title>Document layout</title>

      <para>The User's Guide is divided into four main sections: Getting Started with CAL, the
      Language Reference, the Standard Library Reference, and the Appendices. Getting Started with
      CAL provides a brief introduction to new users of CAL. The Language Reference documents the
      features of the CAL language. The Standard Library Reference documents CAL's standard library
      modules (which corresponds fairly closely to the standard library of most object-oriented
      languages).</para>

      <para>Finally, the Appendices section provides supplementary reference information: some
      suggested further reading and a reference list of CAL keywords.</para>
    </section>

    <section>
      <title>Call for feedback</title>

      <para>This document aims to be as complete and easy-to-use as possible. Any feedback you might
      have to help improve it would be very welcome. Please send any comments, suggestions, or
      questions to the CAL Language Discussion forum on Google Groups <link
      xlink:href="http://groups.google.com/group/cal_language"></link>.</para>
    </section>
  </chapter>

  <chapter>
    <title>Getting Started with CAL</title>

    <para>This section aims to give an introduction to the basic features of CAL. You are encouraged
    to follow the examples as you progress through the section. Some concepts may be used before
    they are introduced.</para>

    <section>
      <title>The ICE environment</title>

      <para>ICE is the Interactive CAL Environment. It is a program that allows you to load CAL
      modules, and then type in expressions to be evaluated in the context of those modules. You may
      find it helpful to load the example definitions into ICE and evaluate some expressions against
      them.</para>

      <section>
        <title>Running ICE</title>

        <para>To launch ICE, simply run the included ICE.bat batch file on Windows, or the ICE.sh
        shell script on UNIX/Linux platforms.</para>
      </section>

      <section>
        <title>Using ICE to run the example code</title>

        <para>It is only possible to enter expressions at the ICE prompt. Function definitions, type
        declarations, and other declarations must appear in modules. The best way to enter these
        declarations is to create your own module file. The declarations can be typed into the
        module file, which is then reloaded into the ICE environment.</para>

        <para>Here are the steps that could be used in an ICE session to try some example
        code:<orderedlist>
            <listitem>
              <para>Use a text editor to create a file <filename>UserGuideExamples.cal</filename> in
              the "<filename>samples/simple/CAL</filename>" folder of your Quark
              distribution.</para>
            </listitem>

            <listitem>
              <para>Use the text editor to paste the following code into the new
              file:<programlisting>module UserGuideExamples;
import Cal.Core.Prelude using
    typeConstructor = Int, Double, String, Boolean, Char, 
                      Integer, JObject, JList, Maybe, Ordering;
    dataConstructor = False, True, LT, EQ, GT, Nothing, Just;
    typeClass = Enum, Eq, Ord, Num, Inputable, Outputable;
    function = 
        add, append, compare,
        concat, const, doubleToString, equals, 
        error, fromJust, fst, input, intToString, isNothing, 
        isEmpty, max, mod, not, output, round, seq, snd, 
        toDouble, field1, field2, field3, upFrom, upFromTo;
    ;
import Cal.Collections.List using
    function = 
        all, chop, filter, foldLeft, foldLeftStrict, foldRight, 
        head, intersperse, last, list2, map, product, reverse,
        subscript, sum, tail, take, zip, zip3, zipWith;
    ;
import Cal.Collections.Array;
import Cal.Core.Bits;
import Cal.Core.Debug;
import Cal.Core.Dynamic using
    typeConstructor = Dynamic;
    function = fromDynamic, fromDynamicWithDefault, toDynamic;
    ;
import Cal.Utilities.Math using
    function = truncate;
    ;
import Cal.Utilities.StringNoCase;
import Cal.Core.String;</programlisting></para>
            </listitem>

            <listitem>
              <para>Save <filename>UserGuideExamples.cal</filename></para>
            </listitem>

            <listitem>
              <para>Use a text editor to add the following line to the end of the
              "<filename>samples/simple/Workspace Declaration/cal.samples.cws</filename>"
              file:<literallayout>StandardVault UserGuideExamples</literallayout></para>
            </listitem>

            <listitem>
              <para>Run <filename>ICE.bat</filename> (or <filename>ICE.sh</filename>).</para>
            </listitem>

            <listitem>
              <para>Set the current module to be <filename>UserGuideExamples</filename> by entering
              the following at the ICE prompt:<userinput>:sm UserGuideExamples</userinput></para>
            </listitem>

            <listitem>
              <para>In a text editor, add some function definitions to the end of
              <filename>UserGuideExamples.cal</filename> and save the file. For
              example:<programlisting>myFactorial :: Integer -&gt; Integer;
myFactorial n =
    product (upFromTo 1 n);</programlisting></para>
            </listitem>

            <listitem>
              <para>Use the <command>:rc</command> command from the ICE prompt to recompile and load
              all changed module files: <literallayout><userinput>:rc</userinput></literallayout></para>
            </listitem>

            <listitem>
              <para>Enter some expressions at the ICE prompt for evaluation:<literallayout><userinput>myFactorial 5</userinput></literallayout></para>
            </listitem>
          </orderedlist></para>

        <para>The edit-recompile-evaluate cycle can be repeated any number of times.</para>
      </section>
    </section>

    <section>
      <title>Values and types</title>

      <para>In CAL, all computations are done by evaluating expressions. An expression is an
      operation either on values, or upon other expressions. The most familiar type of expression is
      the arithmetic expression:<literallayout><userinput>1.2 + 5.0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>6.2</computeroutput></literallayout></para>

      <para>The example expression above consists of the addition operation (<function
      role="operator">+</function>) applied to two subexpressions. The subexpressions are the value
      <literal>1.2</literal> and the value <literal>5.0</literal>. The expression evaluates to the
      Double value <literal>6.2</literal>.</para>

      <para>Every valid CAL expression evaluates to a value. This document gives the value of
      example expressions after the word <emphasis>returns</emphasis> in bold italics (as in the
      above example, which has the value <constant>6.2</constant>). The text after and including
      <emphasis>returns</emphasis> is not part of the expression itself.</para>

      <para>Every value in CAL has a type. Intuitively, a type is a set of all the values that are a
      part of that type. Types can have sizes ranging from a single value (e.g. the <type>()</type>
      type), to an infinite number of values (e.g. the <type>Integer</type> type).</para>

      <para>Try typing a few arithmetic expressions into ICE's command line. Ex:<informalexample>
          <literallayout><userinput>5.0 * 10.0 / 2.5</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>20.0</computeroutput></literallayout>
        </informalexample><informalexample>
          <para><informalexample>
              <literallayout><userinput>"One string " ++ "Another string"</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"One string Another string"</computeroutput></literallayout>
            </informalexample></para>
        </informalexample></para>

      <section>
        <title>Type inference</title>

        <para>The CAL compiler uses a process known as type inference to determine the type of each
        expression that it evaluates. Type inference determines the type of the expression's result
        based upon the types of the operations and values that make up the expression.</para>

        <informalexample>
          <literallayout>1.2 + 5.0
<emphasis role="bold-italic">returns</emphasis> <computeroutput>6.2</computeroutput></literallayout>
        </informalexample>

        <para>To return to our simple arithmetic example, both <literal>1.2</literal> and
        <literal>5.0</literal> are of type <type>Double</type> (i.e., double-precision floating
        point), and <function role="operator">+</function> is an operation of type <type>Num a =&gt;
        a -&gt; a -&gt; a</type> (i.e., a function that takes two arguments of some numeric type
        <type>a</type>, and returns a result of the same numeric type). Based upon this information,
        the inferencer is able to determine that the type of the result must be Double. We see from
        the actual result (<computeroutput>6.2</computeroutput>) that this is indeed the
        case.</para>

        <para>ICE provides a command (<command>:t</command>) that allows you to inspect the type
        that the compiler has inferred for a given expression:<informalexample>
            <literallayout><userinput>:t "One string " ++ " another"</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>String</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t 1.2 + 5.0</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>Double</computeroutput>
</literallayout>
          </informalexample></para>

        <para>We give the result as an <emphasis>outputs</emphasis> rather than as a
        <emphasis>returned</emphasis> value, because the above are commands to the ICE environment,
        not expressions.</para>

        <para>CAL is a strongly-typed language. This means that the compiler checks each expression
        to ensure that it has a consistent type. If the inferencer cannot determine a consistent
        type for an application, compilation will fail with an error:<informalexample>
            <literallayout><userinput>1.2 + "hello"</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type error applying the operator "+" to its second argument. 
Caused by: Type clash: type constructor Prelude.Double does not match 
Prelude.String
</computeroutput></literallayout>
          </informalexample></para>

        <para>In this example, we are attempting to apply an operator (<function
        role="operator">+</function>) that takes two arguments that must be of the same type to two
        arguments of different types (<type>Double</type> and <type>String</type>). Since the types
        of the arguments cannot be resolved with the type of the operator (more about this below),
        the type inferencer cannot determine a consistent type for the expression, and compilation
        fails.</para>

        <para>The requirement that the type inferencer be able to unambiguously determine the type
        of an expression can sometimes cause unexpected behaviour:<informalexample>
            <literallayout><userinput>5 * 8</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Ambiguous type signature in inferred type (Prelude.Num a, 
Prelude.Outputable a) =&gt; a
</computeroutput></literallayout>
          </informalexample></para>

        <para>This error message occurs because the type inferencer is not able to determine the
        exact type of <literal>5</literal> or <literal>8</literal>, and therefore the type of the
        whole expression. The best it can determine is that <literal>5</literal> and
        <literal>8</literal> are both members of some numeric type. However, <literal>5</literal>
        and <literal>8</literal> could each represent a value of several numeric types (including
        <type>Int</type>, <type>Integer</type>, and <type>Double</type>); there is no way to tell
        from the given form of the expression what specific type was intended:<informalexample>
            <literallayout><userinput>:t 5 * 8</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>Num a =&gt; a</computeroutput>
</literallayout>
          </informalexample></para>

        <para>There are a number of ways to deal with this behaviour. One is to declare the type of
        the entire expression; if the type inferencer is able to make type assignments that are
        consistent with this declaration, then the expression will compile.</para>

        <para>The <function role="operator">::</function> operator is used to declare the type of
        expressions:<informalexample>
            <literallayout><userinput>5 * 8 :: Integer</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>40</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>5 * 8 :: Double</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>40.0</computeroutput>
</literallayout>
          </informalexample></para>

        <para>Another approach is to declare the type of one or both of the
        subexpressions:<informalexample>
            <literallayout><userinput>(5 :: Integer) * 8</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>40</computeroutput>
</literallayout>
          </informalexample></para>

        <para>Since the first argument is an <type>Integer</type>, and the <function
        role="operator">*</function> operator accepts two arguments of the same type, the inferencer
        can determine that the other argument must also be an <type>Integer</type>, with the result
        being an <type>Integer</type> as well:<informalexample>
            <literallayout><userinput>:t (5 :: Integer) * 8</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>Integer</computeroutput>
</literallayout>
          </informalexample></para>
      </section>

      <section>
        <title>Lists</title>

        <para>In addition to the simple types, CAL also includes several built-in types for
        combining values of the simple types. The two most important of these additional types are
        lists and tuples.</para>

        <para>A list is an ordered collection of zero or more values of the same type. In CAL, lists
        are written surrounded by square brackets, with the elements separated by
        commas:<informalexample>
            <literallayout><userinput>["list", "of", "strings"]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>["list", "of", "strings"]</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>["invalid", 'L', 10]</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type error. All elements of a list must have compatible types. 
Caused by: Type clash: type constructor Prelude.String does not match 
Prelude.Char
</computeroutput></literallayout>
          </informalexample></para>

        <para>List values can be constructed by adding elements to the front using the Cons operator
        (<function role="operator">:</function>). The Cons operator takes two arguments: An element
        to prepend to a list, and the list to prepend to, and returns a new list consisting of the
        element prepended to the provided list:</para>

        <informalexample>
          <literallayout><userinput>"a" : ["list", "of", "strings"]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>["a", "list", "of", "strings"]</computeroutput>
</literallayout>
        </informalexample>

        <informalexample>
          <literallayout><userinput>5.0 : [4.0]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[5.0, 4.0]</computeroutput>
</literallayout>
        </informalexample>

        <para>List values can be combined using the append operator (<function
        role="operator">++</function>). The append operator takes two list arguments and returns a
        list consisting of the elements of the first list followed by the elements of the second
        list:<informalexample>
            <literallayout><userinput>[1.0, 2.0, 3.0] ++ [0.4, 0.9]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[1.0, 2.0, 3.0, 0.4, 0.9]</computeroutput>
</literallayout>
          </informalexample></para>

        <para>It is possible for a list to have zero elements. The "empty list" is a valid list; it
        is represented by empty square brackets:<informalexample>
            <literallayout><userinput>10.5 : []</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[10.5]</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>['a', 'b', 'c'] ++ []</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>['a', 'b', 'c']</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>[] ++ ["val1", "val2"]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>["val1", "val2"]</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>[]</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Ambiguous type signature in inferred type 
Prelude.Outputable a =&gt; a
</computeroutput></literallayout>
          </informalexample></para>

        <para>Note that the empty list produces an error when entered by itself. That is because the
        type inferencer cannot determine from the expression alone whether it refers to a list of
        Strings, a list of Double values, or a list of some other type. As with ambiguous numeric
        types, an explicit type declaration can remove the ambiguity:<informalexample>
            <literallayout><userinput>[] :: [Char]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[]</computeroutput>
</literallayout>
          </informalexample></para>

        <para>The type of a list is represented by the type of its elements enclosed within square
        brackets:<informalexample>
            <literallayout><userinput>:t ["Jack", "Tom"]</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[String]</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t ["Simone", "Sally", "Sarah"]</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[String]</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t [3.0, 1.0, 1.0, 2.0]</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[Double]</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t [[1.1, 1.2], [0.0, 0.3], [], [-3.0]]</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[[Double]]</computeroutput>
</literallayout>
          </informalexample></para>

        <para>The first two examples are both lists of <type>String</type>s. Notice that the two
        lists have the same type even though they have differing numbers of elements.</para>

        <para>The third example is a list of <type>Double</type>s. The final example is a list of
        lists of <type>Double</type>s. Notice that it is possible for a list's elements to be lists
        themselves. Note also that a list of lists of <type>Double</type>s has a different type from
        a list of <type>Double</type>s, since their elements are of differing types.</para>

        <para>In other words, you cannot mix lists of <type>Double</type>s with <type>Double</type>s
        in the same list:<informalexample>
            <literallayout><userinput>[1.0, [1.2], 1.1]</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type error. All elements of a list must have compatible types. 
Caused by: Type clash: type constructor Prelude.Double does not match 
Prelude.List
</computeroutput></literallayout>
          </informalexample></para>
      </section>

      <section>
        <title>Tuples</title>

        <para>Tuples are ordered collections of fixed numbers of values. The most familiar kind of
        tuple is the 2-tuple, or pair. Pairs or triples (3-tuples) are often used to model geometric
        locations:<informalexample>
            <para><code>(0.0, 0.0)</code></para>
          </informalexample><informalexample>
            <para><code>(-13.9, 50.0, 12.5)</code></para>
          </informalexample></para>

        <para>Although the above examples are pairs and triples whose components are all of the same
        type (<type>Double</type>), it is also valid for tuple components to be of different
        types:<informalexample>
            <para><code>("James", 27.0)</code></para>
          </informalexample><informalexample>
            <para><code>('A', "Bob")</code></para>
          </informalexample></para>

        <para>The type of a tuple is written as the types of each component within
        parentheses:<informalexample>
            <literallayout><userinput>:t ("James", 27.0)</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(String, Double)</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout>:t (61.0, "Bob")
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Double, String)</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t </userinput>(0.0, 0.0)
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Double, Double)</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t (-13.9, 50.0, 12.5)</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Double, Double, Double)</computeroutput>
</literallayout>
          </informalexample></para>

        <para>Note that the first tuple (consisting of a <type>String</type> followed by a
        <type>Double</type>) has a different type than the second tuple (consisting of a
        <type>Double</type> followed by a <type>String</type>). Note also that the third example
        (pair of <type>Doubles</type>) has a different type than the fourth example (triple of
        <type>Doubles</type>). This is because, unlike lists, every member of a given tuple type
        must have the same number of components.</para>

        <para>Tuple components needn't be of simple types; they can be of any type, including other
        tuple types:<informalexample>
            <literallayout><userinput>:t ("Origin", (0.0, 0.0))</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(String, (Double, Double))</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t (['a', 'b', 'c], 3.0)</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>([Char], Double)</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t ([('a', 1.0), ('b', 2.0), ('c', 3.0)], True)</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>([(Char, Double)], Boolean)</computeroutput>
</literallayout>
          </informalexample></para>
      </section>

      <section>
        <title>Case expressions, part 1</title>

        <para>In addition to utility functions such as <function>fst</function>,
        <function>snd</function>, <function>head</function>, <function>tail</function>, and so forth
        that CAL provides for accessing the components of lists and tuples, CAL also provides a
        construct known as the case expression. Case expressions allow you to bind the components of
        lists and tuples to variable names to make accessing them more convenient:<footnote>
            <para>This is not all that case expressions are used for. See <xref
            linkend="CaseExpressionsPart2" />.</para>
          </footnote><programlisting>isOrigin :: Num a =&gt; (a, a, a) -&gt; Boolean;
public isOrigin point =
    case point of
    (x, y, z) -&gt; x==0 &amp;&amp; y==0 &amp;&amp; z==0;
    ;</programlisting></para>

        <para>In the above example, the case expression matches the <parameter>point</parameter>
        value. Each case expression contains one or more alternatives. An alternative is a pattern
        (for example, <code>(x, y, z)</code>) followed by a right-arrow (<function
        role="operator">-&gt;</function>) followed by an expression. The alternative whose pattern
        matches the case expression's argument is chosen, and the alternative's expression is
        evaluated as the value of the case expression.</para>

        <para>The pattern <code>(x, y, z)</code> matches any 3-tuple. It binds the identifiers
        <varname>x</varname>, <varname>y</varname>, and <varname>z</varname> to the values of the
        first, second, and third components of the 3-tuple for the scope of the alternative's
        expression.</para>

        <para>Similar patterns can be used for tuples of any number of dimensions. Elements that you
        don't wish to bind to an identifier can be filled in with an underscore
        (<literal>_</literal>):<informalexample>
            <programlisting>myFst :: (a,b) -&gt; a;
public myFst pair =
    case pair of 
    (ret, _) -&gt; ret;
    ;    
mySnd :: (a,b) -&gt; b;
public mySnd pair =
    case pair of 
    (_, ret) -&gt; ret;
    ;</programlisting>
          </informalexample></para>

        <para>Case expressions can also be used to match against list arguments:<informalexample>
            <programlisting>any :: (a -&gt; Boolean) -&gt; [a] -&gt; Boolean;
public any p list =
    case list of
    [] -&gt; False;
    listHead : listTail -&gt; p listHead || any p listTail;
    ;</programlisting>
          </informalexample></para>

        <para>The pattern <code>[]</code> matches the empty list. The pattern <code>listHead :
        listTail</code> matches any non-empty list. In the above example, the first element of the
        list is bound to <varname>listHead</varname>, and the rest of the list is bound to
        <varname>listTail</varname> in the second alternative.</para>
      </section>
    </section>

    <section>
      <title>Functions</title>

      <para>A function is an operation that takes some number of values (possibly zero), and returns
      another, possibly different value. For example, the <function>max</function> function takes
      two arguments and returns the largest of the two:<informalexample>
          <literallayout><userinput>max 1.5 0.3</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>1.5</computeroutput>
</literallayout>
        </informalexample></para>

      <para>Note that function applications are a kind of expression. They must always produce a
      value, and their types must be consistent.</para>

      <para>The <function>id</function> function takes a single value and returns an identical
      value:</para>

      <informalexample>
        <literallayout><userinput>id "ahoy"</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"ahoy"</computeroutput>
</literallayout>
      </informalexample>

      <para>The <function>head</function> functions takes a single list value and returns the first
      element of the list:</para>

      <informalexample>
        <literallayout><userinput>head ["top", "middle", "bottom"]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"top"</computeroutput>
</literallayout>
      </informalexample>

      <para>The <function>pi</function> function takes no arguments and returns a Double value that
      approximates the value of pi:</para>

      <informalexample>
        <literallayout><userinput>pi</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>3.141592653589793</computeroutput>
</literallayout>
      </informalexample>

      <para>The <function>isEven</function> function takes an <type>Int</type> argument and returns
      a <type>Boolean</type> indicating whether it is even (<function>True</function>) or odd
      (<function>False</function>):</para>

      <informalexample>
        <literallayout><userinput>isEven 9</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput>
</literallayout>
      </informalexample>

      <informalexample>
        <literallayout><userinput>isEven 10</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput>
</literallayout>
      </informalexample>

      <para>The <function>power</function> function takes two <type>Double</type> arguments and
      raises the first argument to an exponent specified by the second argument, returning another
      <type>Double</type>:</para>

      <informalexample>
        <literallayout><userinput>power 2 0.5</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>1.4142135623730951</computeroutput>
</literallayout>
      </informalexample>

      <para>The arguments to a function need not all be of the same type. For example, the
      <function>subscript</function> function in the <classname>String</classname> module accepts a
      <type>String</type> and an <type>Int</type> specifying an index into the <type>String</type>,
      and returns the <type>Char</type> at the specified index:</para>

      <informalexample>
        <literallayout><userinput>String.subscript "a modern Major-General" 9</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>'M'</computeroutput>
</literallayout>
      </informalexample>

      <para>In CAL, functions themselves are values. Like all other values, they have a type:</para>

      <informalexample>
        <literallayout><userinput>:t pi</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>Double</computeroutput>
</literallayout>
      </informalexample>

      <informalexample>
        <literallayout><userinput>:t isEven</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>Int -&gt; Boolean</computeroutput>
</literallayout>
      </informalexample>

      <informalexample>
        <literallayout><userinput>:t power</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>Double -&gt; Double -&gt; Double</computeroutput>
</literallayout>
      </informalexample>

      <informalexample>
        <literallayout><userinput>:t String.subscript</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>String -&gt; Int -&gt; Char</computeroutput>
</literallayout>
      </informalexample>

      <informalexample>
        <literallayout><userinput>:t id</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>a -&gt; a</computeroutput>
</literallayout>
      </informalexample>

      <informalexample>
        <literallayout><userinput>:t head</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[a] -&gt; a</computeroutput>
</literallayout>
      </informalexample>

      <para>The first type signature is familiar; <function>pi</function> returns a value of type
      <type>Double</type>.</para>

      <para>The second type signature contains a new element: It includes an arrow (<function
      role="operator">-&gt;</function>). The arrow indicates a function with arguments. The type
      signature <type>Int -&gt; Boolean</type> specifies the type of a function that accepts a
      single <type>Int</type> argument and returns a <type>Boolean</type> value.</para>

      <para>The type of functions that return multiple values are specified by listing the types of
      the arguments in order and separated by arrows, followed by another arrow and the type of the
      return value. So the type signature of <function>power</function> (<type>Double -&gt; Double
      -&gt; Double</type>) represents the type of a function that accepts two <type>Double</type>
      arguments and returns another <type>Double</type> value, and the type signature of
      <function>String.subscript</function> (<type>String -&gt; Int -&gt; Char</type>) represents
      the type of a function that accepts a <type>String</type> and an <type>Int</type> and returns
      a <type>Char</type>.</para>

      <para>The fifth signature (for the <function>id</function> function) has another new element:
      it refers to an unfamiliar type <type>a</type>.</para>

      <para>The type signature <type>a -&gt; a</type> specifies the type of a function that accepts
      a value of type <type>a</type> and returns another value of the same type <type>a</type>, for
      some type <type>a</type>. The identifier <varname>a</varname> is a <firstterm>type
      variable</firstterm>; it can be bound to any type. Note that it can only be bound to a single
      type within a given type signature.</para>

      <para>What this means is that we can pass an argument of any type at all to
      <function>id</function>, and it will return a value of the same type.</para>

      <para>Similarly, the final type signature (for the <function>head</function> function)
      specifies a function that accepts a list of <type>a</type> (for some type <type>a</type>), and
      returns a value of the same type <type>a</type>.</para>

      <para>It is possible to use multiple type variables in a single type signature. For example,
      the <function>fst</function> function accepts a 2-tuple, whose components can each be of any
      type, and returns the value of the first component. Similarly, the <function>snd</function>
      function accepts a 2-tuple with components of any type, and returns the second
      component:</para>

      <informalexample>
        <literallayout><userinput>fst ("foo", 2.0)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"foo"</computeroutput>
</literallayout>
      </informalexample>

      <informalexample>
        <literallayout><userinput>snd ("foo", 2.0)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>2.0</computeroutput>
</literallayout>
      </informalexample>

      <informalexample>
        <literallayout><userinput>:t fst</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(a, b) -&gt; a</computeroutput>
</literallayout>
      </informalexample>

      <informalexample>
        <literallayout><userinput>:t snd</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(a, b) -&gt; b</computeroutput>
</literallayout>
      </informalexample>

      <para>Note that the type signature for <code>fst ((a, b) -&gt; a)</code> contains two type
      variables. The first component of the argument can be of any type; the second component can
      also be of any type, and needn't be the same type as the first. But whatever the type of the
      first component is, the return value must be of the same type, because the first component and
      the return type have the same type variable (<varname>a</varname>).</para>

      <para>Type variables are distinguished from specific type names by their case. Type variables
      always begin with a lower-case letter, whereas type names always begin with an upper-case
      letter. It is customary to choose type variable names starting with <varname>a</varname> and
      moving up the alphabet (<varname>b</varname>, <varname>c</varname>, etc.) as new names are
      required.</para>

      <section>
        <title>Type class constraints</title>

        <para>Often, we don't want to restrict a value to a single type, but we don't want to allow
        it to be of just any type either. We want to restrict it to be a member of some group of
        types, such as the numeric types, or the types for which it is possible to compare for
        equality. For these situations, CAL provides a mechanism known as <firstterm>type
        classes</firstterm>.</para>

        <para>A type class is a group of types that all implement some common set of operations
        (known as <firstterm>methods</firstterm>). There is generally an implicit semantic
        "contract" about the meaning of these operations. For example, in the
        <classname>Eq</classname> class, it is understood that if <code>equals x y</code> is
        <code>True</code>, then <code>notEquals x y</code> should be <code>False</code>, and vice
        versa, for all <varname>x</varname> and <varname>y</varname>.</para>

        <para>We can specify that a type variable must belong to a given type class (or group of
        type classes). We do this by adding a type class constraint to a type signature. A type
        class constraint is represented by a type class name followed by the variable to which it
        applies, followed by a double arrow (<function role="operator">=&gt;</function>), followed
        by the type signature that is being constrained:<informalexample>
            <literallayout><userinput>:t max</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>Ord a =&gt; a -&gt; a -&gt; a</computeroutput>
</literallayout>
          </informalexample></para>

        <para>The <function>max</function> function has a type that includes a type class
        constraint. Its type may be read as "a function that accepts two arguments of type a and
        returns a value of type <type>a</type>, for some type <type>a</type> that is a member of the
        <classname>Ord</classname> class".</para>
      </section>

      <section>
        <title>Higher-order functions</title>

        <para>We mentioned above that functions are themselves values. This means that it is
        possible for a function to accept another function as an argument, and/or to return
        functions. A function which operates upon other functions is called a higher-order function.
        Higher-order functions are a central technique of functional programming.</para>

        <para>CAL provides a number of built-in higher-order functions in the standard library
        modules. Many, although not all, of these functions abstract various kinds of iterations
        over lists, arrays and other container types.</para>

        <para>The <function>map</function> function accepts two arguments: A function that accepts a
        single argument, and a list of elements of the type that the function accepts.
        <function>map</function> returns a list of the results of applying the function argument to
        each element of the list argument:<informalexample>
            <literallayout><userinput>:t map</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(a -&gt; b) -&gt; [a] -&gt; [b]</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>map isEven [9, 8, 7, 6]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[False, True, False, True]</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>map head [['H', 'T'], ['1', '2'], ['a', 'b', 'c']]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>['H', '1', 'a']</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>map fst [("Q1",True), ("Q2",False), ("Q3",False), ("Q4", True)]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>["Q1", "Q2", "Q3", "Q4"]</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>map fst [['H', 'T'], ['1', '2'], ['a', 'b', 'c']]</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type Error during an application. Caused by: Type clash: 
type constructor Prelude.Tuple2 does not match Prelude.List.</computeroutput>
</literallayout>
          </informalexample></para>

        <para>The last call fails because the fst function accepts a tuple argument, but the list
        passed to <function>map</function> is a list of lists, not tuples.</para>

        <para>The filter function accepts two arguments: a function that accepts a single argument
        and returns a <type>Boolean</type> value, and a list of elements of a type that the function
        accepts. It returns a list of each element for which the function argument returns
        <function>True</function>:</para>

        <para>The final call fails, because <function>head</function> of a list of
        <type>Char</type>s returns a <type>Char</type> value, not a <type>Boolean</type>
        value.</para>

        <para>The <function>compose</function> function accepts two single-argument functions and
        returns a new function equivalent to applying the first function to the result of the second
        function. The first function must accept as its argument values of the same type as the
        second function returns.<informalexample>
            <literallayout><userinput>fst (1::Int, 'E')</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>1</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>isEven 1</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>isEven (fst (1::Int, 'E'))</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>(compose isEven fst) (1::Int, 'E')</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>(compose fst isEven) (1::Int, 'E')</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type Error during an application. Caused by: Type clash: 
type constructor Prelude.Boolean does not match a record type.</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t fst</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(a, b) -&gt; a</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t isEven</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>Int -&gt; Boolean</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t (compose isEven fst)</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Int, a) -&gt; Boolean</computeroutput>
</literallayout>
          </informalexample></para>

        <para>The attempt to call <code>(compose fst isEven)</code> fails, (even though the call to
        <code>(compose isEven fst)</code> succeeds) because <function>isEven</function> returns a
        <type>Boolean</type>, whereas <function>fst</function> accepts a 2-tuple as its
        argument.<footnote>
            <para><function>fst</function> has type <type>(a, b) -&gt; a</type>, and
            <function>isEven</function> has type <type>Int -&gt; Boolean</type>. It's possible to
            use the output from <function>fst</function> as the input to
            <function>isEven</function>, because we can treat the type variable <varname>a</varname>
            as referring to the <type>Int</type> type (in other words, the function constructed by
            <function>compose</function> will accept any 2-tuple whose first element is an
            <type>Int</type>). However, there is no way to use the output of
            <function>isEven</function> as input to <function>fst</function>, because there's no way
            to bind the type variables such that a <type>Boolean</type> value matches the type
            <type>(a, b)</type>.</para>
          </footnote></para>
      </section>

      <section>
        <title>Defining functions</title>

        <para>Functions are specified using a function definition. Function definitions are not
        expressions, so you cannot type them into the prompt in ICE. They must appear in a module,
        which may then be compiled and loaded.</para>

        <para>Function definitions take the form of an equation, with an optional visibility
        specification:<informalexample>
            <programlisting>public square n =
    n * n;
public removeEmptyElements list =
    filter (compose not isEmpty) list;</programlisting>
          </informalexample></para>

        <para>The first definition specifies that <code>square x</code> is a function that returns
        <code>x * x</code>. It is also public, which means that it can be used from outside the
        module in which it is defined. The second definition specifies that
        <code>removeEmptyElements x</code> is a function that accepts a list of lists and returns a
        new version of the list that has all of the empty lists removed.</para>

        <para>With the <function>square</function> and <function>removeEmptyElements</function>
        functions defined as above, the following expressions can be evaluated:<informalexample>
            <literallayout><userinput>square 2.1</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>4.41</computeroutput></literallayout>
          </informalexample><informalexample>
            <para><informalexample>
                <literallayout><userinput>removeEmptyElements [['a', 'b', 'c'], [], ['d', 'e'], []] </userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[['a', 'b', 'c'], ['d', 'e']]</computeroutput></literallayout>
              </informalexample></para>
          </informalexample></para>

        <para>It is good practice to precede each function definition with a type
        declaration:<informalexample>
            <programlisting>square :: Num a =&gt; a -&gt; a;
public square x =
    x * x;
removeEmptyElements :: [[a]] -&gt; [[a]];
public removeEmptyElements x =
    filter (compose not isEmpty) x;</programlisting>
          </informalexample></para>

        <para>In the first example, we declare that <function>square</function> accepts a single
        argument, which must be a member of the <classname>Num</classname> class, and returns a
        value of the same type. In the second example, we declare that
        <function>removeEmptyElements</function> accepts a single list of lists of some type
        <type>a</type>, and returns a list of lists of the same type <type>a</type>.</para>
      </section>

      <section>
        <title>Lambda expressions</title>

        <para>It is often convenient to create functions that have no names. Such functions are
        referred to as lambda expressions. They are usually passed to higher-order functions such as
        map or filter. In CAL, lambda expressions are introduced by a backslash:<informalexample>
            <para><code>\x y -&gt; (y, x)</code></para>
          </informalexample></para>

        <para>The arguments of the function are listed after the backslash, and the body of the
        function is listed after the right-arrow (<function role="operator">-&gt;</function>). The
        above expression produces a function that accepts two arguments and returns a pair of the
        arguments in reversed order:<informalexample>
            <literallayout><userinput>:t \x y -&gt; (y,x)</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>a -&gt; b -&gt; (b,a)</computeroutput>
</literallayout>
          </informalexample></para>

        <para>Anonymous functions are often used in situations where a very specific, single-purpose
        function is required:<informalexample>
            <programlisting>maxList :: Ord a =&gt; [a] -&gt; a;
maxList valueList = 
    List.foldRight1 max valueList;
normalizeScores :: [Double] -&gt; [Double];
normalizeScores rawScores =
    let
        maxScore :: Double;
        maxScore = maxList rawScores;
    in
        map (\x -&gt; x / maxScore) rawScores;
</programlisting>
          </informalexample></para>

        <para>In the example above, <function>normalizeScores</function> passes to
        <function>map</function> a lambda expression that accepts a single value and divides it by a
        specific number (in the case, the number returned by <code>maxList rawScores</code>). This
        function does not make recursive calls to itself, so it is both possible and convenient to
        pass it in as a lambda expression rather than creating a separate named function.</para>

        <para>It is possible (and frequently desirable) to access local variables from the scope
        that an anonymous function is specified within. For example, in the above code, the lambda
        expression passed to <function>map</function> references the local definition of
        <function>maxScore</function>.</para>
      </section>
    </section>

    <section>
      <title>User-defined types</title>

      <para>In addition to its various built-in types, CAL also allows you to define your own types
      using data definitions.<footnote>
          <para>This is not the only way to define new types. See also <xref
          linkend="ForeignTypeDefinitions" />.</para>
        </footnote> One such type defined in the Prelude is the <type>Ordering</type> type. We can
      write our own version:<informalexample>
          <programlisting>/**
 * Represents an ordering relationship between two values: less 
 * than, equal to, or greater than.
 * 
 * @see typeClass = Ord
 * @see function = compare
 */
data public MyOrdering =
    /**
     * A data constructor that represents the ordering 
     * relationship of "less than".
     */
    public MyLT |
    /**
     * A data constructor that represents the ordering 
     * relationship of "equal to".
     */
    public MyEQ |
    /**
     * A data constructor that represents the ordering
     * relationship of "greater than".
     */
    public MyGT
    deriving Eq, Ord, Enum, Bounded, Outputable;</programlisting>
        </informalexample></para>

      <para>This example defines the <type>MyOrdering</type> type as being
      <modifier>public</modifier> (i.e., usable in other modules). The <type>MyOrdering</type> type
      contains three values, which are constructed by the data constructors
      <function>MyLT</function>, <function>MyEQ</function>, and <function>MyGT</function>. Note that
      the data constructors are also declared as being <modifier>public</modifier>. This means that
      code in other modules will be able to use the data constructors directly to create values of
      this type (i.e., this is not an Abstract Data Type).</para>

      <para>We could use the <type>MyOrdering</type> type to write functions that order geometric
      points:<informalexample>
          <programlisting>comparePoints :: Num a =&gt; (a, a) -&gt; (a, a) -&gt; MyOrdering;
public comparePoints point1 point2 =
    case point1 of
    (x1,y1) -&gt;
        case point2 of
        (x2,y2) -&gt;
            if x1 &gt; x2 then
                MyGT
            else if x1 &lt; x2 then
                MyLT
            else if y1 &gt; y2 then
                MyGT
            else if y1 &lt; y2 then
                MyLT
            else
                MyEQ;
        ;
    ;</programlisting>
        </informalexample></para>

      <para>With <function>comparePoints</function> defined as above, the following expressions can
      be evaluated:<informalexample>
          <literallayout><userinput>comparePoints (1.0, 2.0) (5.0, 6.0)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>MyLT</computeroutput>
</literallayout>
        </informalexample><informalexample>
          <literallayout><userinput>comparePoints (1.0, 2.0) (-4.0, 1.0)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>MyGT</computeroutput>
</literallayout>
        </informalexample><informalexample>
          <literallayout><userinput>comparePoints (1.0, 2.0) (1.0, 1.0)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>MyGT</computeroutput>
</literallayout>
        </informalexample><informalexample>
          <literallayout><userinput>comparePoints (9.0, 9.5) (9.0, 9.5)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>MyEQ</computeroutput>
</literallayout>
        </informalexample></para>

      <para>It is also possible to define types that "wrap" other types. Types of this kind have at
      least one data constructor that accepts one or more arguments:<informalexample>
          <programlisting>data public MyMaybe a = 
    public MyNothing | 
    public MyJust
        value :: a;</programlisting>
        </informalexample></para>

      <para>The above defines a family of types <type>MyMaybe a</type> with two data constructors:
      <function>MyNothing</function>, which is a familiar 0-argument data constructor, and
      <function>MyJust</function>, which takes a single argument, named
      <parameter>value</parameter>, of type <type>a</type>.</para>

      <para>The Prelude defines a type of this form called <type>Maybe a</type>. The return type
      from functions that might fail is often <type>Maybe Result</type> (where <type>Result</type>
      is some result type). If a database operation succeeds, for example, a function might return
      <function>Just <replaceable>value</replaceable></function>, (where
      <replaceable>value</replaceable> is a value of type <type>Result</type>) whereas if it fails,
      it might return <function>Nothing</function>.</para>

      <para>The <type>Maybe a</type> family contains types for all of the different bindings of
      <varname>a</varname>:<informalexample>
          <literallayout><userinput>:t Just 50.0</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Maybe Double)</computeroutput>
</literallayout>
        </informalexample><informalexample>
          <literallayout><userinput>:t Just (10 :: Int)</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Maybe Int)</computeroutput>
</literallayout>
        </informalexample><informalexample>
          <literallayout><userinput>:t Just "ahoy"</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Maybe String)</computeroutput>
</literallayout>
        </informalexample><informalexample>
          <literallayout><userinput>:t Nothing</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Maybe a)</computeroutput>
</literallayout>
        </informalexample><informalexample>
          <literallayout><userinput>Just 50.0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Just 50.0</computeroutput>
</literallayout>
        </informalexample><informalexample>
          <literallayout><userinput>Nothing</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Ambiguous type signature in inferred type Prelude.Outputable a =&gt; a</computeroutput>
</literallayout>
        </informalexample></para>

      <para>The attempt to evaluate the type of <function>Nothing</function> on its own fails,
      because that data constructor does not take enough arguments to allow the type inferencer to
      determine the type represented by <varname>a</varname>. As usual, an explicit type declaration
      can resolve the ambiguity:</para>

      <informalexample>
        <literallayout><userinput>(Nothing :: Maybe Char)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Nothing</computeroutput>
</literallayout>
      </informalexample>

      <para>Note that we must declare the name and type of every argument that a data constructor
      takes. Note also that when the type of a data constructor's argument is a type variable, then
      that type variable must also appear as an argument to the type constructor:<informalexample>
          <para><programlisting>data public MyEither a b = 
    public MyLeft     value :: a | 
    public MyRight    value :: b;</programlisting></para>

          <para><emphasis role="bold-italic">compiles without error</emphasis></para>
        </informalexample><informalexample>
          <para><programlisting>data public Value = 
    public StringValue    strValue :: String |
    public IntValue       intValue :: Int |
    public BooleanValue   boolValue :: Boolean |
    public DoubleValue    dblValue :: Double;
</programlisting></para>

          <para><emphasis role="bold-italic">compiles without error</emphasis></para>
        </informalexample></para>

      <para>The declaration of <function>Value</function> compiles without error even though its
      data constructors accept arguments that are not arguments to the type constructor because none
      of the argument types are type variables.<informalexample>
          <para><programlisting>data public Broken1 = 
    public Simple | 
    public BrokenWildcard    arg :: a;
</programlisting><emphasis role="bold-italic">Error:</emphasis> <computeroutput>The type variable a
          must appear on the left-hand side of the data declaration.</computeroutput></para>
        </informalexample></para>

      <para>The declaration of <type>Broken1</type> fails because the
      <function>BrokenWildcard</function> data constructor takes an argument of type <type>a</type>,
      but the type constructor does not accept <parameter>a</parameter> as an
      argument.<informalexample>
          <para><programlisting>data public Broken2 a = 
    public BrokenLeft     value :: a | 
    public BrokenRight    value :: b;</programlisting><emphasis role="bold-italic">Error:</emphasis>
          <computeroutput>The type variable b must appear on the left-hand side of the data
          declaration.</computeroutput></para>
        </informalexample></para>

      <para>The declaration of <type>Broken2</type> fails because the data constructor
      <function>BrokenRight</function> takes an argument of type <type>b</type>, but the type
      constructor does not take <parameter>b</parameter> as an argument.</para>

      <section>
        <title xml:id="CaseExpressionsPart2">Case expressions, part 2</title>

        <para>As with lists and tuples, the components of user-defined data structures are accessed
        using case expressions. Patterns based on the data constructors for a type can be used to
        unpackage the components of an instance of a user-defined type:<informalexample>
            <programlisting>maybeToList :: Maybe a -&gt; [a];
public maybeToList m =
    case m of
    Nothing -&gt; [];
    Just value  -&gt; [value];
    ;</programlisting>
          </informalexample></para>

        <para>The above code converts any value of type <type>Maybe a</type> (for some type
        <type>a</type>) into a list of elements of type <type>a</type>. If the value passed in is
        <function>Nothing</function>, then the list is empty. If the value passed in is
        <parameter>Just x</parameter> (for some value <parameter>x</parameter>), then the list will
        be a single-element list whose only element is <parameter>x</parameter>. With the above
        definition, we can evaluate the following expressions:<informalexample>
            <literallayout><userinput>maybeToList (Just 'c')</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>['c']</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>maybeToList (Nothing :: Maybe Int)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[]</computeroutput>
</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>maybeToList (Just 12.2)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[12.2]</computeroutput>
</literallayout>
          </informalexample></para>

        <para>If only certain components in a user-defined type are required, an alternative syntax
        may be used specifying only the required components:<informalexample>
            <programlisting>data public TripleType a b c =
    public TripleDC
        field1 :: a
        field2 :: b
        field3 :: c;
public addFirstAndThird tripleType =
    case tripleType of
    TripleDC {field1, field3} -&gt; field1 + field3; 
    ;</programlisting>
          </informalexample></para>

        <para>The <function>addFirstAndThird</function> function returns the sum of the values of
        the <parameter>field1</parameter> and <parameter>field3</parameter> arguments from a
        <type>TripleType</type> data value.<informalexample>
            <literallayout><userinput>addFirstAndThird (TripleDC 2.0 "String" 3.0)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>5.0</computeroutput>
</literallayout>
          </informalexample></para>

        <para>There are times when we don't want to specify all possible alternatives in a case
        expression. In these instances, we can use a default pattern (the underscore) to match all
        of the alternatives that are not explicitly specified:<informalexample>
            <programlisting>pointGreaterThan :: Num a =&gt; (a, a) -&gt; (a, a) -&gt; Boolean;
pointGreaterThan p1 p2 =
    case comparePoints p1 p2 of
    MyGT -&gt; True;
    _ -&gt; False;
    ;</programlisting>
          </informalexample></para>

        <para>For the purposes of <function>pointGreaterThan</function>, all that matters is whether
        <function>comparePoints</function> returns <function>MyGT</function>. If it does not, then
        it doesn't matter whether it returned <function>MyLT</function> or
        <function>MyEQ</function>. So rather than specify separate patterns for
        <function>MyLT</function> and <function>MyEQ</function>, the above definition provides only
        two patterns: One for <function>MyGT</function>, and one for everything else.</para>
      </section>
    </section>

    <section>
      <title>Accessing CALDoc information</title>

      <para>CAL has a special kind of comment known as CALDoc that is similar to Javadoc. CALDoc
      comments are added by the developer to CAL code elements, which are processed by the compiler
      during compilation.</para>

      <para>The source in the CAL standard library has a lot of CALDoc associated with it. This
      CALDoc documentation can be a very useful source of up-to-date documentation on specific
      functions, data constructors, methods, types, type classes, and modules.</para>

      <para>ICE provides commands for displaying the CALDoc associated with CAL entities:</para>

      <informaltable>
        <tgroup align="left" cols="2">
          <thead>
            <row>
              <entry>ICE Command</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><command>:docm <replaceable>module_name</replaceable></command></entry>

              <entry>Show the CALDoc comment associated with the named module</entry>
            </row>

            <row>
              <entry><command>:docf
              <replaceable>function_or_class_method_name</replaceable></command></entry>

              <entry>Show the CALDoc comment associated with the named function or class
              method.</entry>
            </row>

            <row>
              <entry><command>:doct <replaceable>type_name</replaceable></command></entry>

              <entry>Show the CALDoc comment associated with the named type constructor</entry>
            </row>

            <row>
              <entry><command>:docd
              <replaceable>data_constructor_name</replaceable></command></entry>

              <entry>Show the CALDoc comment associated with the named data constructor.</entry>
            </row>

            <row>
              <entry><command>:docc <replaceable>type_class_name</replaceable></command></entry>

              <entry>Show the CALDoc comment associated with the named type class.</entry>
            </row>

            <row>
              <entry><command>:doci <replaceable>type_class_name
              instance_type_constructor</replaceable></command></entry>

              <entry>Show the CALDoc comment associated with the named instance.</entry>
            </row>

            <row>
              <entry><command>:docim <replaceable>method_name type_class_name
              instance_type_constructor</replaceable></command></entry>

              <entry>Show the CALDoc comment associated with the named instance method.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>For example, to display the CALDoc associated with the Dynamic module, use the
      <command>:docm</command> command from the ICE command prompt:<informalexample>
          <literallayout><userinput>:docm Dynamic</userinput>
<emphasis role="bold-italic">outputs</emphasis>
<computeroutput>CALDoc for the Cal.Core.Dynamic module:
Defines the Dynamic type along with a variety of functions for working 
with it.
Based on the Dynamics module in Hugs and GHC, and the paper "Scrap your 
boilerplate: a practical design for generic programming".
Author:
  Bo Ilic
  James Wright</computeroutput></literallayout>
        </informalexample></para>

      <para>Similarly, to display the CALDoc associated with the <function>minBound</function>
      method, use the <function>:docf</function> command:<informalexample>
          <literallayout><userinput>:docf minBound</userinput>
<emphasis role="bold-italic">outputs</emphasis>
<computeroutput>Cal.Core.Prelude.minBound :: Bounded a =&gt; a

CALDoc for the Cal.Core.Prelude.minBound class method:

(Required method)

Returns:
  result :: Bounded a =&gt; a
    the minimum bound of the instance type.</computeroutput></literallayout>
        </informalexample></para>

      <para>Note that it is possible for the methods of a specific instance to have their own CALDoc
      also. To view this CALDoc, use the <command>:docim</command> command. For example, to see the
      CALDoc for the <function>minBound</function> method of the <classname>Bounded</classname>
      instance for the <type>Char</type> type:<informalexample>
          <literallayout><userinput>:docim minBound Bounded Char</userinput>
<emphasis role="bold-italic">outputs</emphasis>
<computeroutput>minBound :: Char

CALDoc for the minBound method in the 
Cal.Core.Prelude.Bounded#Cal.Core.Prelude.Char instance:

(Required method)

The minimum bound for Char is '\u0000'.

Returns:
  result :: Char</computeroutput></literallayout>
        </informalexample></para>
    </section>

    <section>
      <title xml:id="StandardLibraryModules">Standard library modules</title>

      <para>The CAL standard library is divided into several different modules. Each module provides
      functions, types, type classes and/or instances related to a specific area of
      functionality.</para>

      <para>Every CAL module must import the <classname>Prelude</classname> module. If you wish to
      use functionality provided by any other library module, then you must import that module as
      well. For example, to operate on <type>Array</type> values a CAL module must import at least
      the <classname>Prelude</classname> module and the <classname>Array</classname> module.</para>

      <section>
        <title>Cal.Core.Prelude</title>

        <para>The Prelude module is the core module of CAL. It must be imported by every other CAL
        module.</para>

        <para>The Prelude defines the primitive types <type>Char</type>, <type>Boolean</type>,
        <type>Byte</type>, <type>Short</type>, <type>Int</type>, <type>Long</type>,
        <type>Float</type>, and <type>Double</type> that correspond to the primitive unboxed Java
        types. It also defines other important CAL types such as <type>String</type>,
        <type>Function</type>, <type>List</type>, <type>Maybe</type>, <type>Either</type>,
        <type>Unit</type>, and the built-in record and tuple types.</para>

        <para>The Prelude also defines the core type classes: <classname>Eq</classname>,
        <classname>Ord</classname>, <classname>Num</classname>, <classname>Inputable</classname>,
        <classname>Outputable</classname>, <classname>Appendable</classname>,
        <classname>Bounded</classname>, <classname>Enum</classname>, <classname>IntEnum</classname>,
        and <classname>Typeable</classname>, as well as appropriate instances of these classes for
        the types listed above.</para>

        <para>The Prelude also contains definitions for many functions that are widely useful in
        writing CAL code.</para>
      </section>

      <section>
        <title>Cal.Collections.Array</title>

        <para>The Array module defines the <type>Array</type> abstract data type, plus a variety of
        functions and instances for operating on <type>Array</type> values.</para>

        <para><type>Array</type> is a polymorphic type; you can construct an <type>Array</type> of
        CAL values of any type. <type>Array</type> values are immutable (ie, purely functional); all
        operations that "change" element values actually return an entirely new <type>Array</type>
        value without modifying the original.</para>

        <para><type>Array</type> values allow constant time access to their elements.</para>
      </section>

      <section>
        <title>Cal.Core.Bits</title>

        <para>The Bits module defines the <classname>Bits</classname> type class. The
        <classname>Bits</classname> type class has methods for performing bitwise operations on
        numeric values (eg, shifts, bitwise boolean operations, etc.). It also provides
        <classname>Bits</classname> instances for the <type>Int</type> and <type>Long</type>
        types.</para>
      </section>

      <section>
        <title>Cal.Core.Char</title>

        <para>The Char module defines a number of useful library functions for operating on
        <type>Char</type> values (eg <function>isLetter</function>,
        <function>isLowerCase</function>).</para>
      </section>

      <section>
        <title>Cal.Core.Debug</title>

        <para>The Debug module provides functionality for debugging CAL programs. It provides the
        <classname>Show</classname> type class, whose <function>show</function> method that will
        convert a CAL value to a human-readable string value, as well as <classname>Show</classname>
        instances for the main CAL data types.</para>

        <para>It also provides the <function>trace</function> function, which is useful for
        inserting tracing statements into CAL code (for "<function>printf</function>
        debugging").</para>

        <para>The Debug module also provides functions to support execution timing and reduction
        tracing.</para>
      </section>

      <section>
        <title>Cal.Utilities.Decimal</title>

        <para>The Decimal module provides useful libraries functions for the <type>Decimal</type>
        type. The <type>Decimal</type> type is an arbitrary-precision integer type based on the Java
        <type>BigDecimal</type> type.</para>
      </section>

      <section>
        <title>Cal.Core.Dynamic</title>

        <para>The Dynamic module defines the <type>Dynamic</type> type and functions for operating
        on <type>Dynamic</type> values. <type>Dynamic </type>values can contain CAL values of any
        type; this allows for the writing of dynamically-typed code (for example, lists that contain
        elements of more than one type). See <xref linkend="DynamicTyping" /> for more
        details.</para>
      </section>

      <section>
        <title>Cal.Core.Exception</title>

        <para>The Exception module provides support for handling exceptions in CAL.</para>

        <para>Exceptions can arise in CAL in a number of ways:<orderedlist spacing="compact">
            <listitem>
              <para>a Java exception is thrown by a call to a foreign function or a primitive
              function</para>
            </listitem>

            <listitem>
              <para>a call to the <function>error</function> function</para>
            </listitem>

            <listitem>
              <para>a pattern matching failure in a case expression or data constructor field
              selection expression e.g. <code>(case Just 10.0 of Nothing -&gt; "abc";)</code> and
              <code>(Left 10.0).Right.value</code>.</para>
            </listitem>

            <listitem>
              <para>a call to the <function>throw</function> function</para>
            </listitem>
          </orderedlist></para>

        <para>Exceptions in categories 1-3 are called Java exceptions because they are not
        associated with a specific CAL type. They can be caught with handlers for the type
        <type>Exception.JThrowable</type>. They can also be caught with any CAL foreign type that is
        an instance of the type class <classname>Exception</classname> such that the foreign
        implementation type is a Java subclass of <classname>java.lang.Throwable</classname>, and
        such that the exception is assignment compatible with the implementation type. For example,
        if a foreign function throws a <classname>java.lang.NullPointerException</classname>, then
        this can be caught by a handler for the CAL types <type>JThowable</type>,
        <type>JRuntimeException</type>, <type>JNullPointerException</type>, but not a handler for
        <type>JIllegalStateException</type> (assuming the natural implied data declarations for
        these CAL types).</para>

        <para>Exceptions in category 4 are called CAL exceptions because they are associated with a
        specific CAL type, namely the type at which the exception was thrown using the throw
        function. They must be caught at that precise type.</para>

        <para>Here is an example showing a function throwing a CAL value of a record-type as an
        exception, catching it, and then doing some simple manipulations:<informalexample>
            <programlisting>calThrownException5 =
    throw ("abc", 1 :: Int, 2 :: Integer,
           ["abc", "def"], Just (20 :: Int))
    `catch`
    (
        let
            handler :: (String, Int, Integer,
                        [String], Maybe Int) -&gt; String;
            handler r = show (r.#5, r.#4, r.#3, r.#2, r.#1);
        in
            handler
    );
//evaluates to True
testCalThrownException5 =
    calThrownException5 ==
        "(Prelude.Just 20, [\"abc\", \"def\"], 2, 1, \"abc\")";
instance Exception String where;
instance Exception Int where;
instance Exception Integer where;
instance Exception a =&gt; Exception (Maybe a) where;
instance Exception a =&gt; Exception [a] where;
instance Exception r =&gt; Exception {r} where;
</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>Cal.Collections.Map, Cal.Collections.IntMap, Cal.Collections.LongMap</title>

        <para>The Map module defines the <type>Map</type> type, which is an efficient implementation
        of maps from keys of arbitrary type to values of arbitrary type. The IntMap and LongMap
        modules provide the <type>IntMap</type> and <type>LongMap</type> types, which are efficient
        implementations of maps from <type>Int</type> or <type>Long </type>keys (respectively) to
        values of arbitrary type.</para>
      </section>

      <section>
        <title>Cal.Collections.List</title>

        <para>The List module provides useful library functions for operating on <type>List</type>
        values. The actual <type>List</type> type is defined in the Prelude module.</para>
      </section>

      <section>
        <title>Cal.Utilities.Locale</title>

        <para>The Locale module defines the <type>Locale</type> type, and provides functions for
        working with locale values, accessing locale properties of the system, and performing
        locale-sensitive string comparisons through the use of the types <type>Collator</type> and
        <type>CollationKey</type>.</para>
      </section>

      <section>
        <title>Cal.Utilities.Math</title>

        <para>The Math module provides a number of useful library functions for math, such as
        trigonometric, logarithmic, and exponential operations, among others.</para>
      </section>

      <section>
        <title>Cal.Utilities.MessageFormat</title>

        <para>The MessageFormat module defines a set of functions for formatting strings with
        message patterns. It provides a means for producing concatenated messages in a localizable
        way.</para>
      </section>

      <section>
        <title>Cal.Utilities.QuickCheck</title>

        <para>The QuickCheck module provides a simple mechanism for testing programs by generating
        arbitrary test data.</para>

        <para>The basic idea is to help simplify and improve testing by automatically creating
        arbitrary test data. Properties of programs can be described by functions. QuickCheck can be
        used to validate these properties by automatically generating lots of arbitrary data to fill
        the functions' parameters. If a property is not true, QuickCheck can report the parameters
        that falsified the property.</para>
      </section>

      <section>
        <title>Cal.Utilities.Random</title>

        <para>The Random module provides functions for generating lists of pseudo-random
        numbers.</para>
      </section>

      <section>
        <title>Cal.Core.Record</title>

        <para>The Record module provides many useful functions for working with CAL record types.
        Since tuples are records, these functions are also useful for working with tuples.</para>
      </section>

      <section>
        <title>Cal.Core.Resource</title>

        <para>The Resource module provides access to localizable user resources in the CAL
        environment.</para>
      </section>

      <section>
        <title>Cal.Collections.Set</title>

        <para>The Set module provides the Set type, which is an efficient implementation of sets of
        values.</para>
      </section>

      <section>
        <title>Cal.Core.String</title>

        <para>The String module provides a number of useful library functions for operating on
        String values.</para>
      </section>

      <section>
        <title>Cal.Utilities.StringNoCase</title>

        <para>The StringNoCase module defines the <type>StringNoCase</type> type, which represents
        case-insensitive string values, as well as appropriate type class instances for the
        <type>StringNoCase</type> type. It also provides functions for operating on
        <type>StringNoCase</type> values and for converting between <type>String</type> and
        <type>StringNoCase</type> values.</para>

        <para>There aren't a lot of functions for operating on <type>StringNoCase</type> values,
        because converting between <type>String</type> and <type>StringNoCase</type> values is quite
        efficient. That means that it's usually feasible to just convert to a <type>String</type>,
        use the appropriate <type>String</type> operation, and then convert back to a
        <type>StringNoCase</type>.</para>
      </section>

      <section>
        <title>Cal.Utilities.StringProperties</title>

        <para>The StringProperties module defines the types <type>StringProperties</type> and
        <type>StringResourceBundle</type> with are useful for working with string resource
        files.</para>
      </section>

      <section>
        <title>Cal.Core.System</title>

        <para>The System module provides functions for interacting with the current CAL execution
        context. Among the functions it provides are <function>getProperty</function>,
        <function>hasProperty</function>, and <function>propertyKeys</function>, which can be used
        to query the execution context for CAL system properties.</para>
      </section>

      <section>
        <title>Cal.Utilities.TimeZone</title>

        <para>The TimeZone module defines the <type>TimeZone</type> type and its affiliated
        operations.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Language Reference</title>

    <section>
      <title>Comments</title>

      <para>Comments in CAL can be classified into two categories: regular comments and CALDoc
      comments.</para>

      <section>
        <title>Regular comments</title>

        <para>A regular comment is a piece of human-readable text that is ignored by the compiler.
        CAL uses the same syntax for regular comments as Java and C++. The compiler will ignore any
        text that falls between two forward-slashes (<code>//</code>) and the end of the line, or
        that falls between a forward-slash and an asterisk (<code>/*</code>) and an asterisk and a
        forward-slash (<code>*/</code>).</para>

        <para>Ex:<informalexample>
            <programlisting>5.0         // Compiler ignores this text, but processes the 5.0

/* Comments in the slash-star style
   may span
   multiple lines */
</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>CALDoc comments</title>

        <para>A CALDoc comment is a piece of end-user and developer visible documentation in the
        source code. Similar to a Javadoc comment in Java, a CALDoc comment is delimited by a
        forward-slash and two asterisks (<code>/**</code>) and an asterisk and a forward-slash
        (<code>*/</code>). On each of the lines making up a CALDoc comment, any leading whitespace
        and subsequent asterisks (<code>*</code>) are ignored.</para>

        <para>For more information on CALDoc comments, please see <xref linkend="CALDoc" />.</para>
      </section>
    </section>

    <section>
      <title>Expressions</title>

      <para>An expression is a unit of code that can be reduced to a value. Every expression returns
      a value of a specific type. This section lists the various types of legal CAL expressions,
      with some examples.</para>

      <section>
        <title>The unit value</title>

        <para>The simplest expression in CAL is the unit value. It corresponds to the
        <type>void</type> type of Java (and other languages). It is written as an empty pair of
        round brackets:<synopsis>()</synopsis></para>
      </section>

      <section>
        <title>Numeric literals</title>

        <para>Numeric literals can be written either in exponential notation, or in standard
        notation. Standard notation is written as a series of digits, with an optional decimal
        point:<synopsis><replaceable>digits</replaceable>[.[<replaceable>digits</replaceable>]]</synopsis></para>

        <para>Some examples:<informalexample>
            <literallayout><literal>50
50.0</literal></literallayout>
          </informalexample></para>

        <para>Exponential notation is also permitted:<synopsis><replaceable>digits</replaceable>[.[<replaceable>digits</replaceable>]] e <replaceable>digits</replaceable>[.[<replaceable>digits</replaceable>]]</synopsis></para>

        <para>In exponential notation, a number is represented by one number (called the mantissa)
        multiplied by some power of ten. In CAL as in most languages, this is written as the
        mantissa followed by a letter E followed by the power of ten to multiply by:<informalexample>
            <programlisting>5.0e2       // 5.0 * 10^2    == 500.0
5.0E-1      // 5.0 * 10^(-1) == 0.5
</programlisting>
          </informalexample></para>

        <para>Note that the case of the letter E is not significant.</para>
      </section>

      <section>
        <title>List expressions</title>

        <para>A list is an ordered, variable-size series of values of the same type. In CAL, lists
        are represented by comma-separated values enclosed within square brackets:<informaltable>
            <tgroup align="left" cols="2">
              <thead>
                <row>
                  <entry>Value</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><code>[]</code></entry>

                  <entry><literallayout>Empty list
Type: <type>[a]</type></literallayout></entry>
                </row>

                <row>
                  <entry><code>["foo", "bar", "baz"]</code></entry>

                  <entry><literallayout>List of three Strings
Type: <type>[String]</type></literallayout></entry>
                </row>

                <row>
                  <entry><code>[[1, 2], [9, 9, 8]]</code></entry>

                  <entry><literallayout>List of two lists (see Tuples)
Type: <type>Num a =&gt; [[a]]</type></literallayout></entry>
                </row>

                <row>
                  <entry><code>[(6.0, 7.0), (2.0, 1.0)]</code></entry>

                  <entry><literallayout>List of two pairs
Type: <type>[(Double, Double)]</type></literallayout></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>Note that it is possible to have an empty list (i.e. a list containing 0 elements). It
        is also possible to nest lists, where one list contains other lists.</para>

        <para>See <xref linkend="Lists" /> for some of the specialized list-handling operations that
        CAL provides.</para>
      </section>

      <section>
        <title>Record expressions</title>

        <para>A record is an unordered collection of named values of possibly differing type. A
        record is represented by a comma-separated list of field assignments:<synopsis>{<replaceable>fieldname</replaceable> = <replaceable>expression</replaceable> [, <replaceable>fieldname</replaceable> = <replaceable>expression</replaceable> ...] }</synopsis></para>

        <para>Ex:<informaltable>
            <tgroup align="left" cols="2">
              <thead>
                <row>
                  <entry>Value</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><code>{}</code></entry>

                  <entry><literallayout>Empty record
Type: <type>{}</type></literallayout></entry>
                </row>

                <row>
                  <entry><code>{x=1.0, y=1.0}</code></entry>

                  <entry><literallayout>Record with two fields
Type: <type>{x :: Double, y :: Double}</type></literallayout></entry>
                </row>

                <row>
                  <entry><code>{name="Jack", age=32.0, gender='M'}</code></entry>

                  <entry><literallayout>Record with three fields
Type: <type>{age :: Double, gender :: Char,
name :: String}</type></literallayout></entry>
                </row>

                <row>
                  <entry><code>{age=32.0, gender='M', name="Jack"}</code></entry>

                  <entry><literallayout>Equivalent to previous record.</literallayout></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>Note that it is possible for a record to contain 0 fields (i.e., to be empty).</para>

        <para>A fieldname is either an identifier starting with a lower-case letter, or an ordinal
        number preceded by the number sign (<function role="operator">#</function>).</para>

        <para>It is possible to obtain the value of an individual field of a record expression using
        the field-selection operator (<function role="operator">.</function>). Attempting to obtain
        a field from a record that doesn't include the specified field is an error.
        Ex:<informalexample>
            <literallayout><userinput>{ x=1.0, y=0.5 }.y</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>0.5</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>{ name="Fred", age=22.0, #1='a', #2='b' }.#1</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>'a'</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>{ name="Jack" }.age</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type error. Invalid record selection for field age. Caused 
by: the record type {name :: Prelude.String} is missing the 
fields [age] from the record type a\age =&gt; {a | age :: b}.</computeroutput></literallayout>
          </informalexample></para>

        <para>It is also possible to extend a record with additional fields, and to update existing
        fields in a record. Both record extension and record update can be achieved by using a
        record case expression, or by using a special syntax.</para>

        <para>Record extension:<informalexample>
            <literallayout><userinput>{{x = 1.0, y = 1.0} | z = 2.0}</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>{x = 1.0, y = 1.0, z = 2.0}</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>case {x = 1.0, y = 1.0} of {x = x1, y = y1} -&gt; {x = x1, y = y1, z = 2.0};</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>{x = 1.0, y = 1.0, z = 2.0}</computeroutput></literallayout>
          </informalexample></para>

        <para>Record update:</para>

        <informalexample>
          <literallayout><userinput>{{x = 1.0, y = 1.0} | y := 2.0}</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>{x = 1.0, y = 2.0}</computeroutput></literallayout>
        </informalexample>

        <informalexample>
          <literallayout><userinput>case {x = 1.0, y = 1.0} of {x = x1, y = _} -&gt; {x = x1, y = 2.0};</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>{x = 1.0, y = 2.0}</computeroutput></literallayout>
        </informalexample>
      </section>

      <section>
        <title>Tuple expressions</title>

        <para>A tuple is an ordered, constant-size collection of values of possibly differing type.
        Tuples are represented in CAL by comma-separated values enclosed within
        parentheses:<informaltable>
            <tgroup align="left" cols="2">
              <thead>
                <row>
                  <entry>Value</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><code>(1.0, 2.0)</code></entry>

                  <entry><literallayout>Pair (2-tuple) of Doubles
Type: <type>(Double, Double)</type></literallayout></entry>
                </row>

                <row>
                  <entry><code>('a', 'b', 3.0)</code></entry>

                  <entry><literallayout>Triple (3-tuple) of two Chars and a Double
Type: <type>(Char, Char, Double)</type></literallayout></entry>
                </row>

                <row>
                  <entry><code>("s", [], [7.0], 'c')</code></entry>

                  <entry><literallayout>4-tuple of a String, two lists, and a Char
Type: <type>(String, [a], [Double], Char)</type></literallayout></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>A tuple is a special case of a record whose fields have ordinal names from
        <varname>#1</varname> to <varname>#n</varname> (for a tuple of dimension
        <emphasis>n</emphasis>). So for example, a 3-tuple is equivalent to a record of three fields
        named <emphasis>#1</emphasis>, <emphasis>#2</emphasis>, and <emphasis>#3</emphasis>.</para>

        <para>Since tuples are just a special case of records, all of the same syntax that applies
        to records can also be used with tuples. Ex:<informalexample>
            <literallayout><userinput>{ #1=10.0, #2='a' }.#1</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>10.0</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>(10.0, 'a').#1</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>10.0</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>("s", [], "s2").#3</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"s2"</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>("s", [], "s2").#4</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type error. Invalid record selection for field #4. Caused by: 
the record type (Prelude.Char, Prelude.Char, Prelude.Char) is missing 
the fields [#4] from the record type a\#4 =&gt; {a | #4 :: b}.</computeroutput></literallayout>
          </informalexample></para>
      </section>

      <section>
        <title>Character literals</title>

        <para>CAL characters are represented by a character within single quotes:<informaltable>
            <tgroup align="left" cols="2">
              <tbody>
                <row>
                  <entry><literal>'A'</literal></entry>

                  <entry><literallayout>Capital A</literallayout></entry>
                </row>

                <row>
                  <entry><literal>'0'</literal></entry>

                  <entry><literallayout>Digit 0</literallayout></entry>
                </row>

                <row>
                  <entry><literal>'\t'</literal></entry>

                  <entry><literallayout>Tab character</literallayout></entry>
                </row>

                <row>
                  <entry><literal>'\''</literal></entry>

                  <entry><literallayout>Single-quote</literallayout></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>As with strings (see below), all of the usual escape-sequences work.</para>
      </section>

      <section>
        <title>String literals</title>

        <para>A string is an ordered sequence of characters. CAL string literals are written
        enclosed by double-quotes:<informalexample>
            <literallayout><literal>"this is a string"</literal>
<literal>"This \"string\" prints\n on two lines"</literal></literallayout>
          </informalexample></para>

        <para>All of the usual escape-sequences work:<informaltable>
            <tgroup align="left" cols="2">
              <tbody>
                <row>
                  <entry><literal>\n</literal></entry>

                  <entry>newline</entry>
                </row>

                <row>
                  <entry><literal>\r</literal></entry>

                  <entry>carriage return</entry>
                </row>

                <row>
                  <entry><literal>\t</literal></entry>

                  <entry>tab</entry>
                </row>

                <row>
                  <entry><literal>\"</literal></entry>

                  <entry>double quote</entry>
                </row>

                <row>
                  <entry><literal>\'</literal></entry>

                  <entry>single quote</entry>
                </row>

                <row>
                  <entry><literal>\\</literal></entry>

                  <entry>backslash</entry>
                </row>

                <row>
                  <entry><literal>\045</literal></entry>

                  <entry>newline</entry>
                </row>

                <row>
                  <entry><literal>\u0025</literal></entry>

                  <entry>the character specified by the octal value 45 (i.e.
                  <literal>'%'</literal>)</entry>
                </row>

                <row>
                  <entry><literal>\n</literal></entry>

                  <entry>the character specified by the hexadecimal value 25 (i.e.
                  <literal>'%'</literal>)</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>
      </section>

      <section>
        <title>Function application</title>

        <para>Functions are applied in CAL by writing the function name followed by the arguments
        separated by spaces:<synopsis><replaceable>fcn_name</replaceable> [<replaceable>arg1</replaceable> [<replaceable>arg2</replaceable> ... [<replaceable>argn</replaceable>]...]]</synopsis></para>

        <para>There is no special operator that represents function application. In particular, the
        list of arguments is not surrounded by parentheses. Example:<informalexample>
            <literallayout><userinput>pi</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>3.141592653589793</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>sin 0.0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>0.0</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>append "first string" " second string"</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"first string second string"</computeroutput></literallayout>
          </informalexample></para>

        <para>Function application has higher precedence than any operator, so parentheses may
        occasionally be required to make a function call behave as expected. For example, the
        (somewhat contrived) call<informalexample>
            <literallayout><userinput>let
    x = 9.0;
in
    max x + 5.0 6.0</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type error applying the operator "+" to its first argument.
Caused by: Type clash: type Prelude.Double -&gt; Prelude.Double is 
not a member of type class Prelude.Num</computeroutput></literallayout>
          </informalexample>will not take the maximum of <code>x + 5.0</code> and <code>6.0</code>.
        In fact, it will produce an error, because it parses as <code>(max x) + (5.0 6.0)</code>
        rather than <code>(max (x + 5.0) 6.0)</code>. Parentheses around the first argument can
        correct this:<informalexample>
            <literallayout><userinput>let 
    x = 9.0;
in
    max (x + 5.0) 6.0
</userinput><emphasis role="bold-italic">returns</emphasis> <computeroutput>14.0</computeroutput></literallayout>
          </informalexample></para>

        <section>
          <title>Partial function application</title>

          <para>One of the advantages of (and motivations for) CAL's syntax for function application
          is the ease with which it allows for partial function application. Partial function
          application allows one to create a new function with a smaller argument list from an
          existing function. For example, we can make a new version of <function>max</function> that
          already has one argument specified:<informalexample>
              <para><code>newMax = max 10.0;</code></para>
            </informalexample></para>

          <para>This produces a new function of one argument that returns 10.0 for numbers less than
          10.0, and unchanged numbers for numbers &gt;= 10.0:<informalexample>
              <literallayout><userinput>newMax 6.0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>10.0</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>newMax (-2.0)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>10.0</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>newMax 12.0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>12.0</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title>Operator application</title>

        <para>An operator is a function that is applied using infix notation. In other words, the
        name of the function is written in between its arguments instead of in front of them. For
        example, in the following expression the operator is <function role="operator">+</function>
        (addition):<informalexample>
            <literallayout><userinput>1.0 + 2.0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>3.0</computeroutput></literallayout>
          </informalexample></para>

        <para>In this example, the operator is <function role="operator">*</function>
        (multiplication):</para>

        <informalexample>
          <literallayout><userinput>4.0 * 5.0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>20.0</computeroutput></literallayout>
        </informalexample>

        <para>CAL has the following operators:<informaltable>
            <tgroup align="left" cols="3">
              <colspec colnum="1" colwidth="2*" />

              <colspec colnum="2" colwidth="3*" />

              <colspec colnum="3" colwidth="3*" />

              <thead>
                <row>
                  <entry>Operator</entry>

                  <entry>Meaning</entry>

                  <entry>Equivalent function, data constructor, or class method</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><function role="operator">==</function></entry>

                  <entry>Equal to</entry>

                  <entry><function>Prelude.equals</function></entry>
                </row>

                <row>
                  <entry><function role="operator">!=</function></entry>

                  <entry>Not equal to</entry>

                  <entry><function>Prelude.notEquals</function></entry>
                </row>

                <row>
                  <entry><function role="operator">&gt;</function></entry>

                  <entry>Greater than</entry>

                  <entry><function>Prelude.greaterThan</function></entry>
                </row>

                <row>
                  <entry><function role="operator">&lt;</function></entry>

                  <entry>Less than</entry>

                  <entry><function>Prelude.lessThan</function></entry>
                </row>

                <row>
                  <entry><function role="operator">&gt;=</function></entry>

                  <entry>Greater than or equal to</entry>

                  <entry><function>Prelude.greaterThanEquals</function></entry>
                </row>

                <row>
                  <entry><function role="operator">&lt;=</function></entry>

                  <entry>Less than or equal to</entry>

                  <entry><function>Prelude.lessThanEquals</function></entry>
                </row>

                <row>
                  <entry><function role="operator">+</function></entry>

                  <entry>Addition</entry>

                  <entry><function>Prelude.add</function></entry>
                </row>

                <row>
                  <entry><function role="operator">-</function></entry>

                  <entry>Subtraction</entry>

                  <entry><function>Prelude.subtract</function></entry>
                </row>

                <row>
                  <entry><function role="operator">*</function></entry>

                  <entry>Multiplication</entry>

                  <entry><function>Prelude.multiply</function></entry>
                </row>

                <row>
                  <entry><function role="operator">/</function></entry>

                  <entry>Division</entry>

                  <entry><function>Prelude.divide</function></entry>
                </row>

                <row>
                  <entry><function role="operator">%</function></entry>

                  <entry>Remainder</entry>

                  <entry><function>Prelude.remainder</function></entry>
                </row>

                <row>
                  <entry><function role="operator">&amp;&amp;</function></entry>

                  <entry>Boolean AND</entry>

                  <entry><function>Prelude.and</function></entry>
                </row>

                <row>
                  <entry><function role="operator">||</function></entry>

                  <entry>Boolean OR</entry>

                  <entry><function>Prelude.or</function></entry>
                </row>

                <row>
                  <entry><function role="operator">++</function></entry>

                  <entry>Append</entry>

                  <entry><function>Prelude.append</function></entry>
                </row>

                <row>
                  <entry><function role="operator">:</function></entry>

                  <entry>List construction</entry>

                  <entry><function>Prelude.Cons</function></entry>
                </row>

                <row>
                  <entry><function role="operator">#</function></entry>

                  <entry>Function composition</entry>

                  <entry><function>Prelude.compose</function></entry>
                </row>

                <row>
                  <entry><function role="operator">$</function></entry>

                  <entry>Function application</entry>

                  <entry><function>Prelude.apply</function></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <section>
          <title>Precedence and Associativity</title>

          <para>When multiple infix operators are used in an expression, ambiguity can arise about
          the order in which they should be applied. For example, the expression<informalexample>
              <para><code>1.0 + 2.0 * 2.0</code></para>
            </informalexample>is ambiguous in the absence of a well-defined operator precedence; it
          can be interpreted as either <code>(1.0 + 2.0) * 2.0</code>, in which case its value is
          <code>6.0</code>, or as <code>1.0 + (2.0 * 2.0)</code>, in which case its value is
          <code>5.0</code>. Fortunately, there is a well-defined operator precedence that determines
          the order in which operations are performed. Operators with higher precedence are applied
          first. In CAL, as in standard arithmetic, the value of the above expression is
          <code>5.0</code>, since the multiplication operator (<function
          role="function">*</function>) has a higher precedence than the addition operator
          (<function role="operator">+</function>).</para>

          <para>Arithmetic operators in CAL have the standard arithmetic precedence. There are also
          a number of other infix operators. The complete list of operator precedence is
          below.</para>

          <para>Some elements of CAL syntax (<function role="operator">::</function> for type
          expressions, backquotes (<function role="operator">``</function>) for arbitrary infix
          functions, and <function role="operator">.</function> for record and data constructor
          field selection) are "operator-like", in that they have associativity and precedence as
          well. The precedence table below includes these operator-like entities.</para>

          <para>Operator groups higher in the list have higher precedence; operators in the same row
          have the same precedence:<informaltable>
              <tgroup align="left" cols="3">
                <thead>
                  <row>
                    <entry>Operator (or operator-like entity)</entry>

                    <entry>Description</entry>

                    <entry>Associativity</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><function role="operator">.</function></entry>

                    <entry>Record or data constructor field selection</entry>

                    <entry>Left-associative</entry>
                  </row>

                  <row>
                    <entry><function role="operator">`function` #</function></entry>

                    <entry>Backquoted-function operator, function composition</entry>

                    <entry>Left-associative (<function role="operator">`function`</function>),
                    Right-associative (<function role="operator">#</function>)</entry>
                  </row>

                  <row>
                    <entry><function role="operator">-</function></entry>

                    <entry>Unary negation</entry>

                    <entry>Non-associative</entry>
                  </row>

                  <row>
                    <entry><function role="operator">* / %</function></entry>

                    <entry>Multiplication, division, remainder</entry>

                    <entry>Left-associative</entry>
                  </row>

                  <row>
                    <entry><function role="operator">+ -</function></entry>

                    <entry>Addition, subtraction</entry>

                    <entry>Left-associative</entry>
                  </row>

                  <row>
                    <entry><function role="operator">: ++</function></entry>

                    <entry>List construction, list appending</entry>

                    <entry>Right-associative</entry>
                  </row>

                  <row>
                    <entry><function role="operator">&lt; &lt;= == != &gt;= &gt;</function></entry>

                    <entry>Comparison operators</entry>

                    <entry>Non-associative</entry>
                  </row>

                  <row>
                    <entry><function role="operator">&amp;&amp;</function></entry>

                    <entry>Boolean AND</entry>

                    <entry>Right-associative</entry>
                  </row>

                  <row>
                    <entry><function role="operator">||</function></entry>

                    <entry>Boolean OR</entry>

                    <entry>Right-associative</entry>
                  </row>

                  <row>
                    <entry><function role="operator">$</function></entry>

                    <entry>Function application</entry>

                    <entry>Right-associative</entry>
                  </row>

                  <row>
                    <entry><function role="operator">::</function></entry>

                    <entry>Type signature</entry>

                    <entry>Non-associative</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>

          <para>Operators that have the same precedence are grouped in an expression on the basis of
          their associativity. Associativity in this context refers to whether the operators on the
          right are evaluated first, or those on the left. For example, consider the case of
          multiple divisions:<informalexample>
              <para><code>30.0 / 20.0 / 10.0</code></para>
            </informalexample></para>

          <para>Without using associativity, this expression is ambiguous; it can be interpreted as
          either <code>30 / (20.0 / 10.0)</code>, in which case its value is <code>15.0</code>, or
          as <code>(30.0 / 20.0) / 10.0</code>, in which case its value is <code>0.15</code>. The
          first case is a right-associative grouping, whereas the second is a left-associative
          grouping. In CAL, the division operator is left-associative, so the expression above will
          evaluate to <code>0.15</code>.</para>

          <para>The precedence table above includes the associativity of each group of
          operators.</para>

          <para>Note that the backquoted-function operator and the function composition operator are
          at the same precedence level, but they differ in associativity. This means that they
          cannot be used together in a single infix expression. For example, expressions of the
          forms<informalexample>
              <para><code>a `b` c # d</code></para>
            </informalexample>and<informalexample>
              <para><code>a # b `c` d</code></para>
            </informalexample>are syntactically invalid in CAL.</para>
        </section>

        <section>
          <title>Operators for function composition (# and $)</title>

          <para>In CAL, the function composition operator (<function role="operator">#</function>)
          can be used to compose two functions using an infix operator expression. For example, the
          expression:<informalexample>
              <para><code>List.filter (not # isEmpty) listOfLists</code></para>
            </informalexample>returns a list of the non-empty elements in the list
          <parameter>listOfLists</parameter> by using the predicate <code>(not # isEmpty)</code>, a
          composed function. This operator is right-associative, and so the
          expression:<informalexample>
              <para><code>(f # g # h) x</code></para>
            </informalexample>is equivalent to:<informalexample>
              <para><code>(f # (g # h)) x</code></para>
            </informalexample>and is thus also equivalent to:<informalexample>
              <para><code>f (g (h x))</code></para>
            </informalexample></para>

          <para>While the function application operator (<function role="operator">$</function>) is
          defined simply as:<programlisting>f $ x = f x</programlisting>its distinguishing feature
          is that it has a low precedence  lower than any other operator except the type signature
          operator (::). It can thus be used to construct nested expressions without parentheses.
          For example, while the expression:<literallayout><code>f x y z</code></literallayout>applies
          the function f to the arguments x, y and z, the expression:<literallayout><code>f x $ y z</code></literallayout>is
          equivalent semantically to the expression:<literallayout><code>f x (y z)</code></literallayout>which
          applies the function f to the arguments <parameter>x</parameter> and <parameter>(y
          z)</parameter>.</para>

          <para>The function application operator is often employed idiomatically to chain a
          sequence of function applications together. For example, rather than
          writing:<literallayout><code>toJIterator (map fromJust (filter isJust (reverse list)))</code></literallayout>one
          can write:<literallayout><code>toJIterator $ map fromJust $ filter isJust $ reverse list</code></literallayout></para>

          <para>Incidentally, the above is semantically equivalent to:<literallayout><code>(toJIterator # map fromJust # filter isJust) (reverse list)</code></literallayout>and
          is thus also equivalent to:<literallayout><code>toJIterator # map fromJust # filter isJust $ reverse list</code></literallayout></para>
        </section>

        <section>
          <title>Backquoted functions</title>

          <para>The usual way to apply functions is in prefix order:<informalexample>
              <para><code>subscript (subscript listOfLists 3) 5</code></para>
            </informalexample></para>

          <para>However, in some circumstances (such as when chaining several calls together), it
          can be more clear to write a function application in infix order. CAL allows you to apply
          any function of two or more arguments using infix notation by surrounding the function
          name in backquotes (<function role="operator">`</function>). For example, the following is
          equivalent to the expression above:<informalexample>
              <para><code>listOfLists `subscript` 3 `subscript` 5</code></para>
            </informalexample></para>

          <para>Note that the backquoted function must accept no fewer than two arguments. However,
          it may accept more. In the case where it accepts more than two arguments, the result is a
          partial application:<informalexample>
              <literallayout><userinput>:t ['a'] `zip3` ['b']</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[a] -&gt; [(Char, Char, a)]</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>(['a'] `zip3` ['b']) ['c']</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[('a', 'b', 'c')]</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>1.0 `negate` 2.0</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type Error during an application. Caused by: Type clash: 
type constructor Prelude.Double does not match Prelude.Function.</computeroutput></literallayout>
            </informalexample></para>

          <para>The third expression fails because negate accepts only one argument.</para>
        </section>
      </section>

      <section>
        <title>If expressions</title>

        <para>An if expression takes one of two different values depending on the boolean value of a
        test expression. It has the form<synopsis>if <replaceable>condition_expression</replaceable> then 
    <replaceable>if_true_expression</replaceable> 
else 
    <replaceable>if_false_expression</replaceable></synopsis></para>

        <para>If <replaceable>condition_expression</replaceable> evaluates to
        <function>True</function>, then the value of the <code>if</code> expression is
        <replaceable>if_true_expression</replaceable>. Otherwise, it is the value of
        <replaceable>if_false_expression</replaceable>. Note that the <code>else</code> clause is
        not optional. Ex:<informalexample>
            <programlisting>if x &gt; 0 then
    "positive"
else
    "negative or zero"</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>Case expressions</title>

        <para>Case expressions provide a means to select from a variety of alternative expressions
        depending upon the value of a test expression. They are often used for extracting components
        of compound data structures such as fields, lists, tuples, or members of algebraic
        types.</para>

        <para>A case expression consists of a specification of the expression to test followed by a
        list of alternatives. An alternative consists of a pattern to match followed by a right
        arrow (<function role="operator">-&gt;</function>) followed by an expression whose body will
        provide the value of the case expression if the alternative is selected. Variables in the
        pattern are bound in the corresponding expression. <synopsis>case <replaceable>condition_expression</replaceable> of
<replaceable>pattern</replaceable> -&gt; <replaceable>expression1</replaceable> ;
[<replaceable>pattern</replaceable> -&gt; <replaceable>expression2</replaceable> ; ... ]</synopsis></para>

        <para>Ex:<informalexample>
            <programlisting>myListSubscript :: [a] -&gt; Int -&gt; a;
public myListSubscript !list !index =
    case list of
    x : xs -&gt; 
        if index == 0 then 
            x
        else if index &gt; 0 then 
            myListSubscript xs (index - 1)
        else 
            error "negative index.";
    [] -&gt; 
        error "index out of bounds.";
    ;
</programlisting>
          </informalexample>With <function>myListSubscript</function> defined as
        above:<informalexample>
            <para><literallayout><userinput>myListSubscript ['a', 'q', 'b'] 0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>'a'</computeroutput></literallayout></para>
          </informalexample><informalexample>
            <literallayout><userinput>myListSubscript ['a', 'q', 'b'] 2</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>'b'</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>myListSubscript ['a', 'q', 'b'] 3</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>index out of bounds.</computeroutput></literallayout>
          </informalexample></para>

        <para>Often, one doesn't care about the value of each component that a pattern matches. In
        these situations, it is possible to use the underscore character as a wildcard identifier.
        The following two examples are equivalent, except that the second does not make an
        unnecessary binding of the first list element:<informalexample>
            <programlisting>length1 :: [a] -&gt; Int;
public length1 !list =
    let
        lengthHelper !list !acc = 
            case list of
            first : rest -&gt; lengthHelper rest (acc + 1);
            [] -&gt; acc;
            ;
    in
        lengthHelper list 0;</programlisting>
          </informalexample><informalexample>
            <programlisting>length2 :: [a] -&gt; Int;
public length2 !list =
    let
        lengthHelper !list !acc = 
            case list of
            _ : rest -&gt; lengthHelper rest (acc + 1);
            [] -&gt; acc;
            ;
    in
        lengthHelper list 0;</programlisting>
          </informalexample>So with <function>length1</function> and <function>length2</function>
        defined as above:<informalexample>
            <literallayout><userinput>length1 ['x', 'y', 'z', 'a', 'b']</userinput>
<emphasis role="bold-italic">returns</emphasis> 5</literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>length2 ['x', 'y', 'z', 'a', 'b']</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>5</computeroutput></literallayout>
          </informalexample></para>

        <section>
          <title>Matching lists</title>

          <para>There are two forms of pattern for matching lists:<informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><synopsis>[]</synopsis></entry>

                    <entry>Matches an empty list</entry>
                  </row>

                  <row>
                    <entry><synopsis>headPattern : tailPattern</synopsis></entry>

                    <entry>Matches a non-empty list</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>

          <para>The first form matches empty lists. The second form matches any non-empty list. It
          binds the first pattern to the head of the list (i.e., the first element), and the second
          pattern to the tail of the list (i.e., a list containing all of the elements of the
          original list except the first).</para>

          <para><informalexample>
              <programlisting>extractTail :: [a] -&gt; [a];
public extractTail list =
    case list of
    [] -&gt; error "empty lists have no tail";
    x : y -&gt; y;
    ;</programlisting>
            </informalexample></para>

          <para>If extractTail is defined as above, then:<informalexample>
              <literallayout><userinput>extractTail []</userinput>
<emphasis role="bold-italic"><computeroutput>Error:</computeroutput></emphasis> <computeroutput>empty lists have no tail</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>extractTail ['a']</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[]</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>extractTail ['a', 'b']</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>['b']</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>extractTail ['a', 'b', 'c']</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>['b', 'c']</computeroutput></literallayout>
            </informalexample></para>
        </section>

        <section>
          <title xml:id="MatchingTuples">Matching tuples</title>

          <para>There is one specialized form of pattern for matching tuples. To match a pair,
          enclose two patterns separated by a comma in parentheses. To match an n-tuple, enclose n
          patterns separated by commas in parentheses:<informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><synopsis>(a, b)</synopsis></entry>

                    <entry>Matches a pair</entry>
                  </row>

                  <row>
                    <entry><synopsis>(a, b, c)</synopsis></entry>

                    <entry>Matches a triple</entry>
                  </row>

                  <row>
                    <entry><synopsis>(x, y, z, w)</synopsis></entry>

                    <entry>Matches a 4-tuple</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>

          <para>Ex:<informalexample>
              <programlisting>public vectorLength vector =
    case vector of
    (x, y) -&gt; Math.sqrt (x * x + y * y);
    ;</programlisting>
            </informalexample></para>

          <para>With vectorLength defined as above,<informalexample>
              <literallayout><userinput>vectorLength (3.0, 4.0)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>5.0</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>vectorLength 3.0 4.0</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type Error during an application. Caused by: Type clash: 
type constructor Prelude.Double does not match Prelude.Function</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>vectorLength (5, 12)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>13.0</computeroutput></literallayout>
            </informalexample></para>

          <para>The second expression raises an error, because <function>vectorLength</function>
          accepts a single 2-tuple, not two non-tuple values.</para>

          <para>Interestingly, the third expression does not raise an error even though we use an
          ambiguous form of numeric literal. This is because the <function>sqrt</function> function
          has the type <type>Double -&gt; Double</type>, so the type inferencer knows that its
          argument must be a <type>Double</type>. From this information, it can work back to deduce
          that the two components of the 2-tuple argument to <function>vectorLength</function> must
          also be <type>Double</type>s.</para>

          <para>Note that a case expression that matches tuples can contain only a single
          alternative.</para>
        </section>

        <section>
          <title xml:id="MatchingRecords">Matching records</title>

          <para>There are three forms of pattern for matching records:<synopsis>{}</synopsis><synopsis>{field_name1 [= pattern1] [, field_name2 [= pattern2] ...]}</synopsis><synopsis>{ pattern0 | field_name1 [= pattern1] [, field_name2 [= pattern2] ...]}</synopsis>The
          first form matches empty records only. The following function will signal an error if it
          is called with anything other than an empty record:<informalexample>
              <programlisting>emptyRecordOnly :: {} -&gt; String;
emptyRecordOnly record =
    case record of
    {} -&gt; "empty record";
    ;</programlisting>
            </informalexample></para>

          <para>The second form matches a record that contains exactly the specified fields. The
          following function will signal an error if it is called with anything other than a record
          that contains a name field, an age field, and nothing else:<informalexample>
              <programlisting>showNameAgeRecord :: {name :: String, age :: Double} -&gt; String;
showNameAgeRecord record =
    case record of
    {name = nameValue, age = ageValue} -&gt; 
        concat ["Name =", nameValue, ". Age =", doubleToString ageValue];
    ;</programlisting>
            </informalexample></para>

          <para>In the above example, the values of the <varname>name</varname> and
          <varname>age</varname> fields are bound to <parameter>nameValue</parameter> and
          <parameter>ageValue</parameter> respectively. However, it is not necessary to specify a
          new name for fields. If the new name is omitted, then the field will be bound to its own
          name. For example, the following definition of <function>showNameAgeRecord</function> is
          equivalent to the above definition:<informalexample>
              <programlisting>showNameAgeRecord :: {name :: String, age :: Double} -&gt; String;
showNameAgeRecord record =
    case record of
    {name, age} -&gt; 
        concat ["Name =", name, ". Age =", doubleToString age];
    ;</programlisting>
            </informalexample></para>

          <para>The values of the fields are bound to their own names in this version. This
          technique is known as "punning". Punning is forbidden for ordinal fields. You must always
          specify a new name for ordinal fields of a record if you wish to unpackage them using a
          case expression. In the following example, we bind the fields of the first record to
          <varname>name1</varname> and <varname>age1</varname> and the fields of the second record
          to <varname>name2</varname> and <varname>age2</varname>. This allows us to access the
          fields of both records at the same time. If we had used punning (i.e., had not provided
          new names for the fields), then the binding for the <varname>name</varname> field of
          <varname>record2</varname> would have masked the binding for the <varname>name</varname>
          field of <varname>record1</varname>.<informalexample>
              <programlisting>equalsNameAgeRecord :: {name :: String, age :: Double} -&gt; {name :: String, age :: Double} -&gt; Boolean;
equalsNameAgeRecord record1 record2 =
    case record1 of
    {name = name1, age = age1} -&gt;
        case record2 of
        {name = name2, age = age2} -&gt;
            name1 == name2 &amp;&amp; age1 == age2;
        ;
    ;</programlisting>
            </informalexample></para>

          <para>With <function>equalsNameAgeRecord</function> defined as above:<informalexample>
              <literallayout><userinput>equalsNameAgeRecord {name = "Matt", age = 54} {age = 54, name = "Matt"}</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>equalsNameAgeRecord {name = "Jack", age = 54.0, profession = 
"blacksmith"} {name = "Jack", age = 54.0, profession = "blacksmith"}</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type Error during an application. Caused by: the fields of 
the two record type {age :: Prelude.Double, name :: Prelude.String} 
and {age :: Prelude.Double, name :: Prelude.String, profession :: 
Prelude.String} must match exactly.
</computeroutput></literallayout>
            </informalexample></para>

          <para>Note that the first expression returns <function>True</function> even though the
          fields are in different orders. The second expression signals an error because we have
          passed in records that have too many fields.</para>

          <para>It is possible for a single record pattern to bind some fields to new names and
          other fields to punned names:<informalexample>
              <programlisting>normalizeVectorRecord :: {#1 :: Double, #2 :: Double, isNormalized :: Boolean} -&gt; {#1 :: Double, #2 :: Double, isNormalized :: Boolean};
normalizeVectorRecord vector =
    case vector of
    {#1 = x, #2 = y, isNormalized} -&gt;
        if isNormalized then
            vector
        else
            let
                length :: Double;
                length = vectorLength (x, y);
            in
                {#1 = x / length, #2 = y / length, isNormalized = True};
    ;</programlisting>
            </informalexample></para>

          <para>In the example above, we bind the ordinal fields <varname>#1</varname> and
          <varname>#2</varname> to the names <varname>x</varname> and <varname>y</varname>
          respectively. <function>isNormalized</function> is bound to its own name. With
          <function>normalizeVectorRecord</function> defined as above:<informalexample>
              <literallayout><userinput>normalizeVectorRecord {#1 = 3.0, #2 = 4.0, isNormalized = False}</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>{#1 = 0.6, #2 = 0.8, isNormalized = True}</computeroutput></literallayout>
            </informalexample></para>

          <para>The final form matches records that contain <emphasis>at least</emphasis> the
          specified fields:<informalexample>
              <programlisting>extractJob :: r\job =&gt; {r | job :: a} -&gt; a;
extractJob record =
    case record of
    {rest | job = jobValue} -&gt; jobValue;
    ;</programlisting>
            </informalexample></para>

          <para>In the example above, the <varname>job</varname> field of <varname>record</varname>
          is bound to the name <varname>jobValue</varname>. A record containing all of the fields of
          <varname>record</varname> except for <varname>job</varname> is bound to the name
          <varname>rest</varname>. This record is referred to as the "base record". Note that the
          type of the base record (in the type signature) has a constraint. The constraint specifies
          that the type <type>r</type> does not have a field named <varname>job</varname>. This kind
          of constraint is referred to as a lacks constraint; see <xref
          linkend="LacksConstraints" /> for details. Punned names are permitted for both forms of
          non-empty record matching. In addition, any name pattern may be the wildcard name
          "<literal>_</literal>" (underscore) for fields that you don't want to access. The
          following definition of <function>extractJob</function> is equivalent to the above
          definition:<informalexample>
              <programlisting>extractJob :: r\job =&gt; {r | job :: a} -&gt; a;
extractJob record =
    case record of
    {_ | job } -&gt; job;
    ;</programlisting>
            </informalexample></para>

          <para>In this version, the <varname>job</varname> field is bound to the name
          <varname>job</varname>, and the base record is not bound to any name (since we don't refer
          to it).</para>

          <para>With <function>extractJob</function> defined as above (either
          definition):<informalexample>
              <literallayout><userinput>extractJob {job = "pilot"}</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"pilot"</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>extractJob {job = "telephone sanitizer", location = (3.0, 1.2)}</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"telephone sanitizer"</computeroutput></literallayout>
            </informalexample></para>

          <para>The additional field (<varname>location</varname>) is ignored in the second call,
          because <function>extractJob</function> does not make use of the base record.</para>

          <para>The following function does make use of the base record: <programlisting>removeJob :: r\job =&gt; {r | job :: String} -&gt; r;
removeJob record =
    case record of
    {rest | job = _} -&gt; rest;
    ;</programlisting></para>

          <para>With <function>removeJob</function> defined as above:<informalexample>
              <literallayout><userinput>removeJob {name = "Ford", job = "hitchhiker", age = 32.0, location = 
"Earth"}</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>{name = "Ford", age = 32.0, location = "Earth"}</computeroutput></literallayout>
            </informalexample></para>

          <para>Note that a case expression that matches records can contain only a single
          alternative.</para>
        </section>

        <section>
          <title xml:id="MatchingDataConstructors">Matching data constructors</title>

          <para>(See <xref linkend="TypeDefinitions" /> for an explanation of algebraic types and
          data constructors.)</para>

          <para>There are three forms of pattern for matching data constructors:<synopsis><replaceable>constructor_name</replaceable> [<replaceable>identifier</replaceable> [<replaceable>identifier</replaceable> ...]...]</synopsis><synopsis><replaceable>constructor_name</replaceable> {[<replaceable>field_name1</replaceable> [, <replaceable>field_name2</replaceable> ...]]}</synopsis><synopsis><replaceable>constructor_name</replaceable> {<replaceable>field_name1</replaceable> = <replaceable>identifier1</replaceable> [, <replaceable>field_name2</replaceable> = <replaceable>identifier2</replaceable> ...]}</synopsis></para>

          <para>The first form binds identifiers to constructor arguments in the order they appear
          in the declaration. i.e. the first identifier is bound to the first argument, the second
          identifier is bound to the second argument, etc. All arguments must be bound -- the number
          of identifiers must be equal to the number arguments to the data constructor. Each
          <replaceable>identifier</replaceable> may be the wildcard name "<literal>_</literal>"
          (underscore) for fields that you don't want to access.</para>

          <para>The second form matches a data constructor containing <emphasis>at least</emphasis>
          the specified fields; the field name identifiers are bound to the corresponding fields'
          values. The third form matches a data constructor containing <emphasis>at least</emphasis>
          the specified fields; each provided identifier is matched to the values of the
          corresponding field.</para>

          <para>Ex:<informalexample>
              <programlisting>data public MyTuple a b =
    public MyTuple
        field1 :: a
        field2 :: b;
public myFst1 myTuple =
    case myTuple of
    MyTuple elem1 elem2 -&gt; elem1;
    ;
public myFst2 myTuple =
    case myTuple of
    MyTuple elem _ -&gt; elem; 
    ;
public myFst3 myTuple =
    case myTuple of
    MyTuple {field1} -&gt; field1; 
    ;
public myFst4 myTuple =
    case myTuple of
    MyTuple {field1=elem} -&gt; elem; 
    ;</programlisting>
            </informalexample></para>

          <para>The above <function>myFst</function> functions extract the value of the
          <varname>field1</varname> argument from a <type>MyTuple</type> data value.</para>

          <para><informalexample>
              <literallayout><userinput>myFst1 (MyTuple 2.0 "String")</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>2.0</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>myFst3 (MyTuple Nothing 2.0)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Nothing</computeroutput></literallayout>
            </informalexample></para>
        </section>

        <section>
          <title>Matching groups of data constructors</title>

          <para>It is reasonably common for several case alternatives to have the same right hand
          side code. In this situation, the alternatives may be grouped.</para>

          <para>As with matching data constructors, there are three forms of pattern for matching
          groups of data constructors:<synopsis>(<replaceable>constructor_name1</replaceable> [| <replaceable>constructor_name2</replaceable> ...]) [<replaceable>identifier</replaceable> [<replaceable>identifier</replaceable> ...]...]</synopsis><synopsis>(<replaceable>constructor_name1</replaceable> [| <replaceable>constructor_name2</replaceable> ...]) {[<replaceable>field_name1</replaceable> [, <replaceable>field_name2</replaceable> ...]]}</synopsis><synopsis>(<replaceable>constructor_name1</replaceable> [| <replaceable>constructor_name2</replaceable> ...]) {<replaceable>field_name1</replaceable> = <replaceable>identifier1</replaceable> [, <replaceable>field_name2</replaceable> = <replaceable>identifier2</replaceable> ...]}</synopsis></para>

          <para>The treatment of these is similar to the treatments of the corresponding forms in
          matching of individual data constructors. The first form binds identifiers to each
          constructor's arguments in the order they appear in the declaration. i.e. the first
          identifier is bound to the first argument, the second identifier is bound to the second
          argument, etc. All arguments must be bound -- the number of identifiers must be equal to
          the number arguments to each data constructor. Each <replaceable>identifier</replaceable>
          may be the wildcard name "<literal>_</literal>" (underscore) for fields that you don't
          want to access.</para>

          <para>The second form matches data constructors containing <replaceable>at
          least</replaceable> the specified fields; the field name identifiers are bound to the
          corresponding fields' values. The third form matches data constructors containing
          <replaceable>at least</replaceable> the specified fields; each provided identifier is
          matched to the values of the corresponding field.</para>

          <para>Ex:<informalexample>
              <programlisting>data public MyPairOrTriple a b c =
    public MyPair
        field1 :: a
        field2 :: b |
    public MyDifferentPair
        elem1  :: a
        elem2  :: b |
    public MyTriple
        field1 :: a
        field2 :: b
        field3 :: c;
public myFirstElem myPairOrTriple =
    case myPairOrTriple of
    (MyPair | MyDifferentPair) elem _ -&gt; elem;
    MyTriple elem _ _ -&gt; elem; 
    ;    
public myField1 myPairOrTriple =
    case myPairOrTriple of
    (MyPair | MyTriple) {field1} -&gt; field1;
    MyDifferentPair {elem1} -&gt; elem1;
    ;</programlisting>
            </informalexample></para>

          <para>The above functions extract the value of the first argument from various
          <function>MyPairOrTriple</function> data values.</para>

          <para><informalexample>
              <literallayout><userinput>myFirstElem (MyPair 2.0 "Str")</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>2.0</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>myField1 (MyTriple Nothing 2.0 "three")</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Nothing</computeroutput></literallayout>
            </informalexample></para>
        </section>

        <section>
          <title>Matching Int values</title>

          <para>There are two forms of pattern for matching values of type <type>Int</type>:
          <synopsis><replaceable>intValue</replaceable></synopsis><synopsis>(<replaceable>intValue1</replaceable> [| <replaceable>intValue2</replaceable> ...])</synopsis></para>

          <para>The first form matches a single Int value. The second form matches one or more Int
          values.</para>

          <para>Ex:<informalexample>
              <programlisting>public isOneOrTwoOrMinusThree intVal =
    case intVal of
    1 -&gt; True;
    (2 | -3) -&gt; True;
    _ -&gt; False;
    ;</programlisting>
            </informalexample></para>

          <para>With <function>isOneOrTwoOrMinusThree</function> defined as above,<informalexample>
              <literallayout><userinput>isOneOrTwoOrMinusThree 1</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>isOneOrTwoOrMinusThree 4</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput></literallayout>
            </informalexample></para>

          <para>Note that the pattern value is a numeric literal which is always interpreted as
          having type <type>Int</type>, rather than an ambiguous numeric type. As such, the value
          must fall within the constraints of the <type>Int</type> type.</para>

          <para>For example, the following is invalid because the numeral is out of
          range:<informalexample>
              <programlisting>public isBigNum intVal =
    case intVal of
    2147483647 -&gt; True;
    _ -&gt; False;
    ;</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title>Matching Char values</title>

          <para>There are two forms of pattern for matching values of type
          <type>Char</type>:<synopsis><replaceable>charValue</replaceable></synopsis><synopsis>(<replaceable>charValue1</replaceable> [| <replaceable>charValue2</replaceable> ...])</synopsis></para>

          <para>The first form matches a single <type>Char</type> value. The second form matches one
          or more <type>Char</type> values.</para>

          <para>Ex:<informalexample>
              <programlisting>public isAorBorC charVal =
    case charVal of
    'a' -&gt; True;
    ('b' | 'c') -&gt; True;
    _ -&gt; False;
    ;</programlisting>
            </informalexample></para>

          <para>With <function>isAorBorC</function> defined as above,<informalexample>
              <literallayout><userinput>isAorBorC 'a'</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>isAorBorC 'd'</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput></literallayout>
            </informalexample></para>

          <para>Note that the pattern value is of type <type>Char</type>, and so may be expressed
          using the various <type>Char</type> escape sequences.</para>

          <para>For example, the following all test for a percent symbol:<informalexample>
              <programlisting>public isPercent1 charVal =
    case charVal of
    '%' -&gt; True;
    _ -&gt; False;
    ;
public isPercent2 charVal =
    case charVal of
    '\045' -&gt; True;
    _ -&gt; False;
    ;
public isPercent3 charVal =
    case charVal of
    '\u0025' -&gt; True;
    _ -&gt; False;
    ;</programlisting>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title>Data constructor field selection</title>

        <para>If an algebraic value is known to be a specific data constructor value, data
        constructor field selection may be used to access the value of that field more directly than
        using a case expression. It has the form: <synopsis><replaceable>expression</replaceable>.<replaceable>constructor_name</replaceable>.<replaceable>field_name</replaceable></synopsis></para>

        <para>Ex:<informalexample>
            <literallayout><userinput>(Just 2.0).Just.value     // The arg to Just is named value'</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>2.0</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>(Just 2.0).Prelude.Just.value    // a qualified name is allowed </userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>2.0</computeroutput></literallayout>
          </informalexample></para>

        <para>If the wrong data constructor is encountered during field selection, a runtime error
        occurs:<informalexample>
            <literallayout><userinput>(Nothing :: Maybe Double).Just.value</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Wrong data constructor value selected. Expecting: 
Prelude.Just, found: Prelude.Nothing.</computeroutput></literallayout>
          </informalexample></para>
      </section>

      <section>
        <title>Let expressions</title>

        <para>A let expression provides a way to introduce definitions which are local to a
        particular expression. It has the form: <synopsis>let
    <replaceable>local_definition</replaceable> ;
    [<replaceable>local_definition</replaceable> ; ...]
in
    <replaceable>expression</replaceable></synopsis> A local_definition can take on one of three
        forms:<itemizedlist>
            <listitem>
              <para>A local function definition:<synopsis><replaceable>name</replaceable> [<replaceable>param1_name</replaceable> [<replaceable>param2_name</replaceable> ...]] = <replaceable>expression</replaceable> ;</synopsis></para>
            </listitem>

            <listitem>
              <para>A local pattern match declaration:<synopsis><replaceable>pattern</replaceable> = <replaceable>expression</replaceable> ;</synopsis></para>
            </listitem>

            <listitem>
              <para>A local type declaration:<synopsis><replaceable>name</replaceable> :: <replaceable>type</replaceable> ;</synopsis></para>
            </listitem>
          </itemizedlist></para>

        <para>There must be at least one local function definition or one local pattern match
        declaration in a let expression. The value of the let expression is the value of the
        expression in the body (i.e., the expression that follows "<code>in</code>").</para>

        <section>
          <title>Local function definitions</title>

          <para>A local function definition introduces a function that is local to the let
          expression, and which may have zero or more parameters. For example:<informalexample>
              <programlisting>maxSquared :: Int -&gt; Int -&gt; Int;
public maxSquared a b =
    let
        aSquared = square a;
        bSquared = square b;

        square x = x * x;
    in
        if aSquared &gt; bSquared then aSquared else bSquared;</programlisting>
            </informalexample></para>

          <para>In the let expression above, three local functions are defined:
          <function>aSquared</function>, <function>bSquared</function>, and
          <function>square</function>. Note that variables such as <varname>aSquared</varname> and
          <varname>bSquared</varname>, which are declared without parameters, are considered to be
          local functions.</para>
        </section>

        <section>
          <title>Local pattern match declarations</title>

          <para>A local pattern match declaration allows one to bind one or more variables to the
          fields of a data constructor or a record using a single declaration. Such a declaration
          has a form:<synopsis><replaceable>pattern</replaceable> = <replaceable>expression</replaceable> ;</synopsis>where
          pattern can have one of the following forms:<itemizedlist>
              <listitem>
                <para>Data constructor patterns:<synopsis><replaceable>constructor_name</replaceable> [<replaceable>name_or_wildcard</replaceable> [<replaceable>name_or_wildcard</replaceable> ...] ...]</synopsis>or
                alternatively:<synopsis><replaceable>constructor_name</replaceable> {<replaceable>field_name1</replaceable> [= <replaceable>name_or_wildcard</replaceable>] [, <replaceable>field_name2</replaceable> [= <replaceable>name_or_wildcard</replaceable>] ...]}</synopsis></para>
              </listitem>

              <listitem>
                <para>List constructor patterns:<synopsis><replaceable>name_or_wildcard</replaceable> : <replaceable>name_or_wildcard</replaceable></synopsis></para>
              </listitem>

              <listitem>
                <para>Tuple patterns:<synopsis>(<replaceable>name_or_wildcard</replaceable>, <replaceable>name_or_wildcard</replaceable> [, <replaceable>name_or_wildcard</replaceable> ...])</synopsis></para>
              </listitem>

              <listitem>
                <para>Record patterns:</para>

                <para><emphasis>Non-polymorphic record patterns:</emphasis><synopsis>{<replaceable>field_name1</replaceable> [= <replaceable>name_or_wildcard</replaceable>] [, <replaceable>field_name2</replaceable> [= <replaceable>name_or_wildcard</replaceable>] ...]}</synopsis></para>

                <para><emphasis>Polymorphic record patterns:</emphasis><synopsis>{_ | <replaceable>field_name1</replaceable> [= <replaceable>name_or_wildcard</replaceable>] [, <replaceable>field_name2</replaceable> [= <replaceable>name_or_wildcard</replaceable>] ...]}</synopsis></para>
              </listitem>
            </itemizedlist></para>

          <para>In each of the above forms, <replaceable>name_or_wildcard</replaceable> can be
          either a variable or the wildcard pattern "<literal>_</literal>". Each variable appearing
          in the pattern is bound to the corresponding field of the expression on the right hand
          side.</para>

          <section>
            <title>Data constructor and list constructor patterns</title>

            <para>Here is an example of a data constructor pattern:<informalexample>
                <programlisting>let
    Cons {head, tail=t} = [1.0, 2.0, -3.0];
in
    (head, t)
returns (1.0, [2.0, -3.0])</programlisting>
              </informalexample></para>

            <para>In the above, the two fields of the <function>Prelude.Cons</function> data
            constructor <varname>head</varname> and <varname>tail</varname> are bound to the
            variables <varname>head</varname> and tail respectively (the first field is a punned
            pattern, see <xref linkend="MatchingDataConstructors" xml:lang="" /> for details). This
            let expression can also be written using the positional syntax for field
            bindings:<informalexample>
                <programlisting>let
    Cons x y = [1.0, 2.0, -3.0];
in
    (x, y)</programlisting>
              </informalexample></para>

            <para>There is also a special syntax for pattern matching the
            <varname>Prelude.Cons</varname> data constructor with the list constructor
            pattern:<informalexample>
                <programlisting>let
    x:y = [1.0, 2.0, -3.0];
in
    (x, y)</programlisting>
              </informalexample></para>
          </section>

          <section>
            <title>Record and tuple patterns</title>

            <para>Here is an example of a record pattern:<informalexample>
                <literallayout><userinput>let
    {country} = {country="Canada"};
    {name=_, addr=address} = {name="Zack", addr="123 Some St."};
in
    (country, address)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>("Canada", "123 Some St.")</computeroutput></literallayout>
              </informalexample></para>

            <para>The first declaration introduces the pattern-bound variable country, which is also
            the field being matched (this is a <firstterm>punned</firstterm> pattern, see <xref
            linkend="MatchingRecords" /> for details on punning). The second declaration uses the
            wildcard pattern to drop the <varname>name</varname> field, while binding the
            <varname>addr</varname> field to a variable called <varname>address</varname>.</para>

            <para>Note that the left hand side must specify <emphasis>all</emphasis> the fields of
            the record type for the expression appearing on the right hand side. This is known as a
            <firstterm>non-polymorphic</firstterm> record pattern. This contrasts with a
            <firstterm>polymorphic</firstterm> record pattern, where this restriction is
            lifted:<informalexample>
                <literallayout><userinput>let
    {_ | #2=y} = (1.0, 2.0, 3.0); // no need to specify #1, #3
    {_ | a} = {a="foo", b="bar"}; // no need to specify b
in
    (a, y)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>("foo", 2.0)</computeroutput></literallayout>
              </informalexample></para>

            <para>While it is possible to use a record pattern to match against a tuple (since
            tuples are records), it is usually more succinct to use a tuple pattern. For
            example,<informalexample>
                <literallayout><userinput>let
    (x, y, z) = List.unzip3 [(1.0,0.0,0.0), (3,2,1), (6,5,4)];
in
    x ++ y ++ z</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[1.0, 3.0, 6.0, 0.0, 2.0, 5.0, 0.0, 1.0, 4.0]</computeroutput></literallayout>
              </informalexample></para>
          </section>

          <section>
            <title>Lazy pattern matching</title>

            <para>A major feature of the local pattern match declaration is its evaluation
            semantics: the expression on the right hand side is evaluated <emphasis>only when one of
            the pattern-bound variables is evaluated</emphasis>. In this sense, we can regard this
            as a form of <firstterm>lazy pattern matching</firstterm>.</para>

            <para>For example, if the expression on the right hand side does not evaluate to the
            same data constructor as specified in the pattern, a pattern match error will
            <emphasis>not</emphasis> occur unless one of the pattern-bound variables is evaluated.
            Thus, the following expression will produce an error:<informalexample>
                <literallayout><userinput>let
    Just {value} = Nothing;
in
    value :: String</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Wrong data constructor value selected. Expecting: 
Prelude.Just, found: Prelude.Nothing.</computeroutput></literallayout>
              </informalexample></para>

            <para>However, the following expressions are okay, because the pattern-bound variables
            are not evaluated:<informalexample>
                <literallayout><userinput>let
    Just {value} = Nothing;
in
    "Hello"</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"Hello"</computeroutput></literallayout>
              </informalexample><informalexample>
                <literallayout><userinput>let
    Just {value} = undefined;
in
    "World"</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"World"</computeroutput></literallayout>
              </informalexample></para>

            <para>The lazy evaluation semantics distinguishes this feature from case expressions,
            where the pattern match is attempted regardless of whether the unpacked values are
            needed. For example:<informalexample>
                <literallayout><userinput>case Nothing of
Just {value} -&gt; "Hello";</userinput><emphasis role="bold-italic">
Error:</emphasis> <computeroutput>Unhandled case for Prelude.Nothing.</computeroutput></literallayout>
              </informalexample><informalexample>
                <literallayout><userinput>case undefined of
Just {value} -&gt; "World";</userinput><emphasis role="bold-italic">
Error:</emphasis> <computeroutput>Prelude.undefined called.</computeroutput></literallayout>
              </informalexample></para>
          </section>
        </section>

        <section>
          <title>Local type declarations</title>

          <para>A local type declaration can be used to provide a type signature for a local
          function or a pattern-bound variable appearing in a local pattern match declaration (see
          <xref linkend="TypeDeclarations" /> for a description of type declarations). For example,
          the following let expression contains a type declaration for each of the locally defined
          variables <varname>x</varname>, <varname>y</varname>, <varname>z</varname> and
          <varname>square</varname>:<informalexample>
              <programlisting>public squareTriple triple =
    let
        x :: Double;
        y :: Double;
        z :: Double;
        (x, y, z) = triple;

        square :: Double -&gt; Double;
        square x = x*x; 
    in 
        (square x, square y, square z);</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title>Scope of local definitions</title>

          <para>Take the following function for example:<informalexample>
              <programlisting>public properFraction x =
    let 
        r :: Double;
        r = x - t;
        
        t :: Double;
        t = truncate x;
    in 
        (t, r);</programlisting>
            </informalexample></para>

          <para>In the above function, <varname>t</varname> and <varname>r</varname> are bound to
          the specified values within the let expression. In particular, a local definition is
          visible:<orderedlist>
              <listitem>
                <para>in its own defining expression (thus enabling recursive definitions),</para>
              </listitem>

              <listitem>
                <para>in the defining expressions of other local definitions in the same let
                expression, and</para>
              </listitem>

              <listitem>
                <para>in the body of the let expression, i.e. the expression that follows
                "<code>in</code>".</para>
              </listitem>
            </orderedlist></para>

          <para>If there are existing definitions for the two variables <varname>t</varname> and
          <varname>r</varname> outside the scope of the let expression, then they are
          <firstterm>shadowed</firstterm> by the local definitions. If the shadowed definitions are
          top-level definitions, then they can be accessed by using qualified names; otherwise,
          these shadowed definitions are inaccessible in the let expression. Other definitions that
          are not shadowed are available both within the local definitions of the let expression and
          within the body. Note also that, as with top-level definitions (see <xref
          linkend="StructureOfAModuleFile" />), the order of the various local definitions doesn't
          matter. In the above example, the definition of <varname>r</varname> refers to
          <varname>t</varname>, and it doesnt matter that <varname>t</varname> is defined after
          <varname>r</varname>.</para>
        </section>
      </section>

      <section>
        <title>Lambda expressions</title>

        <para>A lambda expression represents an anonymous function. It has the form: <synopsis>\<replaceable>arg1</replaceable> [<replaceable>arg2</replaceable> ...] -&gt; <replaceable>expression</replaceable></synopsis></para>

        <para>A lambda expression creates a function accepting the specified arguments without
        binding it to an identifier. This function can then be passed as an argument to other
        functions.</para>

        <para>Ex:<informalexample>
            <programlisting>doubleList :: [Double] -&gt; [Double];
public doubleList list =
    map (\x -&gt; x*2.0) list;</programlisting>
          </informalexample></para>

        <para>With the above definition of doubleList: <informalexample>
            <literallayout><userinput>doubleList [1.0, 8.0, 4.5]
</userinput><emphasis role="bold-italic">returns</emphasis> <computeroutput>[2.0, 16.0, 9.0]</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>doubleList []</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[]</computeroutput></literallayout>
          </informalexample></para>
      </section>
    </section>

    <section>
      <title>Types</title>

      <para>Every CAL value has a type. A type is a set of allowable values that a value of that
      type may be. For example, the <type>Integer</type> type contains all the negative and positive
      integers; the <type>Int</type> type contains all of the integers between
      <literal>-2147483648</literal> and <literal>2147483647</literal>; and the <type>Boolean</type>
      type contains only two values (<function>True</function> and
      <function>False</function>).</para>

      <para>CAL types fall into a number of categories: primitive types, function types, and
      algebraic types. In addition, it is possible to declare foreign types. Values of foreign types
      are opaque to CAL, and are generally operated upon using imported foreign functions.</para>

      <section>
        <title>Primitive types</title>

        <para>CAL contains a number of primitive types. The primitive types are:<informaltable>
            <tgroup align="left" cols="2">
              <thead>
                <row>
                  <entry>Type</entry>

                  <entry>Example value</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><type>Boolean</type></entry>

                  <entry><literal>True</literal>, <literal>False</literal></entry>
                </row>

                <row>
                  <entry><type>Char</type></entry>

                  <entry><literal>'C'</literal>, <literal>'\n'</literal>,
                  <literal>'1'</literal></entry>
                </row>

                <row>
                  <entry><type>Byte</type></entry>

                  <entry><literal>-12</literal>, <literal>98</literal></entry>
                </row>

                <row>
                  <entry><type>Short</type></entry>

                  <entry><literal>545</literal>, <literal>-12000</literal></entry>
                </row>

                <row>
                  <entry><type>Int</type></entry>

                  <entry><literal>55000</literal>, <literal>(-120000)</literal></entry>
                </row>

                <row>
                  <entry><type>Float</type></entry>

                  <entry><literal>19.9</literal>, <literal>1.2e6</literal></entry>
                </row>

                <row>
                  <entry><type>Double</type></entry>

                  <entry><literal>16.4</literal>, <literal>1.45e10</literal>,
                  <literal>0.004</literal></entry>
                </row>

                <row>
                  <entry><type>Long</type></entry>

                  <entry><literal>987000000000</literal></entry>
                </row>

                <row>
                  <entry><type>String</type></entry>

                  <entry><literal>"alpha"</literal>, <literal>"\t hdr1 \n"</literal></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>
      </section>

      <section>
        <title>Built-in types</title>

        <para>In addition to the primitive types, CAL has three built-in types with special
        syntactic support: lists, tuples, and records.</para>

        <section>
          <title>Lists</title>

          <para>A list is an ordered, variable-length sequence of values of the same type. List
          types are specified by enclosing the type of the elements in square brackets:<synopsis>[ <replaceable>type_name</replaceable> ]</synopsis></para>

          <para>For example:<informalexample>
              <literallayout><userinput>:t ["foo", "bar"]</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[String]</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>:t [1.0, 2.0, 3.0]</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[Double]</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>:t [(1::Integer), 7, 7, 5]</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[Integer]</computeroutput></literallayout>
            </informalexample></para>

          <para>Note that it is possible for a list's elements to have any type, including tuples,
          records, and other lists:<informalexample>
              <literallayout><userinput>:t [["foo 1", "foo 2"], [], ["bar", "baz"], ["quux"]]</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[[String]]</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>:t [("foo", (1::Integer)), ("bar", 2), ("bar", 1)]</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[(String, Integer)]</computeroutput></literallayout>
            </informalexample></para>
        </section>

        <section>
          <title>Tuples</title>

          <para>A tuple is an ordered, constant-size collection of values of possibly differing
          types. Tuple types are specified by enclosing a comma-separated list of the types of each
          component of the tuple in parentheses:<synopsis>( <replaceable>type_name</replaceable>, <replaceable>type_name</replaceable> [, <replaceable>type_name</replaceable> ...] )</synopsis></para>

          <para>For example:<informalexample>
              <literallayout><userinput>:t (55.1, 55.2)</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Double, Double)</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>:t (0.9, "foo", 'Z')</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Double, String, Char)</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>:t ('C', 'A', "baz", "qux")</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Char, Char, String, String)</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>:t ('m', ['a', 'c', 'b'])</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>(Char, [Char])</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>:t (["str1", "str2"], 'c', (2.2, 1.3))</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>([String], Char, (Double, Double))</computeroutput></literallayout>
            </informalexample></para>
        </section>

        <section>
          <title>Records</title>

          <para>A record is an unordered collection of named values of possibly differing type.
          Record types are specified by a list of field type specifications enclosed in braces.
          Field type specifications are a field name followed by a double-colon followed by the type
          of the field:<synopsis>{ <replaceable>field1_name</replaceable> :: <replaceable>field1_type</replaceable> [, <replaceable>field2_name</replaceable> :: <replaceable>field2_type</replaceable> ...] }</synopsis></para>

          <para>Ex:<informalexample>
              <literallayout><userinput>:t {name = "bill", job = "janitor", age = 25.0}</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>{age :: Double, job :: String, name :: String}</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>:t {x = 12.7, y = (-19.0)}</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>{x :: Double, y :: Double}</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>:t {a = "foo", #1 = 'N', #2 = 0.0, #3 = 1.0}</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>{#1 :: Char, #2 :: Double, #3 :: Double, a :: String}
</computeroutput></literallayout>
            </informalexample></para>
        </section>

        <section>
          <title>Type variables</title>

          <para>The example algebraic types given above are extremely specific. However, it is also
          possible to specify much more generic types through the use of a type variable. A type
          variable is an identifier that "stands in" for a type in a type declaration. For example,
          the type signature<informalexample>
              <para><type>(a, a)</type></para>
            </informalexample>represents the type of a pair where the two components are of the same
          type. Type variables are distinguished from type names by the case of their initial
          letter. Type names always start with an upper-case letter, whereas type variables always
          begin with a lower-case letter. It is customary to use type variables starting from the
          letter a and moving up the alphabet as further variables are needed. (e.g. if one needs
          three type variables for a type signature, one uses the variables <varname>a</varname>,
          <varname>b</varname>, and <varname>c</varname>).</para>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <thead>
                  <row>
                    <entry>Type signature</entry>

                    <entry>Matches</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><type>[a]</type></entry>

                    <entry>Any list of <type>a</type> (for some type <type>a</type>)</entry>
                  </row>

                  <row>
                    <entry><type>[[a]]</type></entry>

                    <entry>Any list of lists of <type>a</type></entry>
                  </row>

                  <row>
                    <entry><type>(a, b, c, d)</type></entry>

                    <entry>Any 4-tuple, each component of which may have a different type</entry>
                  </row>

                  <row>
                    <entry><type>(a, b, b)</type></entry>

                    <entry>Any 3-tuple whose last two components must be the same type, but whose
                    first component may be of a different type</entry>
                  </row>

                  <row>
                    <entry><type>(String, a)</type></entry>

                    <entry>Any pair whose first component is a <type>String</type></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>

          <para>Note that although the type variable can represent any type, it cannot represent two
          different types in the same type signature: So the signature <type>(a, a)</type> can match
          the type <type>(Int, Int)</type> or the type <type>(String, String)</type>, but never the
          type <type>(String, Int)</type>.</para>

          <para>We can define the function <function>appendList</function> as
          follows:<programlisting>appendList :: [a] -&gt; [a] -&gt; [a];
private appendList !list1 list2 =
    case list1 of
    []     -&gt; list2;
    head : rest -&gt; head : appendList rest list2;
    ;</programlisting></para>

          <para>Note that <function>appendList</function> takes two arguments of type
          <type>[a]</type>. Although <type>[a]</type> can match any list type, in any given call to
          <function>appendList</function>, all instances of <type>[a]</type> must match the same
          list type:<informalexample>
              <literallayout><userinput>appendList ['x', 'w', 'a'] ['b', 'c']</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>['x', 'w', 'a', 'b', 'c']</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>appendList [[1.0, 2.0], [1.0, 3.0]] [[3.1, 3.2]]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[[1.0, 2.0], [1.0, 3.0], [3.1, 3.2]]</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>appendList [1.0, 2.0, 3.0] ['a', 'b', 'c']</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type Error during an application. Caused by: Type clash: 
type constructor Prelude.Double does not match Prelude.Char.</computeroutput></literallayout>
            </informalexample></para>

          <para>The third expression above fails because we are attempting to pass two lists of two
          different types (i.e., we are trying to simultaneously match <type>[a]</type> to
          <type>[Double]</type> and <type>[Char]</type>).</para>
        </section>
      </section>

      <section>
        <title>Function types</title>

        <para>Functions are first-class values in CAL. That means that each function also belongs to
        a type. Function types are represented as an arrow-separated list of types. These types are
        the types of each of the parameters followed by the type of the return value:<synopsis><replaceable>param1_type</replaceable> [ -&gt; <replaceable>param2_type</replaceable> ...] -&gt; <replaceable>return_type</replaceable></synopsis>
        This is fairly straightforward to interpret for single-argument functions:<informaltable>
            <tgroup align="left" cols="2">
              <thead>
                <row>
                  <entry>Type</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><type>String -&gt; Integer</type></entry>

                  <entry>Function from <type>String</type> to <type>Integer</type></entry>
                </row>

                <row>
                  <entry><type>Double -&gt; Double</type></entry>

                  <entry>Function from <type>Double</type> to <type>Double</type></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>The interpretation for multi-parameter functions is slightly more subtle. The meaning
        of the type for a multi-parameter function hinges on the fact that the <function
        role="operator">-&gt;</function> operator is right-associative:<informaltable>
            <tgroup align="left" cols="2">
              <thead>
                <row>
                  <entry>Type</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><type>Double -&gt; Double -&gt; String</type></entry>

                  <entry>Function that takes 2 <type>Double</type>s and returns a
                  <type>String</type></entry>
                </row>

                <row>
                  <entry><type>Double -&gt; (Double -&gt; String)</type></entry>

                  <entry>Equivalent to previous</entry>
                </row>

                <row>
                  <entry><type>Double -&gt; Double -&gt; Double -&gt; String</type></entry>

                  <entry>Function that takes 3 <type>Double</type>s and returns a
                  <type>String</type></entry>
                </row>

                <row>
                  <entry><type>Double -&gt; (Double -&gt; (Double -&gt; String))</type></entry>

                  <entry>Equivalent to previous</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>Written in this form, it is clear that one can interpret a function taking two
        <type>Double</type>s and returning a <type>String</type> as actually being a function that
        accepts one <type>Double</type> and returns another function; this other function accepts
        another <type>Double</type> (the next parameter) and returns a <type>String</type>. Note how
        this accounts for partial function application: Applying a single argument to an <phrase
        role="formula">n</phrase>-argument function yields a new function of <phrase
        role="formula">(n-1)</phrase> arguments. <phrase role="formula">N</phrase> successive such
        applications eventually reduce the function call to its return value.</para>
      </section>

      <section>
        <title>Algebraic types</title>

        <para>An algebraic, or parameterized, type is one that allows one or more different data
        constructors. These data constructors may accept specified concrete types, or they may
        accept general types (specified by type variables).</para>

        <para>An algebraic type is specified by a type constructor followed by zero or more other
        types:<synopsis><replaceable>type_constructor</replaceable> [<replaceable>type1</replaceable> [<replaceable>type2</replaceable> ...]]</synopsis></para>

        <para>Ex: <informalexample>
            <informaltable>
              <tgroup align="left" cols="2">
                <thead>
                  <row>
                    <entry>Type</entry>

                    <entry>Possible values</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><type>Ordering</type></entry>

                    <entry><function>LT</function>, <function>EQ</function>, or
                    <function>GT</function></entry>
                  </row>

                  <row>
                    <entry><type>Maybe String</type></entry>

                    <entry><code>(Just <replaceable>string_value</replaceable>)</code> or
                    <function>Nothing</function></entry>
                  </row>

                  <row>
                    <entry><type>Either Int Integer</type></entry>

                    <entry><code>(Left <replaceable>int_value</replaceable>)</code> or <code>(Right
                    <replaceable>integer_value</replaceable>)</code></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </informalexample></para>

        <para>The last two types in the above example are subsets of the following more general
        types:<informaltable>
            <tgroup align="left" cols="2">
              <thead>
                <row>
                  <entry>Type</entry>

                  <entry>Possible values</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><type>Maybe a</type></entry>

                  <entry><code>(Just <replaceable>value</replaceable>)</code> for some
                  <varname><replaceable>value</replaceable></varname>, or
                  <code>Nothing</code></entry>
                </row>

                <row>
                  <entry><type>Either a b</type></entry>

                  <entry><code>(Left <replaceable>value1</replaceable>)</code> or <code>(Right
                  <replaceable>value2</replaceable>)</code>, for some
                  <varname><replaceable>value1</replaceable></varname> or
                  <varname><replaceable>value2</replaceable></varname></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>There are a number of built-in algebraic types. New ones can also be declared using a
        data declaration.</para>

        <section>
          <title>Type constructors vs. data constructors</title>

          <para>Note that there is an important distinction between type constructors, which are
          used to specify a type, and data constructors, which are used to specify a value. Each
          algebraic type has exactly one type constructor, and at least one data constructor. (This
          distinction is occasionally obscured in types whose type constructor and data constructor
          have the same name).</para>

          <para>Ex:<informalexample>
              <informaltable>
                <tgroup align="left" cols="3">
                  <thead>
                    <row>
                      <entry>The type...</entry>

                      <entry>has type constructor...</entry>

                      <entry>and data constructors...</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry><type>Maybe a</type></entry>

                      <entry><type>Maybe</type></entry>

                      <entry><function>Just</function>, <function>Nothing</function></entry>
                    </row>

                    <row>
                      <entry><type>Either a b</type></entry>

                      <entry><type>Either</type></entry>

                      <entry><function>Left</function>, <function>Right</function></entry>
                    </row>

                    <row>
                      <entry><type>Ordering</type></entry>

                      <entry><type>Ordering</type></entry>

                      <entry><function>LT</function>, <function>EQ</function>,
                      <function>GT</function></entry>
                    </row>

                    <row>
                      <entry><type>Int</type></entry>

                      <entry><type>Int</type></entry>

                      <entry><replaceable>(int values)</replaceable></entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </informalexample></para>

          <para>Some example values and their corresponding types: <informalexample>
              <informaltable>
                <tgroup align="left" cols="2">
                  <thead>
                    <row>
                      <entry>Value</entry>

                      <entry>Type</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry><type>EQ</type></entry>

                      <entry><type>Ordering</type></entry>
                    </row>

                    <row>
                      <entry><type>LT</type></entry>

                      <entry><type>Ordering</type></entry>
                    </row>

                    <row>
                      <entry><type>Just "holiday"</type></entry>

                      <entry><type>Maybe String</type></entry>
                    </row>

                    <row>
                      <entry><type>Nothing</type></entry>

                      <entry><type>Maybe a</type> (for some <type>a</type>)</entry>
                    </row>

                    <row>
                      <entry><type>Left 50.0</type></entry>

                      <entry><type>Either Double a</type> (for some <type>a</type>)</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </informalexample></para>

          <para>See <xref linkend="StandardLibraryReference" /> for a complete list of types defined
          in the Prelude.</para>
        </section>
      </section>

      <section>
        <title>Type classes</title>

        <para>It is possible to organize types into groupings known as classes. A type class is a
        group of types that define some common set of operations. These operations are referred to
        as methods.</para>

        <para>Note that in spite of the "class" and "method" terminology, CAL classes are
        conceptually quite different from classes in object-oriented languages such as C# or Java.
        Classes (and interfaces) in Java define entirely new types. By contrast, a CAL type class is
        not a new type itself, but rather just a set of types that share specified methods.</para>

        <para>CAL defines a number of built-in type classes. See <xref
        linkend="StandardLibraryReference" /> for a complete list of the type classes defined in the
        Prelude.</para>

        <para>Types that are members of a specific type class are said to be instances of that
        class. Every instance of a class specifies (in an instance declaration) the functions that
        are to be used to provide the functionality of the required methods. For example, the
        <type>Int</type> type uses the <function>equalsInt</function> function to define the
        functionality for the <function>equals</function> method.</para>

        <para>See <xref linkend="TypeClassDefinitions" /> and <xref
        linkend="TypeInstanceDefinitions" /> for information on declaring type classes and
        instances. See <xref linkend="StandardLibraryReference" /> for a complete list of type
        classes defined in the Prelude.</para>
      </section>

      <section>
        <title>Constrained types</title>

        <para>With type variables, it is possible to specify types extremely generally. Constrained
        type expressions allow one to be slightly more specific by specifying properties that type
        variables must satisfy, while still avoiding the need to use specific, concrete
        types.</para>

        <para>There are two types of constraint that can be applied to a type expression: Type class
        constraints, and lacks constraints.</para>

        <para>Constrained type signatures have two forms. Which form you use depends on whether you
        want to use a single constraint or multiple constraints:<synopsis><replaceable>constraint</replaceable> =&gt; <replaceable>type_signature</replaceable></synopsis><synopsis>(<replaceable>constraint</replaceable> [, <replaceable>constraint</replaceable> [, <replaceable>constraint</replaceable> ...]]</synopsis></para>

        <para>It's okay to mix types of constraints in the same type signature (i.e. record
        constraints and type class constraints in the same signature, or even applied to the same
        type variable in the same signature, are allowed).</para>

        <section>
          <title>Type class constraints</title>

          <para>Type class constraints have the following form:<synopsis><replaceable>type_class</replaceable> <replaceable>type_variable</replaceable></synopsis></para>

          <para>One or more type variables are required to belong to various type classes. These
          variables are then used in the main body of the type signature.</para>

          <para>Ex:<informalexample>
              <informaltable>
                <tgroup align="left" cols="2">
                  <thead>
                    <row>
                      <entry>Type</entry>

                      <entry>Description</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry><type>[a]</type></entry>

                      <entry>List of elements of type <type>a</type>, for some type
                      <type>a</type></entry>
                    </row>

                    <row>
                      <entry><type>Ord a =&gt; [a]</type></entry>

                      <entry>List of elements of type <type>a</type>, for some type <type>a</type>
                      which is an instance of <classname>Ord</classname></entry>
                    </row>

                    <row>
                      <entry><type>(Ord a, Show b) =&gt; a -&gt; b</type></entry>

                      <entry>Function taking an argument of type <type>a</type> and returning a
                      value of type <type>b</type>, for some type <type>a</type> which is an
                      instance of <classname>Ord</classname> and some type <type>b</type> which is
                      an instance of <classname>Show</classname>.</entry>
                    </row>

                    <row>
                      <entry><type>(Ord a, Show a) =&gt; (a, b)</type></entry>

                      <entry>2-tuple whose first component is of type <type>a</type> and whose
                      second component is of type <type>b</type>, for some type <type>a</type> which
                      is an instance of both <classname>Ord</classname> and
                      <classname>Show</classname> and some type <type>b</type>.</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </informalexample></para>

          <para>Note that the same variable can be constrained to belong to multiple classes (as in
          the last example above). Note also that not every variable used in the signature needs to
          be constrained. However, every variable that is constrained on the left of the
          double-arrow must be used in the signature on the right of the double-arrow.</para>
        </section>

        <section>
          <title xml:id="LacksConstraints">Lacks constraints</title>

          <para>Lacks constraints have the form:<synopsis><replaceable>type_variable</replaceable> \ <replaceable>field_name</replaceable></synopsis></para>

          <para>A lacks constraint indicates that a type variable must be a record type which does
          not include the specified field. These constraints are most often used to restrict the
          base-record of a record type to not include the fields which will be specified for the
          record type (the third example in the table below):<informalexample>
              <informaltable>
                <tgroup align="left" cols="2">
                  <thead>
                    <row>
                      <entry>Type</entry>

                      <entry>Description</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry><type>{r}</type></entry>

                      <entry>A record containing any fields</entry>
                    </row>

                    <row>
                      <entry><type>r\foo =&gt; {r}</type></entry>

                      <entry>A record containing any fields <emphasis>except</emphasis>
                      <varname>foo</varname></entry>
                    </row>

                    <row>
                      <entry><type>r\foo =&gt; {r | foo :: String}</type></entry>

                      <entry>A record containing any fields, one of which <emphasis>must
                      be</emphasis> <varname>foo</varname>, with <varname>foo</varname> having type
                      <type>String</type>.</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title>Higher-kinded type variables</title>

        <para>CAL supports the use of <firstterm>higher-kinded</firstterm> type variables. Whereas a
        regular type variable is a variable which stands for a <emphasis>type</emphasis>, a
        higher-kinded type variable is a variable which stands for a <emphasis>type
        constructor</emphasis>. For example, one may define a functor type class as:<informalexample>
            <programlisting>public class Functor f where
    public map :: (a -&gt; b) -&gt; f a -&gt; f b;
    ;</programlisting>
          </informalexample></para>

        <para>In the above declaration, the variable f is a higher-kinded type variable standing for
        a type constructor with one type parameter. The type declaration of the
        <function>map</function> method tells us that it is a method which takes a function (of type
        <type>a -&gt; b</type>) and a value of type <type>(f a)</type>, and returns a value of type
        <type>(f b)</type>.</para>

        <para>The type constructor for the standard type <type>Maybe</type> fits the requirement of
        a type constructor with one type parameter, and thus we may define a <type>Functor</type>
        instance for <type>Maybe</type>:<informalexample>
            <programlisting>instance Functor Maybe where
    map = mapMaybe;
    ;
mapMaybe :: (a -&gt; b) -&gt; (Maybe a -&gt; Maybe b);
private mapMaybe mappingFunction !maybeValue =
    case maybeValue of
    Nothing -&gt; Nothing;
    Just {value} -&gt; Just (mappingFunction value);
    ;</programlisting>
          </informalexample></para>
      </section>
    </section>

    <section>
      <title>Definitions and declarations</title>

      <para>A definition associates a function or type with a name. This section describes the
      format of the various kinds of CAL definitions.</para>

      <section>
        <title>Function definitions</title>

        <para>The simplest kind of definition is a function definition. A function definition has
        the following form:<synopsis>[<replaceable>visibility</replaceable>] <replaceable>name</replaceable> [<replaceable>param1_name</replaceable> [<replaceable>param2_name</replaceable> ...]] = <replaceable>expression</replaceable> ;</synopsis></para>

        <para><replaceable>Visibility</replaceable> is either <modifier>public</modifier>,
        <modifier>protected</modifier>, or <modifier>private</modifier>; if it is omitted, then the
        function is private by default. Public functions are visible to other modules that import
        the current module, whereas private functions are not. Protected functions are visible only
        to friend modules. (See <xref linkend="Modules" /> for further details).</para>

        <para><replaceable>Name</replaceable> is an identifier beginning with a lower-case letter.
        Zero or more parameter names may be specified.</para>

        <para>Some example functions:<informalexample>
            <programlisting>public e = 2.718281828459045;</programlisting>
          </informalexample><informalexample>
            <programlisting>public squareOf x = x * x;</programlisting>
          </informalexample><informalexample>
            <programlisting>private cube x = x * square x;</programlisting>
          </informalexample><informalexample>
            <programlisting>public distance loc1 loc2 =
    case loc1 of
    (x1,y1) -&gt; case loc2 of
               (x2,y2) -&gt; vectorLength (x1-x2, y1-y2);
               ;
    ;</programlisting>
          </informalexample></para>

        <para>Note that constant values can be defined as zero-parameter functions.</para>
      </section>

      <section>
        <title xml:id="TypeDeclarations">Type declarations</title>

        <para>CAL uses a feature known as type inference to deduce the types for each expression and
        definition that it encounters. However, type inference is not always able to unambiguously
        determine the type of an expression:<informalexample>
            <literallayout><userinput>:t []</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[a]</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t [] == []</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Ambiguous type signature in inferred type 
Prelude.Eq a =&gt; a.</computeroutput></literallayout>
          </informalexample></para>

        <para>In the first example above, the type inferencer is able to determine that the
        expression <code>[]</code> has the type <type>[a]</type>. In the second example, the
        inferencer is able to determine that the expression <code>[]</code> must have the type
        <type>Eq a =&gt; a</type> since we are attempting to apply the <function>equals</function>
        method of the <classname>Eq</classname> class to it. However, that is not sufficiently
        specific to determine which instance of <classname>Eq</classname> should be used for the
        <function>equals</function> method, so the attempt to type the expression fails.</para>

        <para>In such ambiguous cases, it may be necessary to explicitly declare the type that an
        expression or definition is meant to have. These declarations are accomplished in CAL
        through a type declaration. Type declarations have the following form:<synopsis><replaceable>expression</replaceable> :: <replaceable>type</replaceable> ;</synopsis></para>

        <para>Ex:<informalexample>
            <programlisting>pi :: Double;</programlisting>
          </informalexample><informalexample>
            <programlisting>sqrt :: Double -&gt; Double;</programlisting>
          </informalexample><informalexample>
            <programlisting>equalsMaybe :: Eq a =&gt; Maybe a -&gt; Maybe a -&gt; Boolean;</programlisting>
          </informalexample></para>

        <para>An explicit type declaration can restrict an expression's type to a more specific type
        than the inferenced type, but it can never declare an expression's type to be a less
        specific type than the inferenced type:<informalexample>
            <literallayout><userinput>:t []</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[a]</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t [] :: [Int]</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>[Int]</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t ([] :: [Int]) == []</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>Boolean</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t 55 + 5</userinput>
<emphasis role="bold-italic">outputs</emphasis> <computeroutput>Num a =&gt; a</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>:t 55 + 5 :: Eq a =&gt; a</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>The declared type of the expression is not compatible with its 
inferred type Prelude.Num a =&gt; a. Caused by: Type clash: The type 
declaration Prelude.Eq a =&gt; a does not match Prelude.Num a =&gt; a.</computeroutput></literallayout>
          </informalexample></para>

        <para>The final declaration fails to compile because <classname>Num</classname> is a
        subclass of <classname>Eq</classname>, so we are attempting to give the expression a more
        general type (<type>Eq</type>) than the inferenced type (<type>Num</type>).</para>

        <para>Even when it is not necessary, it is good practice to include explicit type
        declarations in certain situations. For example, it is a good practice to always assert the
        type of functions immediately before they are defined:<informalexample>
            <programlisting>notEqualsOrdering :: Ordering -&gt; Ordering -&gt; Boolean;
private notEqualsOrdering !x !y = not (equalsOrdering x y);
equalsOrdering :: Ordering -&gt; Ordering -&gt; Boolean;
private equalsOrdering !x !y =
    case x of
    LT -&gt;
        case y of 
        LT -&gt; True;
        _ -&gt; False;
        ;
    EQ -&gt;
        case y of 
        EQ -&gt; True;
        _ -&gt; False;
        ;
    GT -&gt;
        case y of 
        GT -&gt; True;
        _ -&gt; False;
        ;
    ;</programlisting>
          </informalexample></para>

        <para>This serves as both an important piece of documentation (ex, that the function accepts
        two arguments of type <type>Ordering</type> and returns a <type>Boolean</type>), and allows
        the compiler to provide better error messages in certain circumstances.</para>
      </section>

      <section>
        <title xlink:href="" xlink:role="TypeDefinitions" xml:id="TypeDefinitions">Type
        definitions</title>

        <para>CAL allows the programmer to extend the type system by defining custom types. As with
        functions, these types may be either public, protected, or private to a module. Simple type
        definitions take the following form: <synopsis>data [<replaceable>visibility</replaceable>] <replaceable>type_name</replaceable> [<replaceable>type_variable</replaceable> [<replaceable>type_variable</replaceable> ... ]] = 
   [<replaceable>visibility</replaceable>] <replaceable>constructor_name</replaceable> [<replaceable>arg_name</replaceable> :: <replaceable>arg_type</replaceable> ...]
   [ | [<replaceable>visibility</replaceable>] <replaceable>constructor_name</replaceable> [<replaceable>arg_name</replaceable> :: <replaceable>arg_type</replaceable> ...] ...]
   [deriving <replaceable>type_class</replaceable> [, <replaceable>type_class</replaceable> ...]]
   ;</synopsis> The type is given a name and a list of one or more data constructors. The data
        constructors may take arguments; if they do, their names and types must be specified. The
        type name is an identifier starting with an uppercase letter. An argument name is either an
        identifier starting with a lowercase letter, or an ordinal number preceded by the number
        sign (<code>#</code>). An argument type may be either a specific type, or may be specified
        using type variables. If the type of a data constructor's argument is specified using a type
        variable, then that variable must also appear as an argument of the type constructor.</para>

        <para>The optional <code>deriving</code> clause allows you to have the compiler
        automatically generate one or more type class instances for this type (see <xref
        linkend="TypeClasses" /> for a description of type classes). This feature saves the effort
        of having to define boilerplate instances for very commonly-used type classes whose
        instances tend to be defined in a very standard fashion.</para>

        <para>Only certain type classes may be specified in the deriving clause of a data
        definition. The type classes supported are:<itemizedlist spacing="compact">
            <listitem>
              <para><classname>Debug.Show</classname></para>
            </listitem>

            <listitem>
              <para><classname>Prelude.Bounded</classname></para>
            </listitem>

            <listitem>
              <para><classname>Prelude.Enum</classname></para>
            </listitem>

            <listitem>
              <para><classname>Prelude.Eq</classname></para>
            </listitem>

            <listitem>
              <para><classname>Prelude.Inputable</classname></para>
            </listitem>

            <listitem>
              <para><classname>Prelude.IntEnum</classname></para>
            </listitem>

            <listitem>
              <para><classname>Prelude.Ord</classname></para>
            </listitem>

            <listitem>
              <para><classname>Prelude.Outputable</classname></para>
            </listitem>

            <listitem>
              <para><classname>QuickCheck.Arbitrary</classname></para>
            </listitem>
          </itemizedlist></para>

        <para>The type classes <classname>Prelude.Bounded</classname>,
        <classname>Prelude.Enum</classname>, <classname>Prelude.IntEnum</classname>, and
        <classname>QuickCheck.Arbitrary</classname> can only be used with the <code>deriving</code>
        clause of enumeration types, where none of the data constructors take any arguments.</para>

        <para>Ex:<informalexample>
            <literallayout><userinput>data public Location = 
    public Nowhere |
    public Everywhere |
    public Cartesian 
        x :: Double 
        y :: Double |
    public Polar 
        theta :: Double 
        r :: Double
    deriving Eq;</userinput>
<emphasis role="bold-italic">compiles without error</emphasis></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>data public Directions = 
    public North | public South | public East | public West
    deriving Prelude.Eq, Prelude.Ord;</userinput>
<emphasis role="bold-italic">compiles without error</emphasis></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>data public Temperature = private Hot | private Cold;</userinput>
<emphasis role="bold-italic">compiles without error</emphasis></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>data public Message = 
    public Warning 
        message :: String |
    public Error 
        message :: String ;</userinput>
<emphasis role="bold-italic">compiles without error</emphasis></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>data public Tree a =
    Leaf |
    Node 
        value :: a
        leftChild :: (Tree a)
        rightChild :: (Tree a);</userinput>
<emphasis role="bold-italic">compiles without error</emphasis></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>data public Broken = 
    public Wrong    value :: a;</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>The type variable a must appear on the left-hand side of 
the data declaration.</computeroutput></literallayout>
          </informalexample></para>

        <para>The final example does not compile because a type variable (<type>a</type>) appears in
        a data constructor declaration but not in the type declaration.</para>

        <para>Note that the data constructors can have a different visibility than the type itself.
        It is common to make types public but data constructors private when defining Abstract Data
        Types, for example.</para>
      </section>

      <section>
        <title>Foreign definitions</title>

        <para>Any Java type can be imported into CAL as a CAL foreign type.</para>

        <para>Any Java method, constructor or field can be imported into CAL as a CAL foreign
        function. In addition, there are other Java operations, such as Java casts and <function
        role="operator">instanceof</function> operator calls that can be imported as CAL foreign
        functions. Although Java methods, constructors, fields, casts and <function
        role="operator">instanceof</function> operators all have their own special syntax in Java,
        they are imported into CAL uniformly as CAL functions. They are first-class CAL functions
        and can be used exactly like any other CAL function.</para>

        <section>
          <title xml:id="ForeignTypeDefinitions">Foreign type definitions</title>

          <para>Java types (i.e. classes, interfaces, and Java primitive types) are imported into
          CAL using the <code>data foreign unsafe import jvm</code> construct:<synopsis>data foreign unsafe import jvm [<replaceable>i_visibility</replaceable>] "<replaceable>java_name</replaceable>" 
 [<replaceable>c_visibility</replaceable>] <replaceable>type_identifier</replaceable> [deriving <replaceable>type_class</replaceable> [, <replaceable>type_class</replaceable>]];</synopsis></para>

          <para>The <replaceable>java_name</replaceable> is the fully qualified name of the type in
          Java. This is the name returned by the Java method
          <code>java.lang.Class.getName()</code>.</para>

          <para>Some examples are:<informalexample>
              <para><literal>"java.lang.String"</literal></para>
            </informalexample><informalexample>
              <para><literal>"java.io.File"</literal></para>
            </informalexample></para>

          <para>Java inner classes use the <code>$</code> as a separator between the name of the
          outer class and the name of the inner class:<informalexample>
              <para><literal>"java.util.Map$Entry"</literal></para>
            </informalexample></para>

          <para>Java primitive types are allowed as well:<informalexample>
              <para><literal>"boolean"</literal>, <literal>"char"</literal>,
              <literal>"byte"</literal>, <literal>"short"</literal>, <literal>"int"</literal>,
              <literal>"long"</literal>, <literal>"float"</literal>,
              <literal>"double"</literal></para>
            </informalexample></para>

          <para>Java array types follow the above naming rules along with the rule that terminating
          square brackets are used to indicate array dimensionality (as in Java source). Some
          examples are:<informalexample>
              <para><literal>"java.lang.Object[]"</literal></para>
            </informalexample><informalexample>
              <para><literal>"int[]"</literal></para>
            </informalexample><informalexample>
              <para><literal>"long[][]"</literal></para>
            </informalexample><informalexample>
              <para><literal>"java.lang.String[][]"</literal></para>
            </informalexample></para>

          <para><replaceable>C_visibility</replaceable> specifies the visibility of the imported
          type; it will be either <modifier>public</modifier>, <modifier>protected</modifier>, or
          <modifier>private</modifier>. If omitted, the visibility defaults to
          <modifier>private</modifier>.</para>

          <para><replaceable>Type_identifier</replaceable> is a CAL identifier beginning with an
          uppercase letter. It specifies the name that the foreign type will be assigned within
          CAL.</para>

          <para>Ex:<informalexample>
              <programlisting>data foreign unsafe import jvm public "java.math.BigInteger" 
    public Integer;</programlisting>
            </informalexample></para>

          <para>In the above example, the name of the type in CAL is <type>Prelude.Integer</type>
          (this definition occurs in the Prelude module). It is defined by the Java class
          <classname>java.math.BigInteger</classname>. Both the implementation visibility and the
          CAL visibility are public.</para>

          <para>Ex:<informalexample>
              <programlisting>data foreign unsafe import jvm private "int"
    public RelativeDate deriving Eq, Ord;</programlisting>
            </informalexample></para>

          <para>In this example, the name of the type in CAL is
          <type>RelativeTime.RelativeDate</type> (this definition occurs in the RelativeTime
          module). It is implemented by the Java primitive <type>int</type> type. The CAL type is
          public, but its implementation as a Java <type>int</type> is private. The type derives the
          <classname>Eq</classname> and <classname>Ord</classname> class instances. The optional
          <code>deriving</code> clause allows you to have the compiler automatically generate one or
          more type class instances for this foreign type (see <xref linkend="TypeClasses" /> for a
          description of type classes). This feature saves the effort of having to define
          boilerplate instances for very commonly-used type classes whose instances tend to be
          defined in a very standard fashion.</para>

          <para>Only certain type classes may be specified in the deriving clause of a foreign type
          definition. The type classes supported are:<itemizedlist spacing="compact">
              <listitem>
                <para><classname>Debug.Show</classname></para>
              </listitem>

              <listitem>
                <para><classname>Prelude.Eq</classname></para>
              </listitem>

              <listitem>
                <para><classname>Prelude.Inputable</classname></para>
              </listitem>

              <listitem>
                <para><classname>Prelude.Ord</classname></para>
              </listitem>

              <listitem>
                <para><classname>Prelude.Outputable</classname></para>
              </listitem>
            </itemizedlist></para>

          <para>The type class <classname>Prelude.Ord</classname> can only be derived for foreign
          types that represent either Java primitive types (e.g., <type>int</type>,
          <type>char</type>, <type>boolean</type>) or Java reference types that implement the
          <interfacename>Comparable</interfacename> interface. "Implementation visibility" is
          specified by <replaceable>i_visibility</replaceable>. It will be either
          <modifier>public</modifier>, <modifier>protected</modifier>, or
          <modifier>private</modifier>. If omitted, the implementation visibility defaults to
          <modifier>private</modifier>. Implementation visibility indicates whether outside modules
          are permitted to define foreign functions that operate on the imported type.</para>

          <para>This ability to control the visibility of a foreign type's implementation type
          allows the programmer to define abstract data types that use foreign values as their
          underlying representation.</para>

          <para>Ex:<informalexample>
              <programlisting>// --- Module Color ---
module Color;
import Cal.Core.Prelude;
friend Color_Tests;

data foreign unsafe import jvm public "java.awt.Color" 
    public JColor;

data foreign unsafe import jvm protected "java.awt.Color"
    public TestableColor;
data foreign unsafe import jvm private "java.awt.Color" 
    public Color;

// --- Module Color_Tests ---
module Color_Tests;
import Cal.Core.Prelude;
import Color;

// !!! Won't compile, Color has private implementation
foreign unsafe import jvm "method getRed" 
    private getRed :: Color -&gt; Int;

// OK, TestableColor is protected implementation 
// and we're a friend module
foreign unsafe import jvm "method getRed" 
    private t_getRed :: TestableColor -&gt; Int; 

// --- Module Draw ---
import Color using
    typeConstructor = JColor, Color;
;

// OK, JColor is public implementation
foreign unsafe import jvm "method getRed" 
    private jColor_getRed :: JColor -&gt; Int;

// !!! Won't compile, TestableColor has protected implementation 
// scope and we're not a friend module
foreign unsafe import jvm "method getRed" 
    private t_getRed :: TestableColor -&gt; Int; 

// !!! Won't compile, Color has private implementation scope
foreign unsafe import jvm "method getRed" 
    private getRed :: Color -&gt; Int;</programlisting>
            </informalexample></para>

          <para>In the above example, the <classname>Draw</classname> module is permitted to define
          foreign functions that operate upon <classname>java.awt.Color</classname> values as CAL
          functions that operate upon <type>JColor</type> values, because <type>JColor</type> is
          imported with a publicly-visible implementation. However, the <classname>Draw</classname>
          module is not permitted to define foreign functions that operate upon
          <classname>java.awt.Color</classname> values as CAL functions that operate upon
          <type>Color</type> values, because the <type>Color</type> type is defined with a private
          implementation. Neither can the <classname>Draw</classname> module define a foreign
          function that operates upon <classname>java.awt.Color</classname> values as a CAL function
          that operates upon <type>TestableColor</type> values, because the <type>Testable</type>
          type has a protected implementation. <classname>Color_Tests</classname>
          <emphasis>is</emphasis> able to implement such functions on <type>TestableColor</type>
          values, however, because <classname>Color_Tests</classname> is a friend module of
          <classname>Color</classname>. (See <xref linkend="Modules" /> for more detail of
          scoping).</para>
        </section>

        <section>
          <title>Foreign function definitions for Java methods and constructors</title>

          <para>Java methods and constructors are both imported into CAL using the <code>foreign
          unsafe import jvm</code> construct. The construct takes the following form:<synopsis>foreign unsafe import jvm "<replaceable>entity_type</replaceable> <replaceable>java_name</replaceable>"
    [<replaceable>visibility</replaceable>] <replaceable>function_identifier</replaceable> :: <replaceable>function_type</replaceable> ;</synopsis></para>

          <para>The valid entity types for foreign functions corresponding to Java methods and
          constructors are:<itemizedlist>
              <listitem>
                <para><code>method </code>(followed by the Java method name)</para>
              </listitem>

              <listitem>
                <para><code>static method </code>(followed by the Java qualified method name)</para>
              </listitem>

              <listitem>
                <para><code>constructor </code>(optionally followed by the Java qualified type
                name)</para>
              </listitem>
            </itemizedlist>Note that the type of the imported function must be specified i.e.
          <replaceable>function_type</replaceable>.</para>

          <para>Here are some examples of importing non-static methods of
          <classname>java.math.BigInteger</classname>:<informalexample>
              <programlisting>foreign unsafe import jvm "method abs"
    private absInteger :: Integer -&gt; Integer;
</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "method toString"
    private toStringWithRadix :: Integer -&gt; Int -&gt; String;</programlisting>
            </informalexample></para>

          <para>The <methodname>abs</methodname> method of <classname>BigInteger</classname> is
          imported as the private CAL function <function>absInteger</function>. Note in the case of
          the non-static method, we do not specify the fully qualified name i.e.
          <methodname>java.math.BigInteger.abs</methodname>. This is because the Java class in which
          the method is defined is determined by the type of the first argument to the method i.e.
          the <type>Integer</type> argument has Java implementation type
          <type>java.math.BigInteger</type>. <function>toStringWithRadix</function> corresponds to
          the overload of <methodname>java.math.BigInteger.toString</methodname> that takes an
          <type>int</type> argument (for the radix).</para>

          <para>Ex:<informalexample>
              <programlisting>foreign unsafe import jvm "static method java.math.BigInteger.valueOf"
    public longToInteger :: Long -&gt; Integer;</programlisting>
            </informalexample></para>

          <para>The static method <methodname>BigInteger.valueOf</methodname> is imported as the
          public CAL function <function>longToInteger</function>. For static methods, the fully
          qualified method name (<methodname>java.math.BigInteger.valueOf</methodname>) is
          needed.</para>

          <para>Ex:<informalexample>
              <programlisting>foreign unsafe import jvm "constructor"
    public stringToInteger :: String -&gt; Integer;</programlisting>
            </informalexample></para>

          <para>The constructor of the <classname>java.math.BigInteger</classname> class that
          accepts a string is imported as the public CAL function
          <function>stringToInteger</function>. Note that optionally, the precise Java class in
          which the constructor is defined can be given. Otherwise, it is determined by the return
          type of the CAL function. For example, the following definition is
          equivalent:<informalexample>
              <programlisting>foreign unsafe import jvm "constructor java.math.BigInteger"
    public stringToInteger :: String -&gt; Integer;</programlisting>
            </informalexample></para>

          <para>Sometimes it is necessary to specify the javaName for a constructor, such as when
          the class in which the constructor is defined cannot be inferred from the return type. For
          example:<informalexample>
              <programlisting>foreign unsafe import jvm "constructor java.util.ArrayList"
    private makeJList :: JList;</programlisting>
            </informalexample></para>

          <para>This is because CAL allows you to specify a return type whose Java implementation
          type is a super-type of the actual Java type returned by the Java method or
          constructor.</para>
        </section>

        <section>
          <title>Foreign function definitions for Java fields</title>

          <para>Java fields are imported into CAL using the <code>foreign unsafe import jvm</code>
          construct. The construct takes the following form:<synopsis>foreign unsafe import jvm "<replaceable>entity_type</replaceable> <replaceable>java_name</replaceable>"
  [<replaceable>visibility</replaceable>] <replaceable>function_identifier</replaceable> :: <replaceable>function_type</replaceable> ;</synopsis></para>

          <para>The valid entity type for foreign fields are:<itemizedlist>
              <listitem>
                <para><code>field </code>(followed by the Java field name)</para>
              </listitem>

              <listitem>
                <para><code>static field </code>(followed by the Java qualified field name)</para>
              </listitem>
            </itemizedlist>Note that the type of the zero-argument CAL function to be associated
          with the field must be specified.</para>

          <para>Ex:<informalexample>
              <programlisting>foreign unsafe import jvm "static field java.lang.Double.NaN"
    public notANumber :: Double;</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title>Foreign function definitions for Java casts</title>

          <para>Java casts can be imported into CAL using the <code>foreign unsafe import jvm</code>
          construct. You can use "cast" to convert between any two CAL types that are foreign types
          such that there is a legal Java conversion between the two types.</para>

          <para>Here is an example from the <classname>Prelude</classname> module. In this case, the
          Java implementation types are <type>byte</type> and <type>float</type>. There is a legal
          Java cast between these two types so this declaration is allowed by CAL.<informalexample>
              <programlisting>foreign unsafe import jvm "cast"
    byteToFloat :: Byte -&gt; Float;</programlisting>
            </informalexample></para>

          <para>Here is another example from the <classname>Prelude</classname> module. In this
          case, the Java implementation types are <classname>java.util.List</classname> and
          <classname>java.util.ArrayList</classname>. There is a legal Java cast between these two
          types so this declaration is allowed by CAL.<informalexample>
              <programlisting>foreign unsafe import jvm "cast"
    listToArrayList :: JList -&gt; JArrayList;</programlisting>
            </informalexample></para>

          <para>"cast" works for any legal Java cast, including identity casts, widening and
          narrowing primitive casts, and widening and narrowing reference casts. The actual rules
          for when you can do this are somewhat technical and described in section 2.6 of the JVM
          specification. The CAL compiler will take care of producing optimal Java code for what you
          have done e.g. narrowing reference casts compile down to uses of the Java cast operator,
          primitive casts compile down to uses of JVM primitive conversion operations, identity and
          widening reference casts are no-ops.</para>
        </section>

        <section>
          <title>Foreign function definitions for Java instanceof operator calls</title>

          <para>Java <function role="operator">instanceof</function> operators can be imported into
          CAL using the <code>foreign unsafe import jvm</code> construct. Here is an example from
          the <classname>Prelude</classname> module. Note that <type>JObject</type> has
          implementation type <classname>java.lang.Object</classname>:<informalexample>
              <programlisting>foreign unsafe import jvm "instanceof java.util.Iterator"
    private isJIterator :: JObject -&gt; Boolean;</programlisting>
            </informalexample></para>

          <para>This is the CAL analogue of the Java construct "<code><replaceable>e</replaceable>
          instanceof java.lang.Iterator</code>" where <replaceable>e</replaceable> is an expression
          having Java static type <classname>java.lang.Object</classname>.</para>

          <para>Here is another example from the <classname>Exception</classname> module. Note that
          <type>JThrowable</type> has implementation type
          <classname>java.lang.Throwable</classname>:<informalexample>
              <programlisting>foreign unsafe import jvm
"instanceof java.lang.NullPointerException"
    public isJavaNullPointerException :: JThrowable -&gt; Boolean;</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title>Foreign function definitions for Java nulls and null-checks</title>

          <para>Java provides the <code>null</code> keyword, and the JVM provides special support
          for comparisons of reference values to <code>null</code>. These constructs can be accessed
          as CAL functions as the following examples show:<informalexample>
              <programlisting>foreign unsafe import jvm "null"
    nullString :: String;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "isNull"
    isNullString :: String -&gt; Boolean;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "isNotNull"
    isNotNullString :: String -&gt; Boolean;</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title>Foreign function definitions for Java class literals</title>

          <para>Java provides special syntax for referring to class literals (values of the type
          <code>java.lang.Class</code>) via the <code>class</code> keyword, and starting with Java
          5, the JVM provides special support for loading class literal values. Class literals can
          be accessed as CAL functions as the following examples show:<informalexample>
              <programlisting>foreign unsafe import jvm "class int"
    intClass :: JClass;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "class java.util.List"
    listClass :: JClass;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "class long[][]"
    longArrayArrayClass :: JClass;</programlisting>
            </informalexample>In the above, the CAL type <code>JClass</code> has implementation type
          <code>java.lang.Class</code>. The three declarations are CAL analogues of the Java
          expressions <code>int.class</code>, <code>java.util.List.class</code>, and
          <code>long[][].class</code> respectively. Note that class literals can be accessed for
          Java primitive types (e.g. <code>int</code>), reference types (e.g.
          <code>java.util.List</code>), array types (e.g. <code>long[][]</code>) and also the
          pseudo-type <code>void</code>.</para>
        </section>

        <section>
          <title>Foreign function definitions for Java array operations</title>

          <para>Java provides primitive operator support for arrays. In particular, for creating,
          updating, subscripting and taking the length of an array. This functionality can be
          exposed as CAL functions, as the following examples show:<informalexample>
              <programlisting>data foreign unsafe import jvm "int[]" JIntArray;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "newArray"
    newIntArray :: Int -&gt; JIntArray;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "updateArray"
    updateIntArray :: JIntArray -&gt; Int -&gt; Int -&gt; Int;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "lengthArray"
    lengthIntArray :: JIntArray -&gt; Int;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "subscriptArray"
    subscriptIntArray :: JIntArray -&gt; Int -&gt; Int;</programlisting>
            </informalexample></para>

          <para>Note that multi-dimensional arrays are also supported, in all the variants supported
          by the JVM. For example, you can subscript a 2-dimensional array at one index (to get a
          one-dimensional array) or at 2-indices (to get an element value).<informalexample>
              <programlisting>data foreign unsafe import jvm "int[][]"
    JInt2Array;</programlisting>
            </informalexample><informalexample>
              <programlisting>//specify the size of one dimension
foreign unsafe import jvm "newArray"
    newInt2Array :: Int -&gt; JInt2Array;</programlisting>
            </informalexample><informalexample>
              <programlisting>//specify the sizes of both dimensions
foreign unsafe import jvm "newArray"
    newInt2Array2 :: Int -&gt; Int -&gt; JInt2Array;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "updateArray"
    updateInt2Array :: JInt2Array -&gt; Int -&gt; JIntArray -&gt; JIntArray;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "updateArray"
    updateInt2Array2 :: JInt2Array -&gt; Int -&gt; Int -&gt; Int -&gt; Int;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "subscriptArray"
    subscriptInt2Array :: JInt2Array -&gt; Int -&gt; Int -&gt; Int;</programlisting>
            </informalexample><informalexample>
              <programlisting>foreign unsafe import jvm "subscriptArray"
    subscriptInt2ArrayToIntArray :: JInt2Array -&gt; Int -&gt; JIntArray;</programlisting>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title xml:id="TypeClassDefinitions">Type class definitions</title>

        <para>A type class is a group of types that all provide some set of operations. (See <xref
        linkend="TypeClasses" /> for details of type classes). Type classes are defined using the
        <code>class</code> keyword. Class definitions take the following form: <synopsis>[<replaceable>visibility</replaceable>] class <replaceable>class_name</replaceable> <replaceable>class_variable</replaceable> where
    [<replaceable>visibility</replaceable>] <replaceable>method_name</replaceable> :: <replaceable>method_type</replaceable>
        [default <replaceable>default_implementation_function_name</replaceable>];
    [[<replaceable>visibility</replaceable>] <replaceable>method_name</replaceable> :: <replaceable>method_type</replaceable>
        [default <replaceable>default_implementation_function_name</replaceable>]; ...]
    ;</synopsis></para>

        <para>Like types, type classes can be defined as being either <modifier>public</modifier>,
        <modifier>protected</modifier>, or <modifier>private</modifier> to a module. The name of a
        type class is an identifier starting with an uppercase letter. Like types, the visibility
        specification is optional; if it is omitted, then the class defaults to being
        <modifier>private</modifier>. The class declaration is followed by a list of one or more
        method declarations. Each method must specify its type and can be declared as being either
        <modifier>public</modifier> or <modifier>private</modifier> (with
        <modifier>private</modifier> being the default). Each method may also specify a default
        implementation.</para>

        <para><informalexample>
            <programlisting>public class MyAppendable a where    
    public myEmpty :: a;    
    public myIsEmpty :: a -&gt; Boolean;
    public myAppend :: a -&gt; a -&gt; a; 
    public myConcat :: [a] -&gt; a
        default myConcatDefault;
    ;</programlisting>
          </informalexample></para>

        <para>In the above example, a type <type>a</type> can be a member of the type class
        <classname>MyAppendable</classname> only if it specifies a public
        <methodname>myEmpty</methodname> method that returns a value of type <type>a</type>, a
        public <methodname>myIsEmpty</methodname> method that accepts a value of type <type>a</type>
        and returns a <type>Boolean</type>, a public <methodname>myAppend</methodname> method that
        accepts two values of type <type>a</type> and returns a value of type <type>a</type>, and a
        public <methodname>myConcat</methodname> method that accepts a list of elements of type
        <type>a</type> and returns a value of type a.</para>

        <para>The <methodname>myConcat</methodname> method, which concatenates a list of values of
        type <type>a</type>, can be implemented using the methods <methodname>myAppend</methodname>
        and <methodname>myEmpty</methodname>. Thus, a default implementation can be specified, in
        this case through the function <function>myConcatDefault</function>:<informalexample>
            <programlisting>myConcatDefault :: MyAppendable a =&gt; [a] -&gt; a;
private myConcatDefault = List.foldRight myAppend myEmpty;</programlisting>
          </informalexample></para>

        <section>
          <title>Constrained class methods</title>

          <para>The type variable used in a type class declaration (before the <code>where</code>
          keyword) scopes over the entire declaration. However, one may have other type variables in
          the type declarations of the methods in the type class, and these type variables can have
          additional constraints.</para>

          <para>Ex:<informalexample>
              <programlisting>public class Formatter a where
    public formatBoolean :: a -&gt; Boolean -&gt; String;
    public formatChar :: a -&gt; Char -&gt; String;
    public formatNum :: Num b =&gt; a -&gt; b -&gt; String;
    ;</programlisting>
            </informalexample></para>

          <para>In the above example, the method <methodname>formatNum</methodname> has an
          additional type class constraint on its second argument, namely <type>Num b =&gt;
          b</type>.</para>
        </section>
      </section>

      <section>
        <title xml:id="TypeInstanceDefinitions">Type instance definitions</title>

        <para>Once a type class has been defined, types may be added to it by means of a type
        instance definition. A type instance definition adds a type to a class and specifies the
        functions that provide the required methods for the class. An instance declaration has the
        following form: <synopsis>instance <replaceable>class_name</replaceable> <replaceable>type_signature</replaceable> where
    <replaceable>method_name</replaceable> = <replaceable>function_name</replaceable> ;
    [<replaceable>method_name</replaceable> = <replaceable>function_name</replaceable> ; ...]
    ;</synopsis></para>

        <para>An instance definition defines a type as being part of a type class.</para>

        <para>Ex:<informalexample>
            <programlisting>public class MyEq a where
    public myEquals :: a -&gt; a -&gt; Boolean;
    public myNotEquals :: a -&gt; a -&gt; Boolean;
    ;    
equalsInt :: Int -&gt; Int -&gt; Boolean;
private equalsInt !x !y =
    x == y;
notEqualsInt :: Int -&gt; Int -&gt; Boolean;
private notEqualsInt !x !y = 
    x != y;    
// Int is an instance of MyEq
instance MyEq Int where
    myEquals = equalsInt;
    myNotEquals = notEqualsInt;
    ;</programlisting>
          </informalexample></para>

        <para>Note that public methods (i.e., methods that may be referenced from modules other than
        the one in which they were defined) may be bound to private functions.</para>

        <para>If a method is declared in the type class to have a default implementation, then the
        instance declaration is allowed to omit the specification of an instance-specific version of
        the method.</para>

        <para>Ex:<informalexample>
            <programlisting>public class MyEq2 a where
    public myEquals2 :: a -&gt; a -&gt; Boolean;
    public myNotEquals2 :: a -&gt; a -&gt; Boolean
        default defaultNotMyEquals2;
    ;

defaultNotMyEquals2 :: MyEq2 a =&gt; a -&gt; a -&gt; Boolean;
private defaultNotMyEquals2 !x !y = 
    not (myEquals2 x y);

equalsInt2 :: Int -&gt; Int -&gt; Boolean;
private equalsInt2 !x !y =
    x == y;

// Int is an instance of MyEq2
instance MyEq2 Int where
    myEquals2 = equalsInt2;
    ;</programlisting>
          </informalexample></para>

        <section>
          <title>Constrained type instance definitions</title>

          <para>There is another form of instance definition for declaring constrained types to be
          part of a type class:<synopsis>instance <replaceable>constraints</replaceable> =&gt; <replaceable>class_name</replaceable> <replaceable>type_signature</replaceable> where
    <replaceable>method_name</replaceable> = <replaceable>function_name</replaceable> ;
    [ <replaceable>method_name</replaceable> = <replaceable>function_name</replaceable> ; ]</synopsis></para>

          <para>Ex:<informalexample>
              <programlisting>instance Eq a =&gt; Eq (MyMaybe a) where
    equals = equalsMyMaybe;
    notEquals = notEqualsMyMaybe;
    ;</programlisting>
            </informalexample><informalexample>
              <programlisting>instance (Eq a, Eq b) =&gt; Eq (MyEither a b) where
    equals = equalsMyEither;
    notEquals = notEqualsMyEither;
    ;</programlisting>
            </informalexample></para>

          <para>The first example declares the type <type>MyMaybe a</type> to be a member of
          <classname>Eq</classname> for all types <type>a</type> that are members of
          <classname>Eq</classname>. The second example declares the type <type>MyEither a b</type>
          to be a member of <classname>Eq</classname> for all types <type>a</type> and
          <type>b</type> where <type>a</type> is a member of <classname>Eq</classname> and
          <type>b</type> is a member of <classname>Eq</classname>.</para>
        </section>
      </section>
    </section>

    <section>
      <title xml:id="Modules">Modules</title>

      <para>The standard compilation unit of a CAL program is the module. A module is usually stored
      as a text file containing CAL source.</para>

      <para>Each definition in a CAL program resides in a single module. Private definitions can
      only be referenced from within the module in which they are defined. Protected definitions can
      be referenced from other modules only if the other module is a friend module. Public
      definitions may be referenced from other modules if they are imported into the other module
      (see Importing functions and types from other modules).</para>

      <section>
        <title>Module names</title>

        <para>The name of a module has the form:<synopsis><replaceable>component</replaceable>[.<replaceable>component</replaceable>[.<replaceable>component</replaceable>[...]]]</synopsis>
        where each <replaceable>component</replaceable> is an identifier starting with an uppercase
        letter. For example, <classname>UserGuideExamples, Cal.Core.Prelude</classname> and
        <classname>Cal.Test.Core.Prelude_Tests</classname> are all valid module names.</para>

        <para>The ability to have multiple components in a module name allows us to organize a set
        of modules into a hierarchy. For example, the standard library modules listed in <xref
        linkend="StandardLibraryModules" /> can be viewed as forming the following
        hierarchy:<informalexample>
            <literallayout><classname>Cal</classname>
     <classname>Collections</classname>
         <classname>Array</classname>, <classname>IntMap</classname>, <classname>List</classname>, <classname>LongMap</classname>, <classname>Map</classname>, <classname>Set</classname>
     <classname>Core</classname>
         <classname>Bits</classname>, <classname>Char</classname>, <classname>Debug</classname>, <classname>Dynamic</classname>, <classname>Exception</classname>, <classname>Prelude</classname>, <classname>Record</classname>, <classname>Resource</classname>, <classname>String</classname>, 
           <classname>System</classname>
     <classname>Utilities</classname>
         <classname>Decimal</classname>, <classname>Locale</classname>, <classname>Math</classname>, <classname>MessageFormat</classname>, <classname>QuickCheck</classname>, <classname>Random</classname>, <classname>StringNoCase</classname>, 
           <classname>StringProperties</classname>, <classname>TimeZone</classname></literallayout>
          </informalexample></para>

        <para>Under this scheme, the prefix <package>Cal.Collections</package> of the module name
        <classname>Cal.Collections.Array</classname> can be considered as a namespace for the
        module.</para>

        <para>To reduce the amount typing required when referring to modules with such hierarchical
        names, CAL permits the use of <firstterm>partially qualified</firstterm> module names
        whenever they are not ambiguous. A partially qualified module name is a proper suffix of a
        (fully qualified) module name. For example, the module
        <classname>Cal.Collections.List</classname> has the partially qualified names
        <classname>List</classname> and <classname>Collections.List</classname>.</para>

        <para>For example, suppose we have a module:<informalexample>
            <programlisting>module W.X.Y.Z;
import Cal.Core.Prelude;
import Y.Z;
import Z;
import A.B.C.D.E;
import P.C.D.E;
import D.E;</programlisting>
          </informalexample></para>

        <para>The following table lists the partially qualified and fully qualified module names of
        the modules involved, and to which module each name resolves.</para>

        <para><informaltable>
            <tgroup align="left" cols="2">
              <thead>
                <row>
                  <entry>Name</entry>

                  <entry>Resolves to...</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><classname>Prelude</classname></entry>

                  <entry><classname>Cal.Core.Prelude</classname></entry>
                </row>

                <row>
                  <entry><classname>Core.Prelude</classname></entry>

                  <entry><classname>Cal.Core.Prelude</classname></entry>
                </row>

                <row>
                  <entry><classname>Cal.Core.Prelude</classname></entry>

                  <entry><classname>Cal.Core.Prelude</classname></entry>
                </row>

                <row>
                  <entry><classname>Z</classname></entry>

                  <entry><classname>Z</classname></entry>
                </row>

                <row>
                  <entry><classname>Y.Z</classname></entry>

                  <entry><classname>Y.Z</classname></entry>
                </row>

                <row>
                  <entry><classname>X.Y.Z</classname></entry>

                  <entry><classname>W.X.Y.Z</classname> (the current module)</entry>
                </row>

                <row>
                  <entry><classname>W.X.Y.Z</classname></entry>

                  <entry><classname>W.X.Y.Z</classname></entry>
                </row>

                <row>
                  <entry><classname>E</classname></entry>

                  <entry>Ambiguous (3 potential matches: <classname>A.B.C.D.E</classname>,
                  <classname>P.C.D.E</classname>, <classname>D.E</classname>)</entry>
                </row>

                <row>
                  <entry><classname>D.E</classname></entry>

                  <entry><classname>D.E</classname></entry>
                </row>

                <row>
                  <entry><classname>C.D.E</classname></entry>

                  <entry>Ambiguous (2 potential matches: <classname>A.B.C.D.E</classname> and
                  <classname>P.C.D.E</classname>)</entry>
                </row>

                <row>
                  <entry><classname>B.C.D.E</classname></entry>

                  <entry><classname>A.B.C.D.E</classname></entry>
                </row>

                <row>
                  <entry><classname>P.C.D.E</classname></entry>

                  <entry><classname>P.C.D.E</classname></entry>
                </row>

                <row>
                  <entry><classname>A.B.C.D.E</classname></entry>

                  <entry><classname>A.B.C.D.E</classname></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable></para>

        <para>The salient points in this example are:<itemizedlist spacing="compact">
            <listitem>
              <para>The fully qualified name of a module always resolves to that module.</para>
            </listitem>

            <listitem>
              <para>In the case of <classname>C.D.E</classname>, no preference is given to either
              <classname>A.B.C.D.E</classname> or <classname>P.C.D.E</classname>  it is considered
              ambiguous.</para>
            </listitem>

            <listitem>
              <para>Neither <classname>Z</classname> nor <classname>Y.Z</classname> resolves to the
              current module <classname>W.X.Y.Z</classname>.</para>
            </listitem>

            <listitem>
              <para>Adding an additional component to the front of a resolvable name may make it
              ambiguous (e.g. <classname>D.E</classname>  <classname>C.D.E</classname>)</para>
            </listitem>
          </itemizedlist></para>
      </section>

      <section>
        <title xml:id="StructureOfAModuleFile">Structure of a module file</title>

        <para>A module file has the following basic structure: <synopsis>module <replaceable>module_name</replaceable> ;

<replaceable>import_declaration</replaceable> ;
[<replaceable>import_declaration</replaceable> ; ...]

[<replaceable>friend_declaration</replaceable> ;
[<replaceable>friend_declaration</replaceable> ; ...]]

[<replaceable>definition</replaceable> ;
[<replaceable>definition</replaceable> ; ...]]</synopsis></para>

        <para>The initial module declaration specifies the name of the module represented by this
        file. The import declarations import identifiers from other modules. The friend declarations
        identify other modules that are allowed to import protected-scope identifiers from this
        module. The definitions associate identifiers with values in the current module.</para>

        <para>Module names are identifiers that begin with an upper-case letter.</para>
      </section>

      <section>
        <title>Importing functions and types from other modules</title>

        <para>In order to use functions defined in another module, the other module must first be
        imported with an import declaration. Import declarations are of the following
        form:<synopsis>import <replaceable>module_name</replaceable> [ using 
    <replaceable>using_clause</replaceable> ; 
    [ <replaceable>using_clause</replaceable> ; ... ] ] 
;</synopsis></para>

        <para>Once an identifier has been imported, it can be accessed using its qualified name. A
        qualified name is a module name followed by a period followed by an identifier name. So for
        example <code>Prelude.String</code> refers to the <type>String</type> type defined in the
        <classname>Prelude</classname> module.</para>

        <para>Ex:<informalexample>
            <programlisting>module Example;
import Cal.Core.Prelude;

piSquare = Prelude.pi * Prelude.pi; // OK

circleArea r = pi * r * r;          // !!! Won't compile (unless
                                    //  pi is also defined in the
                                    //  Example module)</programlisting>
          </informalexample></para>

        <section>
          <title>using clauses</title>

          <para>It is often inconvenient to have to qualify the name of each imported identifier
          with its home module. This is particularly true for frequently-used identifiers (ex: the
          standard types defined in the Prelude module). As a convenience, it is possible when
          importing a module to specify a list of identifiers that may be referenced without
          qualification. The list is specified in the using clauses of the import statement. Each
          clause takes the form<synopsis><replaceable>itemKind</replaceable> = <replaceable>identifier</replaceable> [, <replaceable>identifier</replaceable> ...] ;</synopsis>where
          <replaceable>itemKind</replaceable> is one of <code>function</code>,
          <code>dataConstructor</code>, <code>typeConstructor</code>, or <code>typeClass</code>, and
          the identifiers are the identifiers of that kind to import without qualification. It is
          possible to have multiple clauses of the same <replaceable>itemKind</replaceable> in a
          single import statement.</para>

          <para>Ex:<informalexample>
              <programlisting>import Cal.Core.Prelude using
    typeConstructor = Int, Double, String, Boolean, Char;
    dataConstructor = False, True, LT, EQ, GT, Nothing, Just;
    typeClass = Eq, Ord, Num, Inputable, Outputable;
    function = append, compare, concatl
    function = toDouble, field1, field2, upFrom, upFromTo;
;
import Math using
    function = pi;
;

piSquare = Math.pi * Math.pi; // Still OK

circleArea r = pi * r * r;    // OK now, we've imported pi
                              //   as an unqualified
                              //   identifier (i.e., in a
                              //   using clause)</programlisting>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title>Friend modules and protected scope</title>

        <para>It is normally only possible to import an identifier from another module if that
        identifier has been declared as public. Private identifiers can never be imported from other
        modules. However, there is a third kind of scope that identifiers can have: protected
        scope.</para>

        <para>An identifier with protected scope may be imported from another module if the
        importing module is a friend module of the module where the protected identifier is defined.
        Friend modules are specified in the module where the protected identifier is defined by
        listing them at the top of the module after the import declarations.</para>

        <para>Ex:<informalexample>
            <programlisting>// Shape module
module Shape;
import Cal.Core.Prelude;
friend Shape_Tests; 

drawGenericShape :: GenericShape -&gt; String;
protected drawGenericShape genericShape =
    let
        r = unwrapShape genericShape;
    in
        r.draw r.value;

// Shape_Tests module
module Shape_Tests;
import Cal.Core.Prelude;
import Shape;

drawGeneric = Shape.drawGenericShape;  // OK, protected symbols
                                       // in Shape module are
                                       // usable from Shape_Tests
                                       // because the Shape
                                       // module declares
                                       // Shape_Tests as a friend

// ShapeConsumer module
module ShapeConsumer;
import Cal.Core.Prelude;
import Shape;

drawGeneric = Shape.drawGenericShape; // !!! Won't compile,
                                      // ShapeConsumer is not a 
                                      // friend of Shape module</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>Workspaces</title>

        <para>A workspace is a collection of CAL modules that are loaded at the same time and are
        available for import. For example, if modules Alpha, Beta, and Gamma are all in the same
        workspace, then it is possible for Alpha to import Beta or Gamma, but not Delta. If Alpha
        needs to import Delta, then Delta must be added to the workspace.</para>

        <para>Adding modules to a workspace can be done either dynamically (by issuing commands to
        the CAL environment being used, such as ICE or GemCutter), or persistently, by editing the
        workspace specification file. The format of this file is a property of the CAL environment
        being used, and not of the language itself, and is therefore beyond the scope of this
        document.</para>
      </section>
    </section>

    <section>
      <title xml:id="CALDoc">CALDoc</title>

      <para>A CALDoc comment is a piece of end-user and developer visible documentation in the
      source code. Such a comment binds exclusively to the definition that immediately follows it.
      CALDoc comments are allowed for the following kinds of definitions:<itemizedlist
          spacing="compact">
          <listitem>
            <para>modules</para>
          </listitem>

          <listitem>
            <para>functions (algebraic, foreign and primitive) and function type declarations</para>
          </listitem>

          <listitem>
            <para>type classes and class methods</para>
          </listitem>

          <listitem>
            <para>instances and instance methods</para>
          </listitem>

          <listitem>
            <para>types (algebraic and foreign) and data constructors</para>
          </listitem>
        </itemizedlist></para>

      <para>In the case of function definitions and function type declarations, CALDoc comments can
      be used to document both top-level and local definitions (i.e., those defined in
      <code>let</code> expressions). Also, if a function has an associated type declaration, then
      the comment must appear before the type declaration rather than before the function
      definition.</para>

      <para>Only whitespace and regular comments may separate a CALDoc comment from its associated
      definition. Unbound CALDoc comments will result in compilation errors.</para>

      <para>Here are some examples demonstrating the positioning of CALDoc comments with respect to
      their associated definitions:<informaltable>
          <tgroup align="left" cols="2">
            <thead>
              <row>
                <entry>Definition</entry>

                <entry>Examples</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Modules</entry>

                <entry><programlisting>/** ... */
module Draw;</programlisting></entry>
              </row>

              <row>
                <entry>Functions and function type declarations</entry>

                <entry><programlisting>/** ... */
second list = head (tail list);
/** ... */
add1 :: Int -&gt; Int;
add1 x = add 1;

let
    /** ... */
    oneTwoThree :: [Int];
    oneTwoThree = [1, 2, 3];
in
    ...</programlisting></entry>
              </row>

              <row>
                <entry>Type classes and class methods</entry>

                <entry><programlisting>/** ... */
public class Bounded a where
    /** ... */
    public minBound :: a;
    /** ... */
    public maxBound :: a;
    ;</programlisting></entry>
              </row>

              <row>
                <entry>Instances and instance methods</entry>

                <entry><programlisting>/** ... */
instance Bounded Int where
    /** ... */
    minBound = minBoundInt;
    /** ... */
    maxBound = maxBoundInt;
    ;</programlisting></entry>
              </row>

              <row>
                <entry>Types and data constructors</entry>

                <entry><programlisting>/** ... */
data public Maybe a =
    /** ... */
    public Nothing | 
    /** ... */
    public Just 
        value :: a 
    deriving Eq, Ord, Inputable, Outputable;</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <section>
        <title>Structure of a CALDoc comment</title>

        <para>A CALDoc comment begins with a general description section, consisting of an arbitrary
        block of text that may be empty, or may span one or more lines. The description can then be
        followed by a tag segment composed of zero or more tagged blocks.</para>

        <section>
          <title>Block tags and inline tags</title>

          <para>A <firstterm>tag</firstterm> is a special marker within a CALDoc comment that the
          compiler is able to recognize and process. There are two kinds of tags in CALDoc:
          <firstterm>block tags</firstterm> and <firstterm>inline tags</firstterm>.</para>

          <para>A <firstterm>tagged block</firstterm> is a section within a CALDoc comment that
          starts with a block tag. A block tag is formed by the '<literal>@</literal>' character
          followed by one of a few special keywords. The block extends up to, but not including,
          either the first line of the next tagged block, or the end of the CALDoc comment. Tagged
          blocks identify certain information that has a routine structure, such as the intended
          purpose of the arguments of a function, in a form that can be checked and processed by the
          compiler.</para>

          <para>An <firstterm>inline block</firstterm> is a section within a CALDoc comment that is
          delimited by the markers '<code>{@<replaceable>tagName</replaceable></code>' and
          '<code>@}</code>', where <replaceable>tagName</replaceable> is the name of an inline tag.
          Inline blocks can appear anywhere in a CALDoc comment where regular text can appear.
          Through the use of inline tags, one can create structured and formatted text for
          documentation purposes. For example, bulleted lists and emphasized text can be embedded
          into a comment via the use of the <code>{@unorderedList}</code> and the <code>{@em}</code>
          tag respectively.</para>

          <para>In CAL, the use of unsupported tags will result in compilation errors.</para>
        </section>

        <section>
          <title>Text and paragraphs</title>

          <para>A block of text within a CALDoc comment is processed as a list of paragraphs. In
          CALDoc, two paragraphs are separated from one another by a <firstterm>paragraph
          break</firstterm> - one or more blank lines separating the two bodies of text.</para>

          <para>There are also circumstances where a paragraph break is implied by the use of
          certain inline tags: for example, the end of the current paragraph is implied by the start
          of a list (see <xref linkend="ListTags" />).</para>

          <para>In a CALDoc comment, the '<literal>@</literal>' character is treated as part of a
          tag if it appears at the beginning of a comment line (ignoring leading asterisks and
          whitespace), or if it appears directly after a block tag (e.g. '<code>@return</code>'), an
          inline tag (e.g. '<code>{@em</code>'), or a close inline block tag '<code>@}</code>'. If
          you want to include the '<literal>@</literal>' character in your comment text in these
          locations, the character must be escaped as '<code>\@</code>'. As a special case, the
          string '<literal>{@</literal>' can be escaped as either '<code>{\@</code>' or
          '<code>\{@</code>'.</para>
        </section>
      </section>

      <section>
        <title>Supported CALDoc block tags</title>

        <section>
          <title><code>@author <replaceable>author-name</replaceable></code></title>

          <para>The <code>@author</code> tag can be used in any CALDoc comment, and a CALDoc comment
          may contain more than one <code>@author</code> tag. The information in an
          <code>@author</code> block can be an arbitrary block of text. However, we recommend
          specifying one author per <code>@author</code> block. For example:<informalexample>
              <programlisting>@author Luke Evans
@author Bo Ilic</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title><code>@deprecated <replaceable>deprecation-notice</replaceable></code></title>

          <para>The <code>@deprecated</code> tag can be used in any CALDoc comment, and it signifies
          that the documented definition is deprecated and is no longer recommended for use. The
          information in a <code>@deprecated</code> block can be an arbitrary block of text, and is
          meant to be a short description of why the definition is deprecated and what could be used
          in its place. A CALDoc comment may contain at most one <code>@deprecated</code>
          tag.</para>
        </section>

        <section>
          <title><code>@version <replaceable>version-string</replaceable></code></title>

          <para>The following is an example of a <code>@version</code> block, which may be used in
          any CALDoc comment:<informalexample>
              <programlisting>@version 37.2.1-beta2</programlisting>
            </informalexample></para>

          <para>The version information in a <code>@version</code> block can be an arbitrary block
          of text, and is not verified against any predefined syntax. A CALDoc comment may contain
          at most one <code>@version</code> tag.</para>
        </section>

        <section>
          <title><code>@return <replaceable>return-value-description</replaceable></code></title>

          <para>The following is an example of a <code>@return</code> block, which may be used in
          CALDoc comments associated with functions and function type declarations:<informalexample>
              <programlisting>@return {@link LT@}, {@link EQ@}, or {@link GT@} if {@code x@} is
        respectively less than, equal to, or greater than
        {@code y@}.</programlisting>
            </informalexample></para>

          <para>The information in a <code>@return</code> block can be an arbitrary block of text,
          and is meant to be a short description of the returned value. A CALDoc comment (for a
          function) may contain at most one <code>@return</code> tag.</para>
        </section>

        <section>
          <title><code>@arg <replaceable>argument-name</replaceable>
          <replaceable>argument-description</replaceable></code></title>

          <para>The <code>@arg</code> tag is meant to be used for documenting the arguments of
          functions and data constructors. As such, the <code>@arg</code> tag can be used in CALDoc
          comments associated with functions, function type declarations, and data
          constructors.</para>

          <para>The information in an <code>@arg</code> block must consist of the name of the
          argument followed by a short description. The <code>@arg</code> blocks within a CALDoc
          comment must follow the order in which the arguments are declared in the function or data
          constructor definition, starting with the first <code>@arg</code> block documenting the
          first argument. The usual convention is that if a CALDoc comment contains any
          <code>@arg</code> blocks, then all arguments should be documented, one per
          <code>@arg</code> block.</para>

          <para>Also, there cannot be more <code>@arg</code> tags in a CALDoc comment than the
          number of arguments permitted by the type of the function or data constructor. However, it
          is possible to have more <code>@arg</code> tags than lexically declared parameters. For
          example:<informalexample>
              <programlisting>/** 
 * A function application function. This function can also
 * be used in its operator form (which is $).
 *
 * @arg functionToApply the function to be applied.
 * @arg argument the argument to the function evaluation.
 * @return the result of evaluating
 *         {@code (functionToApply argument).@}
 */
apply :: (a -&gt; b) -&gt; a -&gt; b;
public apply !functionToApply = functionToApply;</programlisting>
            </informalexample></para>

          <para>In this example, the function <function>apply</function> has only one lexically
          declared parameter, namely <function>functionToApply</function>. The type of the function,
          however, dictates that <function>apply</function> can be called with a second parameter of
          type <type>a</type>. Therefore, we can document this second argument, and give it a name
          (incidentally, the argument is called '<parameter>argument</parameter>', but it could be
          any other name).</para>

          <para>This ability to document the names of unnamed function arguments also extends to
          foreign functions. For example:<informalexample>
              <programlisting>/**
 * Returns the index within the specified string of the first
 * occurrence of the specified substring, starting at the
 * specified index.
 * 
 * @arg stringToSearch the string to be searched.
 * @arg searchString the substring for which to search.
 * @arg fromIndex the index from which to start the search.
 * @return the index within this string of the first occurrence
 *         of the specified substring, starting at the
 *         specified index.
 */
foreign unsafe import jvm "method indexOf"
    public indexOfString :: String -&gt; String -&gt; Int -&gt; Int;</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title xml:id="SeeTag">The <code>@see</code> tag</title>

          <para>The purpose of the <code>@see</code> tag is to indicate cross-references to other
          CAL definitions. It can be used in any CALDoc comment, and a CALDoc comment can contain
          more than one <code>@see</code> tag.</para>

          <para>A <code>@see</code> block can take on one of the following six forms, depending on
          the kind of definitions to be cross-referenced:<itemizedlist>
              <listitem>
                <synopsis>@see function = {<replaceable>function reference</replaceable>} [, {<replaceable>function reference</replaceable>} ...]</synopsis>
              </listitem>

              <listitem>
                <synopsis>@see dataConstructor = {<replaceable>data constructor reference</replaceable>} [, {<replaceable>data constructor reference</replaceable>} ...]</synopsis>
              </listitem>

              <listitem>
                <synopsis>@see typeConstructor = {<replaceable>type constructor reference</replaceable>} [, {<replaceable>type constructor reference</replaceable>} ...]</synopsis>
              </listitem>

              <listitem>
                <synopsis>@see typeClass = {<replaceable>type class reference</replaceable>} [, {<replaceable>type class reference</replaceable>} ...]</synopsis>
              </listitem>

              <listitem>
                <synopsis>@see module = {<replaceable>module reference</replaceable>} [, {<replaceable>module reference</replaceable>} ...]</synopsis>
              </listitem>

              <listitem>
                <synopsis>@see {<replaceable>reference</replaceable>} [, {<replaceable>reference</replaceable>} ...]</synopsis>
              </listitem>
            </itemizedlist></para>

          <para>In each of the above <code>@see</code> block variants, a reference can either be
          just a name (e.g. <code>Eq</code> or <code>Prelude.map</code>), or one that is surrounded
          by double quotes (e.g. <literal>"makeFileName"</literal> or
          <literal>"Debug.Show"</literal>). Double-quoted names are not checked during the
          compilation process, while unquoted ones are checked to make sure that the definitions
          they reference do indeed exist and are found either in the current module or in its
          imported modules. Double-quoted names are handy for indicating cross-references to related
          definitions in modules that are not imported by the current module.</para>

          <para>In all the cases above except "<code>@see module</code>", a name can either be
          qualified or unqualified, and is treated as a reference to a top-level definition. In
          particular, one cannot refer to local definitions in a <code>@see</code> block.</para>

          <para>The last <code>@see</code> block variant above provides a handy, shorter syntax, one
          which omits the <emphasis>context</emphasis> keyword. In this variant, references of
          different kinds (function and class method names, module names, type constructor names,
          data constructor names, and type class names) can appear in the same block. One
          restriction with this syntax is that <emphasis>unchecked</emphasis>, (i.e. double-quoted)
          references to modules, type constructors, data constructors and type classes are not
          allowed in this kind of <code>@see</code> block.</para>

          <para>The names of CAL entities are often unique enough that using this shorter syntax
          would suffice in many circumstances.</para>

          <para>Also, within a <code>@see</code> block, whitespace is not important - there can be
          any amount of whitespace, or no whitespace at all, on either side of the
          '<literal>=</literal>' and the '<literal>,</literal>' separating the references.</para>

          <para>Here are some examples of <code>@see</code> blocks:<orderedlist>
              <listitem>
                <para>From the Prelude module: <programlisting>/**
 * Represents an ordering relationship between two values:
 * less than, equal to, or greater than.
 * 
 * @see Ord
 * @see compare
 */
data public Ordering = ...</programlisting></para>
              </listitem>

              <listitem>
                <para>A more contrived example:<programlisting>/**
 * This is a test module that tests the compiler's CALDoc
 * handling abilities.
 *
 * @see Prelude, "Cal.Collections.List.zip", Bounded, Maybe
 * @see module = Prelude, "Cal.Collections.List", Debug
 * @see function= Prelude.map,
 *                "Cal.Collections.List.zipWith",id
 * @see typeClass=Prelude.Eq, Bounded
 * @see typeConstructor =Maybe ,"Cal.Collections.Array.Array"
 * @see dataConstructor = Prelude.Left ,
 *                        "Cal.Utilities.Locale.NoDecomposition"
 */
module CALDocTest;

import Prelude using
    function = id;
    typeConstructor = Maybe;
    typeClass = Bounded;
    ;

import Debug;</programlisting></para>
              </listitem>
            </orderedlist></para>
        </section>
      </section>

      <section>
        <title>Supported CALDoc inline tags</title>

        <section>
          <title><code>{@em <replaceable>text</replaceable>@}</code></title>

          <para>Displays <replaceable>text</replaceable> in an emphasized font. For example, in the
          generated HTML documentation, the text would be surrounded by a pair of
          <tag>&lt;em&gt;</tag><tag>&lt;/em&gt;</tag> tags, and would normally be rendered in
          italics.</para>

          <para>Note that the <replaceable>text</replaceable> being emphasized must not contain
          paragraph breaks. To emphasize text spanning more than one paragraph, use a separate
          <code>{@em}</code> block to surround the text on each side of the paragraph break. For
          example:<informalexample>
              <programlisting>/** 
 * Here is an example of emphasized text spanning more than
 * one paragraph: {@em This is a sentence in the first
 * paragraph to be emphasized.@}
 * 
 * {@em This is a sentence in the second paragraph to be
 * emphasized.@}
 */</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title><code>{@strong <replaceable>text</replaceable>@}</code></title>

          <para>Displays <replaceable>text</replaceable> in a strongly emphasized font. For example,
          in the generated HTML documentation, the text would be surrounded by a pair of
          <tag>&lt;strong&gt;</tag><tag>&lt;/strong&gt;</tag> tags, and would normally be rendered
          in bold. The restriction on paragraph breaks for the <code>{@em}</code> tag also applies
          to this tag.</para>
        </section>

        <section>
          <title><code>{@sup <replaceable>text</replaceable>@}</code></title>

          <para>Displays <replaceable>text</replaceable> in superscript. For example, in the
          generated HTML documentation, the text would be surrounded by a pair of
          <tag>&lt;sup&gt;</tag><tag>&lt;/sup&gt;</tag> tags. The restriction on paragraph breaks
          for the <code>{@em}</code> tag also applies to this tag.</para>
        </section>

        <section>
          <title><code>{@sub <replaceable>text</replaceable>@}</code></title>

          <para>Displays text in subscript. For example, in the generated HTML documentation, the
          text would be surrounded by a pair of <tag>&lt;sub&gt;</tag><tag>&lt;/sub&gt;</tag> tags.
          The restriction on paragraph breaks for the <code>{@em}</code> tag also applies to this
          tag.</para>
        </section>

        <section>
          <title><code>{@url <replaceable>url</replaceable>@}</code></title>

          <para>Inserts an inline hyperlink with <replaceable>url</replaceable> both as the visible
          text and as the target of the hyperlink. For example:<informalexample>
              <programlisting>/** 
 * Please visit {@url http://www.businessobjects.com@} for
 * more information.
 */</programlisting>
            </informalexample></para>

          <para>Note that no inline tags can appear within the url itself.</para>
        </section>

        <section>
          <title><code>{@code <replaceable>code-text</replaceable>@}</code></title>

          <para>Displays <replaceable>code-text</replaceable> in a code font. Note that the
          whitespace in <replaceable>code-text</replaceable> is preserved and respected in the
          generated output. Also, blank lines are not interpreted as paragraph breaks within a
          <code>{@code}</code> block - they are simply treated as part of the whitespace content of
          the text.</para>

          <para>Note that if a CALDoc comment line contains leading asterisks, it is only the
          whitespace to the right of such asterisks that is considered part of the code text.</para>
        </section>

        <section>
          <title><code>{@summary <replaceable>summary-text</replaceable>@}</code></title>

          <para>Displays <replaceable>summary-text</replaceable> as it would be displayed without
          the <code>{@summary}</code> tag, but include the text as part of the comment's summary.
          This tag is useful for overriding the default summary-extraction behaviour, which treats
          the first sentence in the first paragraph as the summary. For example, one can include
          more than one sentence in the summary, or have the summary extracted from some location
          other than the first sentence of the comment.</para>

          <para>Note that <replaceable>summary-text</replaceable> cannot contain paragraph breaks.
          If multiple paragraphs are needed for the comment's summary, use one
          <code>{@summary}</code> block for each paragraph to be included in the
          summary:<informalexample>
              <programlisting>/** 
 * TODO: this needs more work
 * 
 * {@summary This is the first sentence of the summary. This
 * is another sentence.@}
 *
 * {@summary This is the {@em second@} paragraph of the summary
 * (the third paragraph of the comment).@}
 *
 * More text of the comment...
 */</programlisting>
            </informalexample></para>

          <para>Note that without the use of the <code>{@summary}</code> blocks above, the summary
          of the comment would have been automatically determined to be <literal>"TODO: this needs
          more work"</literal>.</para>
        </section>

        <section>
          <title>The <code>{@link}</code> tag</title>

          <para>Inserts an inline cross-reference to another CAL definition. This tag is very
          similar to the <code>@see</code> tag. The difference between the two is that
          <code>{@link}</code> generates a link that appears inline with the surrounding text, while
          <code>@see</code> places links in a separate "See Also" section.</para>

          <para>A <code>{@link}</code> block can take on one of the following six forms, depending
          on the kind of definitions to be cross-referenced:<itemizedlist>
              <listitem>
                <synopsis>{@link function = {function reference}@}</synopsis>
              </listitem>

              <listitem>
                <synopsis>{@link dataConstructor = {data constructor reference}@}</synopsis>
              </listitem>

              <listitem>
                <synopsis>{@link typeConstructor = {type constructor reference}@}</synopsis>
              </listitem>

              <listitem>
                <synopsis>{@link typeClass = {type class reference}@}</synopsis>
              </listitem>

              <listitem>
                <synopsis>{@link module = {module reference}@}</synopsis>
              </listitem>

              <listitem>
                <synopsis>{@link {reference}@}</synopsis>
              </listitem>
            </itemizedlist></para>

          <para>The syntax and semantics of the references in the various variants above are the
          same as those for the <code>@see</code> tag (see <xref linkend="SeeTag" />).</para>

          <para>As with the <code>@see</code> tag, the names of CAL entities are often unique enough
          that using the shorter syntax (<code>{@link
          {<replaceable>reference</replaceable>}@}</code>) would suffice in many
          circumstances.</para>

          <para>Within a <code>{@link}</code> block, whitespace is not important - there can be any
          amount of whitespace, or no whitespace at all, on either side of the
          '<literal>=</literal>' and before the '<literal>@}</literal>' ending the block.</para>
        </section>

        <section>
          <title xml:id="ListTags">The <code>{@unorderedList}</code>, <code>{@orderedList}</code>,
          and <code>{@item}</code> tags</title>

          <para>The tags <code>{@unorderedList}</code> and <code>{@orderedList}</code> respectively
          introduce an ordered (i.e. numbered) and an unordered (i.e. bulleted) list. These two tags
          serve a similar purpose to the <tag>&lt;ul&gt;</tag> and <tag>&lt;ol&gt;</tag> tags in
          HTML.</para>

          <para>The appearance of an {@unorderedList} tag or an {@orderedList} tag implies the end
          of the preceding paragraph.</para>

          <para>Within an <code>{@unorderedList}</code> block or an <code>{@orderedList}</code>
          block, the only permitted content is a set of zero or more <code>{@item}</code> blocks,
          which can be separated by whitespace. A <code>{@item}</code> block correspond to the
          <code>&lt;li&gt;</code> tag in HTML, and signifies a list item for the enclosing list. The
          content of a list item can be one or more paragraphs, separated by paragraph breaks. Also,
          a list can itself be nested within an item of another list. For example:<informalexample>
              <programlisting>/** 
 * Here are a few important points:
 * {@orderedList
 *    {@item This is point #1.@}
 *    {@item This is point #2.@}
 *    {@item
 *        A list item can contain more than one paragraph.
 *
 *        As shown here (this is the second paragraph).
 *    @}
 *    {@item
 *        A list item can contain any text or inline blocks,
 *        including nested lists, e.g.:
 *
 *        {@unorderedList
 *            {@item Red@}
 *            {@item Green@}
 *            {@item Blue@}
 *        @}
 *
 *        and code blocks:
 *        {@code
 *         let
 *             f = 3.0;
 *         in
 *             f + f
 *        @}
 *    @}
 * @}
 */</programlisting>
            </informalexample></para>
        </section>
      </section>
    </section>

    <section>
      <title>Standard functions and techniques</title>

      <para>This section details some common techniques and functions for dealing with various
      common types of CAL data.</para>

      <section>
        <title xml:id="Lists">Lists</title>

        <para>Lists are by far the most commonly-used algebraic data structures in CAL (and in most
        functional languages). There are a number of standard techniques for dealing with data
        stored in a list.</para>

        <section>
          <title>Higher-order functions</title>

          <para>A higher-order function is a function that can accept another function as one of its
          arguments. A number of the common operations upon lists have been extracted into standard
          higher-order functions. These functions are defined in the <classname>List</classname>
          module.</para>

          <section>
            <title><function>map</function></title>

            <para>The <function>map</function> function accepts a function and a list. It applies
            the provided one-argument function to each element of the provided list, and returns a
            list of the results. For example, the single expression<informalexample>
                <literallayout><userinput>map round [1.2, 1.75, 3.0, 4.9]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[1, 2, 3, 5]</computeroutput></literallayout>
              </informalexample>will convert a list of <type>Double</type>s into a list of
            <type>Int</type>s.</para>
          </section>

          <section>
            <title><function>filter</function></title>

            <para>The filter <function>function</function> also accepts a function and a list. It
            applies the provided one-argument function to each element of the provided list, and
            returns a list of the elements for which the provided function returned
            <function>True</function>. Note that the provided function must be a predicate, i.e., it
            must return a <type>Boolean</type>.</para>

            <para>Ex: The following expression takes a list of <type>Maybe</type>s and return only
            the elements that are not <function>Nothing</function>:<informalexample>
                <literallayout><userinput>filter isJust [Just 'a', Just 'b', Nothing, Nothing, Just 'c']</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[Just 'a', Just 'b', Just 'c']</computeroutput></literallayout>
              </informalexample></para>

            <para>This can be combined with <function>map</function> to obtain a list of the
            <type>Char</type>s that are contained in the non-<function>Nothing</function>
            elements:<informalexample>
                <literallayout><userinput>map fromJust (filter isJust [Just 'a', Just 'b', Nothing, Nothing, Just 
'c'])</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>['a', 'b', 'c']</computeroutput></literallayout>
              </informalexample></para>
          </section>

          <section>
            <title><function>foldRight</function> and <function>foldLeftStrict</function></title>

            <para><function>foldRight</function> accepts a 2-argument function (called the "folding
            function"), an initial value, and a list. The folding function is applied in turn to
            each element of the list along with the result of the previous application (or with the
            starting value, for the first application). The result of all of these applications is a
            single result value.</para>

            <para>In other words, <function>foldRight</function> returns the result of applying the
            folding function to the first element of the list argument and the result of a recursive
            call to <function>foldRight</function>. Ex:<programlisting>foldRight add 0.0 [5, 4, 6, 1]</programlisting>is
            equivalent to<programlisting>add 5 (add 4 (add 6 (add 1 0.0)))</programlisting></para>

            <para>There is a related function called <function>foldLeft</function>, which returns
            the result of applying its function argument to a recursive call to
            <function>foldLeft</function> and the first element of the list argument.
            Ex:<programlisting>foldLeft add 0.0 [5, 4, 6, 1]</programlisting>is equivalent
            to<programlisting>add (add (add (add 0.0 5) 4) 6) 1</programlisting></para>

            <para>In most situations, <function>foldLeft</function> is less space-efficient than
            <function>foldRight</function> and should not be used. The reason has to do with
            differences in how the calls are reduced. <function>foldRight</function> reduces to a
            call to the folding function (with one argument being a recursive call to
            <function>foldRight</function>), whereas <function>foldLeft</function> reduces to
            another call to <function>foldLeft</function>. Ex:<screen>foldRight add 0.0 [5, 4, 6, 1]</screen>reduces
            (after a single reduction step) to<screen>add 5 (foldRight add 0.0 [4, 6, 1])</screen></para>

            <para>In contrast, the following <function>foldLeft</function> call<programlisting>foldLeft add 0.0 [5, 4, 6, 1]</programlisting>reduces
            (after a single reduction step) to<programlisting>foldLeft add (add 0.0 5) [4, 6, 1]</programlisting></para>

            <para>Because the <function>foldRight</function> call reduces to a call to the folding
            function, the folding function has the opportunity to begin producing output before the
            entire list is evaluated. In contrast, when using <function>foldLeft</function>, the
            folding function will not be evaluated until the entire list has been traversed. This
            makes <function>foldLeft</function> particularly ill-suited to processing infinite
            lists.</para>

            <para>However, there is a strict version of <function>foldLeft</function> called
            <function>foldLeftStrict</function> which allows for a more efficient evaluation of
            functions that are strict in both arguments. This is because
            <function>foldLeftStrict</function> evaluates the call to the function argument at each
            recursive step, whereas <function>foldRight</function> returns a lazy value representing
            the application of the function argument to an element of the list argument and a
            recursive call to <function>foldRight</function>. So, the following call<programlisting>foldLeftStrict add 0.0 [5, 4, 6, 1]</programlisting>reduces
            (after a single reduction step) to<programlisting>foldLeftStrict add 5.0 [4, 6, 1]</programlisting>because
            the call to the folding function is evaluated immediately. This is a much more efficient
            way to fold a strict function over a list.</para>

            <para>Fortunately, out of all this analysis comes a simple rule of thumb: When the
            folding function is strict in both arguments, use <function>foldLeftStrict</function>.
            Otherwise, use <function>foldRight</function>. Some functions, such as
            <function>subtract</function>, are not commutative. That is, the order of their
            arguments makes a difference. For such functions, <function>foldLeftStrict</function>
            and <function>foldRight</function> can produce different results. Ex:<informalexample>
                <literallayout><userinput>foldLeftStrict subtract 0.0 [1, 1, 1]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>-3.0</computeroutput></literallayout>
              </informalexample><informalexample>
                <literallayout><userinput>foldRight subtract 0.0 [1, 1, 1]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>1.0</computeroutput></literallayout>
              </informalexample></para>

            <para>In these situations, it's necessary to choose the function that produces the
            correct associativity. If you need a function with left associativity, it is better to
            choose <function>foldLeftStrict</function> than <function>foldLeft</function> if at all
            possible. Only choose <function>foldLeft</function> if you need left-associativity and
            it is important that the folding function's arguments be evaluated non-strictly.</para>
          </section>
        </section>

        <section>
          <title>List-manipulation utility functions</title>

          <para>In addition to the standard higher-order functions for operating on lists, CAL
          provides some utility functions for accessing elements and properties of a list.</para>

          <section>
            <title><function>head</function> and <function>tail</function></title>

            <para>The <function>head</function> function accepts a list and returns its first
            element. The <function>tail</function> function accepts a list and returns all of the
            list's elements except the first.</para>

            <para>Ex:<informalexample>
                <literallayout><userinput>head [1,2,3]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>1</computeroutput></literallayout>
              </informalexample><informalexample>
                <literallayout><userinput>tail [1,2,3]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[2,3]</computeroutput></literallayout>
              </informalexample></para>
          </section>

          <section>
            <title><function>length</function></title>

            <para>The <function>length</function> function accepts a list and returns its length.
            The empty list has length 0, a list with one element has length 1, etc.</para>
          </section>
        </section>

        <section>
          <title>Recursive list handling</title>

          <para>A common pattern is to process the elements of a list one at a time, unpacking the
          head and tail of the list using a <code>case</code> expression:<informalexample>
              <programlisting>sumList1 :: Num a =&gt; [a] -&gt; a;
public sumList1 list =
    let
        sumHelper list !acc =
            case list of
            [] -&gt; 0;
            head : rest -&gt; sumHelper rest (acc + head);
            ;
    in
        sumHelper list 0;</programlisting>
            </informalexample></para>

          <para>Note that many such functions can be replaced by calls to
          <function>foldRight</function> or <function>foldLeftStrict</function> (when a single value
          is being accumulated) or to <function>map</function> or <function>filter</function> (when
          a list is being transformed into another list). Ex:<informalexample>
              <programlisting>sumList :: Num a =&gt; [a] -&gt; a;
public sumList list = foldLeftStrict add 0 list;</programlisting>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title>Records</title>

        <section>
          <title>Unpacking named fields using the field selection operator</title>

          <para>The easiest way to extract a specific field from a record is by using the field
          selection operator (<function role="operator">.</function>):<informalexample>
              <literallayout><userinput>{name = "Phillipe", age = 5.0}.age</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>5.0</computeroutput></literallayout>
            </informalexample></para>

          <para>Attempting to retrieve a field from a record that does not contain that field
          results in an error:<informalexample>
              <literallayout><userinput>{name = "Phillipe", age = 5.0}.job</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type error. Invalid record selection for field job. Caused by:
the record type {age :: Prelude.Double, name :: Prelude.String} is 
missing the fields [job] from the record type a\job =&gt; {a | job :: b}.</computeroutput></literallayout>
            </informalexample></para>
        </section>

        <section>
          <title>Unpacking named fields using case expressions</title>

          <para>Another method for handling records in CAL is the case expression (see <xref
          linkend="MatchingRecords" /> for a detailed description). The usual situation is to want
          to extract a specific named field or fields from a record, which may contain other,
          unspecified fields:<informalexample>
              <programlisting>recTo2DPoint rec =
    case rec of
    {_ | x, y} -&gt; (x,y);
    ;</programlisting>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title>Tuples</title>

        <section>
          <title>Unpacking tuple components using the field selection operator</title>

          <para>Since tuples are special cases of records, the same field selection operator that is
          used to extract named fields from records can be used for tuples. The first component of a
          tuple is named <varname>#1</varname>, the second component is named <varname>#2</varname>,
          etc:<informalexample>
              <literallayout><userinput>('C', 0.61, 0.65).#1</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>'C'</computeroutput></literallayout>
            </informalexample></para>

          <para>As with general records, attempting to extract a component that a tuple doesn't
          contain will result in a runtime error:<informalexample>
              <literallayout><userinput>('C', 0.61, 0.65).#4</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type error. Invalid record selection for field #4. Caused by: 
the record type (Prelude.Char, Prelude.Double, Prelude.Double) is 
missing the fields [#4] from the record type a\#4 =&gt; {a | #4 :: b}.</computeroutput></literallayout>
            </informalexample></para>
        </section>

        <section>
          <title>Unpacking tuple components using case expressions</title>

          <para>See <xref linkend="MatchingTuples" /> for a detailed description of using case
          expressions to extract components from tuples. Case expressions allow an expression to
          refer to each component of a tuple by name: <informalexample>
              <programlisting>twoDPointToRec point =
    case point of
    (xVal, yVal) -&gt; {x=xVal, y=yVal};
    ;</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title>Unpacking tuple components using utility functions</title>

          <para>CAL also provides a number of utility functions for extracting the components of
          various tuple types. These functions have names of the form <varname>fieldN</varname>, and
          return the <phrase role="formula">N</phrase>th component of a tuple. Ex:<informalexample>
              <literallayout><userinput>field1 (1,2,3)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>1</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>field2 (1,2,3)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>2</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>field3 (1,2,3,4)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>3</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>field3 (1,2,3,4,5)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>3</computeroutput></literallayout>
            </informalexample></para>

          <para>These functions are provided for the first 7 components (i.e.,
          <function>field1</function> to <function>field7</function>).</para>

          <para>In addition, two specially-named functions are provided for the first two
          components:<informalexample>
              <literallayout><userinput>fst (1,2)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>1</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>snd (1,2)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>2</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>snd (1,2,3)</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Type Error during an application. Caused by: the fields of
the two record type (a, b) and (Prelude.Double, Prelude.Double, 
Prelude.Double) must match exactly.</computeroutput></literallayout>
            </informalexample></para>

          <para>Unlike <function>field1</function> and <function>field2</function> (which can be
          applied to any record with a <varname>#1</varname> or <varname>#2</varname> field
          respectively), <function>fst</function> and <function>snd</function> can only be applied
          to pairs. This is why the third expression above fails.</para>
        </section>
      </section>

      <section>
        <title>Algebraic types</title>

        <section>
          <title>Unpacking data constructor using case expressions</title>

          <para>See <xref linkend="MatchingDataConstructors" /> for a detailed description of using
          case expressions to unpack data constructors. Case expressions are the most general way to
          extract components from an algebraic value:<informalexample>
              <programlisting>data MyTupleType a =
    MyTuple2 
        elem1 :: a 
        elem2 :: a |
    MyTuple3
        elem1 :: a 
        elem2 :: a
        elem3 :: a
    ;

addMyTupleElems :: Num a =&gt; MyTupleType a -&gt; a;
addMyTupleElems myTuple =
    case myTuple of
    MyTuple2 elem1 elem2 -&gt; elem1 + elem2;
    MyTuple3 elem1 elem2 elem3 -&gt; elem1 + elem2 + elem3;
    ;</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title>Extracting data constructor arguments using the field selection operator</title>

          <para>If an algebraic value is known to be a specific data constructor value, and that
          value has only one component field of interest, the easiest way to extract that value is
          by using the field selection operator (<function
          role="operator">.</function>):<informalexample>
              <literallayout><userinput>(Just 2.0).Just.value     // The arg to Just is named value'</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>2.0</computeroutput></literallayout>
            </informalexample></para>

          <para>If the wrong data constructor is encountered during field selection, a runtime error
          occurs:<informalexample>
              <literallayout><userinput>(Nothing :: Maybe Double).Just.value</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Wrong data constructor value selected. Expecting: 
Prelude.Just, found: Prelude.Nothing.</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>
    </section>

    <section>
      <title>Advanced topics</title>

      <section>
        <title>Evaluation of expressions</title>

        <para>Most nested expressions can be evaluated in multiple orders. For example, with
        increment defined as follows:<programlisting>increment :: Int -&gt; Int;
increment x = x + 1;</programlisting>consider the expression <code>increment (2 * 3)</code>. One
        possible order to evaluate this expression is:<literallayout><code>increment (2 * 3)
(2 * 3) + 1
6 + 1
7</code></literallayout></para>

        <para>Another is:<literallayout><code>increment (2 * 3)
increment 6
6 + 1
7</code></literallayout></para>

        <para>In the first case, we chose to reduce the application of the
        <function>increment</function> function first. In the second case, we chose to reduce the
        application of the <function role="operator">*</function> operator first.</para>

        <para>We say that in the first case, we chose to reduce the "outermost reducible expression"
        (or outermost redex) first. An outmost redex is one that is contained in no other redex. In
        the second case, we chose to reduce the innermost redex first. An innermost redex is one
        that contains no other redex.</para>

        <para>Let's look at another example. First, the outermost-first reduction:<literallayout><code>head (45 : list1 (myFactorial 3))
45</code></literallayout></para>

        <para>And the same expression evaluated using innermost-first reduction:<literallayout><code>head (45 : list1 (myFactorial 3))
head (45 : list1 (3 * (myFactorial (3 - 1)))
head (45 : list1 (3 * (myFactorial 2))
head (45 : list1 (3 * 2 * (myFactorial (2 - 1)))
head (45 : list1 (3 * 2 * (myFactorial 1))
head (45 : list1 (3 * 2 * 1 * (myFactorial (1 - 1)))
head (45 : list1 (3 * 2 * 1 * (myFactorial 0))
head (45 : list1 (3 * 2 * 1 * 1))
head (45 : list1 (6 * 1 * 1))
head (45 : list1 (6 * 1))
head (45 : list1 6)
head (45 : [6])
45</code></literallayout></para>

        <para>Note that the innermost-first reduction order requires many more steps to calculate
        the same result. This is because it calculates the value of the <code>list1 (myFactorial
        3)</code> expression - a value that is ultimately discarded.</para>

        <para>CAL uses an outermost-first, or "lazy", evaluation order. This contrasts with most
        languages, which use an innermost-first, or "strict", evaluation order. Lazy evaluation gets
        its name because it avoids calculating the values of expressions that are not needed for the
        final value of an expression (such as <code>list1 (myFactorial 3)</code>).</para>

        <para>We can verify that CAL uses lazy evaluation by entering the following expression into
        ICE:<informalexample>
            <literallayout><userinput>head (45 : list1 (error "you should never see this")) :: Int</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>45</computeroutput></literallayout>
          </informalexample></para>

        <para>If the application of <function>error</function> had been evaluated (as it would have
        been in a strict evaluation order), an error message would have been displayed. Instead, a
        value of 45 was returned.</para>

        <section>
          <title>Infinite data structures</title>

          <para>One of the techniques that lazy evaluation makes possible is the infinite data
          structure. For example, it is possible to write a function in CAL that returns a list of
          all of the non-negative even numbers:<informalexample>
              <programlisting>evensFrom :: Int -&gt; [Int];
evensFrom start =
    start : evensFrom (start + 2);
evens :: [Int];
evens = evensFrom 0;</programlisting>
            </informalexample></para>

          <para>In a non-lazy (or "strict") language, any application of the
          <function>evens</function> function would result in an infinite loop, with the computer
          attempting to calculate the infinite list of every even number before it could return.
          However, in CAL, it is possible to safely apply <function>evens</function>, so long as
          only some finite subset of the list is required. For example, using the
          <function>evens</function> function defined above in conjunction with the standard
          <function>take</function> function (which returns the first <phrase
          role="formula">n</phrase> elements of any list, for some <phrase
          role="formula">n</phrase>), we can find the first 5 even numbers:<informalexample>
              <literallayout><userinput>take 5 evens</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[0, 2, 4, 6, 8]</computeroutput></literallayout>
            </informalexample></para>
        </section>

        <section>
          <title>The <function>seq</function> function</title>

          <para>There are some situations where lazy evaluation is undesirable. Strict evaluation
          can be both faster and more space-efficient than lazy evaluation for non-shared values
          that are actually evaluated.</para>

          <para>For situations where this is known to be the case, CAL provides the ability to force
          the order in which expressions will be reduced. One way to do this is by using the
          <function>seq</function> function. The <function>seq</function> function takes two
          arguments. It forces the first argument to be reduced until it is in "Weak Head Normal
          Form"; then it returns the value of the second argument.</para>

          <para>For algebraic types (i.e., lists, records, tuples, and user-defined types), Weak
          Head Normal Form is the point where the outermost data constructor for the value is known.
          For numeric types (<type>Double</type>, <type>Int</type>, <foreignphrase>et
          al</foreignphrase>), Weak Head Normal Form is the point at which the numeric value of the
          expression is known. <footnote>
              <para>One can think of a numeric type as an algebraic type with an infinite number of
              data constructors. e.g., one can think of the <type>Integer</type> type as being
              defined by <code>data public Integer = 0 | 1 | 2 | 3 | ...</code>. When one thinks of
              numeric types in this way, then the two definitions of Weak Head Normal Form are
              equivalent.</para>
            </footnote></para>

          <para>Note the distinction between "evaluated until WHNF" and "evaluated completely".
          Lists are evaluated only until the outermost data constructor is known (i.e., until it is
          known whether the list is empty or not). This means that it is still possible to force the
          evaluation of infinite lists using <function>seq</function> without causing an infinite
          loop.</para>

          <para>As an example of the effect of the seq function, consider the following two
          definitions:<programlisting>cons :: a -&gt; [a] -&gt; [a];
cons x y = x : y;</programlisting><programlisting>strictCons :: a -&gt; [a] -&gt; [a];
strictCons x y = seq y (x : y);</programlisting></para>

          <para>Both <function>cons</function> and <function>strictCons</function> return a list
          containing the first argument followed by the elements of the second argument. However,
          their reductions look quite different. Here is the reduction of <function>cons
          (myFactorial 3) (cons (3 + 4) [8, 9])</function>:<literallayout><code>cons (myFactorial 3) (cons (3 + 4) [8, 9])
(myFactorial 3) : (cons (3 + 4) [8, 9])
(3 * (myFactorial (3 - 1)) : (cons (3 + 4) [8, 9])
(3 * (myFactorial 2) : (cons (3 + 4) [8, 9])
(3 * 2 * (myFactorial (2 - 1)) : (cons (3 + 4) [8, 9])
(6 * (myFactorial (2 - 1)) : (cons (3 + 4) [8, 9])
(6 * (myFactorial 1)) : (cons (3 + 4) [8, 9])
(6 * 1 * (myFactorial (1 - 1))) : (cons (3 + 4) [8, 9])
(6 * (myFactorial (1 - 1))) : (cons (3 + 4) [8, 9]) 
(6 * (myFactorial 0)) : (cons (3 + 4) [8, 9])
(6 * 1) : (cons (3 + 4) [8, 9])
6 : (cons (3 + 4) [8, 9])
6 : ((3 + 4) : [8, 9])
6 : (7 : [8, 9])
[6, 7, 8, 9]</code><footnote xml:id="SeqClarityRewriteFootnote">
                <para>This step is just a rewrite for clarity, not a reduction. <code>
e.g. [6, 7, 8, 9]</code> is a shorthand notation for <code>6 : (7 : (8 : ( 9 : [])))</code>
</para>
              </footnote></literallayout></para>

          <para>Compare this with the reduction of the equivalently-valued <code>strictCons
          (myFactorial 3) (strictCons (3 + 4) [8, 9])</code>: <literallayout><code>strictCons (myFactorial 3) (strictCons (3 + 4) [8, 9])
strictCons (myFactorial 3) ((3 + 4) : [8, 9])
strictCons (myFactorial 3) (7 : [8, 9])
strictCons (myFactorial 3) [7, 8, 9]</code><footnoteref linkend="SeqClarityRewriteFootnote" /><code>
(myFactorial 3) : [7, 8, 9]
(3 * myFactorial (3 - 1)) : [7, 8, 9]
(3 * myFactorial 2) : [7, 8, 9]
(3 * 2 * myFactorial (2 - 1)) : [7, 8, 9]
(6 * myFactorial (2 - 1)) : [7, 8, 9]
(6 * myFactorial 1) : [7, 8, 9]
(6 * 1 * myFactorial (1 - 1)) : [7, 8, 9]
(6 * myFactorial (1 - 1)) : [7, 8, 9]
(6 * myFactorial 0) : [7, 8, 9]
(6 * 1) : [7, 8, 9]
6 : [7, 8, 9]
[6, 7, 8, 9]</code><footnoteref linkend="SeqClarityRewriteFootnote" /></literallayout></para>

          <para>Note that <function>strictCons</function>'s use of the <function>seq</function>
          function forces its second argument (in this case, <code>(strictCons (3 + 4) [8,
          9])</code>) to be reduced before its first argument (<code>myFactorial 3</code>).</para>
        </section>

        <section>
          <title>Strict parameters</title>

          <para>CAL provides the ability to flag certain parameters as strict by prepending them
          with an exclamation point (or "pling"):<informalexample>
              <programlisting>myHead :: [a] -&gt; a;
public myHead !list =
    case list of
    firstElement : _  -&gt; firstElement;
    []     -&gt; error "empty list.";
    ;</programlisting>
            </informalexample></para>

          <para>In the definition of <function>myHead</function> above, for example, the
          <parameter>list</parameter> parameter has been flagged as strict. This indicates that the
          value passed into head as <parameter>list</parameter> will be evaluated until it is in
          "Weak Head Normal Form" before the function itself is evaluated.</para>

          <para>Plinged arguments are evaluated in left-to-right order before the body of the
          function is returned. For example, the following two definitions of
          <function>notEqualsList</function> are equivalent:<informalexample>
              <programlisting>private notEqualsList1 !l1 !l2 = 
    not (equalsList l1 l2);
private notEqualsList2 l1 l2 = 
    seq l1 
    (seq l2
    (not (equalsList l1 l2)));</programlisting>
            </informalexample></para>

          <para>The first version flags the <parameter>l1</parameter> and <parameter>l2</parameter>
          parameters as strict. The second version uses nested applications of
          <function>seq</function> to force <parameter>l1</parameter> and <parameter>l2</parameter>
          to be reduced (in that order) before the body expression is returned.</para>

          <para>It is good practice to flag a parameter to a function as strict whenever you know
          that its value (or data constructor) will be required for the evaluation of the function.
          Consider the following definition of the <type>Boolean</type> <function>and</function>
          operation:<programlisting>and :: Boolean -&gt; Boolean -&gt; Boolean;
public and !a b =
    case a of
    False -&gt; False;
    True -&gt; b;
    ;</programlisting></para>

          <para>Note that the first parameter is strict, but the second is not. This is because the
          data constructor of the first parameter is required in order to determine which case
          alternative to follow. However, the value of the second parameter does not influence the
          execution of the function. It is returned as-is in the <function>True</function>
          alternative, and not at all in the <function>False</function> alternative. Since the value
          of the second parameter is not needed in order to determine the result of the
          <function>and</function> function, there is no reason to flag it as strict.</para>
        </section>

        <section>
          <title>Recursion and the stack</title>

          <para>In most languages, each function call requires additional stack space. This means
          that the number of recursive function calls that can be made by a function in these
          languages is limited by the size of the stack.</para>

          <para>However, thanks to lazy evaluation, recursive CAL functions often use no more stack
          than a single function call. For example, consider this definition of a function similar
          to the <function>List.map</function> function:<informalexample>
              <programlisting>/**
 * 'myMap mapFunction list' applies the function mapFunction to 
 * each element of the list and returns the resulting list.
 * 
 * @arg mapFunction
 *        a function to be applied to each element of the list.
 * @arg list
 *        the list.
 * @return the list obtained by applying mapFunction to each 
 * element of the list.
 */
myMap :: (a -&gt; b) -&gt; [a] -&gt; [b];
public myMap mapFunction !list =
    case list of
    [] -&gt; [];
    listHead : listTail -&gt; 
        mapFunction listHead : myMap mapFunction listTail;
    ;</programlisting>
            </informalexample></para>

          <para>Each call to <function>myMap</function> returns either <function>[]</function> (when
          the empty list is passed in), or a <function>Cons</function> data constructor whose head
          is a (not yet evaluated) application of <function>mapFunction</function> to
          <parameter>listHead</parameter> and whose tail is a (not yet evaluated) application of
          <function>myMap</function> to <parameter>mapFunction</parameter> and
          <parameter>listTail</parameter>. In other words, each step of the reduction of an
          expression involving <function>myMap</function> is a single function call, rather than
          being a list of nested function calls as it would be in an eager language such as Java or
          C++.</para>

          <para>There is, however, one class of recursive CAL function that does use additional
          stack for each recursive call. Any function whose return value is strict (in the sense
          that it is either a numeric value or a type whose data constructors take strict arguments)
          may require additional stack for each recursive call.</para>

          <para>Ex:<informalexample>
              <programlisting>data MyLazyList a =
    MyLazyNil |
    MyLazyCons 
        head :: a 
        tail :: (MyLazyList a); 
data MyStrictList a =
    MyStrictNil |
    MyStrictCons 
        head :: a 
        tail :: !(MyStrictList a); 
makeMyLazyList :: [a] -&gt; MyLazyList a;
makeMyLazyList x =
    case x of
    [] -&gt; MyLazyNil;
    first : rest -&gt; MyLazyCons first (makeMyLazyList rest);
    ;
makeMyStrictList :: [a] -&gt; MyStrictList a; 
makeMyStrictList x =
    case x of
    [] -&gt; MyStrictNil;
    first : rest -&gt; MyStrictCons first (makeMyStrictList rest);
    ;</programlisting>
            </informalexample></para>

          <para>In the example code above, we have defined two types that have the same form as the
          built-in <type>List</type> type: <type>MyLazyList</type> and <type>MyStrictList</type>.
          <type>MyLazyList</type> is equivalent to the built-in <type>List</type> type (with the
          <function>MyLazyNil</function> data constructor corresponding to the
          <function>Nil</function> data constructor, and the <function>MyLazyCons</function> data
          constructor corresponding to the <function>Cons</function> data constructor).
          <type>MyStrictList</type> is equivalent to the built-in <type>List</type> type with one
          difference: The <parameter>tail</parameter> parameter of <function>MyStrictCons</function>
          is strict rather than lazy.</para>

          <para>The <function>makeMyStrictList</function> and <function>makeMyLazyList</function>
          functions convert a regular CAL list into a <type>MyStrictList</type> and
          <type>MyLazyList</type> respectively. However, one causes a stack overflow when applied to
          large lists, while the other does not:<informalexample>
              <literallayout><userinput>(makeMyLazyList (upFromTo 0 100000 :: [Int])).MyLazyCons.head</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>0</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>(makeMyStrictList (upFromTo 0 100000 :: [Int])).MyStrictCons.head</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>The java virtual machine encountered an error.
Caused by: java.lang.StackOverflowError,  Detail: null
</computeroutput></literallayout>
            </informalexample></para>

          <para>The reason that <function>makeMyStrictList</function> requires additional stack for
          each call is that in order to evaluate the first call, it must evaluate all of the
          recursive calls as well (since the strict <parameter>tail</parameter> parameter requires
          the recursive call to be reduced to WHNF before the <type>MyStrictCons</type> value can be
          constructed). By contrast, <function>makeMyLazyList</function> can construct and return
          the <type>MyLazyCons</type> value without having to make a recursive call. The recursive
          call will happen if and when the value of <parameter>tail</parameter> is requested.</para>

          <section>
            <title>Tail recursive functions</title>

            <para>Even recursive functions that must return strict values can be written to require
            only constant stack, so long as they are tail recursive.</para>

            <para>A tail recursive function is a recursive function where the recursive call (or
            calls) is in tail position. A function call is in tail position if the result of the
            function call is returned directly:<informalexample>
                <programlisting>sumIntList1 :: [Integer] -&gt; Integer;
sumIntList1 numList =
    case numList of
    [] -&gt; 0;
    first : rest -&gt; first + sumIntList1 rest;
    ;
sumIntList2 :: [Integer] -&gt; Integer -&gt; Integer;
sumIntList2 numList accum =
    case numList of
    [] -&gt; accum;
    first : rest -&gt; sumIntList2 rest (accum + first);
    ;</programlisting>
              </informalexample></para>

            <para>In the above code, the recursive call to <function>sumIntList2</function> is in
            tail position, because the result from <function>sumIntList2</function> is returned
            directly without any additional processing.</para>

            <para>In contrast, the recursive call to <function>sumIntList1</function> is
            <emphasis>not</emphasis> in tail position, because the result from the call to
            <function>sumIntList1</function> is passed as an argument to the addition operator
            rather than being returned directly. The addition operator is in tail position in
            sumIntList1 rather than the recursive call.</para>

            <para>Although <function>sumIntList2</function> does not use extra stack at each
            recursive invocation, it is still not ideal. Its <parameter>accum</parameter> parameter
            is lazily evaluated. This means that an invocation such as <code>sumIntList2 [5,6,7,8]
            0</code> would reduce as follows:<literallayout><code>sumIntList2 [5, 6, 7, 8] 0
sumIntList2 [6, 7, 8] (5 + 0)
sumIntList2 [7, 8] (6 + (5 + 0))
sumIntList2 [8] (7 + (6 + (5 + 0)))
sumIntList2 [] (8 + (7 + (6 + (5 + 0))))
(8 + (7 + (6 + (0 + 5))))</code></literallayout></para>

            <para>Although the recursive invocations of <function>sumIntList2</function> took no
            extra stack, the invocations of the addition operator to evaluate
            <parameter>accum</parameter> at the end of the recursion will require enough stack to
            make <phrase role="formula">n</phrase> calls (where the input list had n elements). This
            means that the tail-recursive <function>sumIntList2</function> can still overflow the
            stack for sufficiently large inputs!</para>

            <para>Fortunately, by making the <parameter>accum</parameter> parameter strict, we can
            force each addition to be evaluated at the time of the recursive call. This eliminates
            the need to evaluate a large, nested addition at the end of the
            recursion.<informalexample>
                <programlisting>sumIntList3 :: [Integer] -&gt; Integer -&gt; Integer;
sumIntList3 numList !accum =
    case numList of
    [] -&gt; accum;
    first : rest -&gt; sumIntList3 rest (accum + first);
    ;</programlisting>
              </informalexample></para>

            <para><function>sumIntList3</function> is identical to <function>sumIntList2</function>,
            except that its accumulator argument is flagged as strict. This forces its
            <parameter>accum</parameter> argument to be reduced before each recursive
            application:<literallayout><code>sumIntList3 [5, 6, 7, 8] 0
sumIntList3 [6, 7, 8] (5 + 0)
sumIntList3 [6, 7, 8] 5
sumIntList3 [7, 8] (6 + 5)
sumIntList3 [7, 8] 11
sumIntList3 [8] (7 + 11)
sumIntList3 [8] 18
sumIntList3 [] (8 + 18)
sumIntList3 [] 26
26</code></literallayout></para>

            <para>Note that at each stage of reduction, the value of accum is always an expression
            with 0 or 1 addition operations. Unlike the previous two sum functions, this strict
            tail-recursive version can be called with a list of any size without overflowing the
            stack:<informalexample>
                <literallayout><userinput>sumIntList1 (upFromTo 0 5000)</userinput>
<emphasis role="bold-italic">Error</emphasis> <computeroutput>while executing: The java virtual machine encountered an error.
Caused by: java.lang.StackOverflowError,  Detail: null</computeroutput></literallayout>
              </informalexample><informalexample>
                <literallayout><userinput>sumIntList2 (upFromTo 0 5000) 0</userinput>
<emphasis role="bold-italic">Error</emphasis> <computeroutput>while executing: The java virtual machine encountered an error.
Caused by: java.lang.StackOverflowError,  Detail: null</computeroutput></literallayout>
              </informalexample><informalexample>
                <literallayout><userinput>sumIntList3 (upFromTo 0 20000) 0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>200010000</computeroutput></literallayout>
              </informalexample><informalexample>
                <literallayout><userinput>sumIntList3 (upFromTo 0 100000) 0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>5000050000</computeroutput></literallayout>
              </informalexample></para>
          </section>
        </section>
      </section>

      <section>
        <title xml:id="DynamicTyping">Dynamic typing</title>

        <para>Most of the time, CAL's type system provides an extremely valuable mechanism for
        helping to ensure program correctness. However, there are rare occasions where you want to
        have, for example, a list that can contain different types of data. CAL's type system does
        not normally allow lists whose elements are not all of the same type. However, by wrapping
        each value (of whichever type) in a <type>Dynamic</type> value, it is possible to get around
        this restriction:<informalexample>
            <programlisting>processSomeDynamicValues :: Dynamic -&gt; String;
processSomeDynamicValues v =
    let
        intValue = fromDynamicWithDefault v (0 :: Int);
        stringValue = fromDynamicWithDefault v "";
        doubleValue = fromDynamicWithDefault v 0.0;
    in
        if (intValue != 0) then
            intToString intValue
        else if (stringValue != "") then
            stringValue
        else if (doubleValue != 0) then
            doubleToString doubleValue
        else
            "unknown Dynamic value";</programlisting>
          </informalexample></para>

        <para>With <function>processSomeDynamicValues</function> defined as above, we can evaluate
        the following expressions:<informalexample>
            <literallayout><userinput>processSomeDynamicValues (toDynamic (35 :: Int))</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"35"</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>map processSomeDynamicValues [toDynamic (16 :: Int), toDynamic 
"str", toDynamic 1.2, toDynamic 18.0, toDynamic (Just 'C')]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>["16", "str", "1.2", "18.0", "unknown Dynamic value"]</computeroutput></literallayout>
          </informalexample></para>

        <para>The <classname>Dynamic</classname> module contains a number of functions for creating
        and inspecting <classname>Dynamic</classname> values. The <function>toDynamic</function>
        function is used to create <type>Dynamic</type> values. It accepts an argument of any
        <type>Typeable</type> type<footnote>
            <para>All non-polymorphic CAL types, and all polymorphic types whose type argument
            variables are not higher-kinded are automatically instances of the <type>Typeable</type>
            class.</para>
          </footnote>, and returns a <type>Dynamic</type> value that wraps that type.</para>

        <para>The <function>fromDynamicWithDefault</function> function is used to extract values
        from a <type>Dynamic</type> value. It takes two arguments: a <type>Dynamic</type> value, and
        a default value. It returns the value wrapped by the <type>Dynamic</type> value if the
        wrapped value is of the same type as the default value. If they are not of the same type,
        then it returns the default value.</para>

        <para>The other way to extract values from a <type>Dynamic</type> wrapper is using the
        function <function>fromDynamic</function>. It returns a value of <function>Just v</function>
        if the <type>Dynamic</type> value wraps the "expected" type, or <function>Nothing</function>
        otherwise:<informalexample>
            <programlisting>unwrapInt :: Dynamic -&gt; Maybe Int;
unwrapInt v =
    fromDynamic v;</programlisting>
          </informalexample></para>

        <para>With unwrapInt defined as above, we can evaluate the following
        expressions:<informalexample>
            <literallayout><userinput>unwrapInt (toDynamic (50 :: Int))</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Just 50</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>unwrapInt (toDynamic 50.0)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Nothing</computeroutput></literallayout>
          </informalexample></para>

        <para>Note that <function>unwrapInt</function> disambiguates the "expected" type by
        declaring the return type of <function>unwrapInt</function>. When
        <function>fromDynamic</function> is called, there must always be some way for the compiler
        to determine the expected return type:<informalexample>
            <literallayout><userinput>fromDynamic (toDynamic (50 :: Int)) :: Maybe Int</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Just 50</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>fromDynamic (toDynamic 50.0) :: Maybe Int</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Nothing</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>fromDynamic (toDynamic 50.0) :: Maybe Double</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Just 50.0</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>fromDynamic (toDynamic 50.0)</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>Ambiguous type signature in inferred type 
(Prelude.Outputable a, Prelude.Typeable a) =&gt; a.</computeroutput></literallayout>
          </informalexample></para>

        <para>The final expression fails, because the type inferencer has not been given enough
        information to determine the expected type, and therefore whether the result should be
        <function>Just 50.0</function> (if <type>Maybe Double</type> is the expected type) or
        <function>Nothing</function> (if some other type is expected).</para>
      </section>

      <section>
        <title>CAFs and caching</title>

        <para>A Constant Applicative Form, or CAF, is a top-level non-foreign function that has no
        lexical arguments and has a non-constrained type.<informalexample>
            <programlisting>approxPi :: Double;
approxPi = 3.14159;</programlisting>
          </informalexample><informalexample>
            <programlisting>addOneInt :: Int -&gt; Int;
addOneInt x = x + 1;</programlisting>
          </informalexample><informalexample>
            <programlisting>sunDiameter :: Num a =&gt; a;
sunDiameter = 1380000;</programlisting>
          </informalexample></para>

        <para>Of the three top-level functions above, only <function>approxPi</function> is a CAF.
        <function>addOneInt</function> is not a CAF, because its definition includes a lexical
        argument (<parameter>x</parameter>). <function>sunDiameter</function> is also not a CAF,
        because it has a constrained type<footnote>
            <para>Functions with a constrained type are not CAFs because their underlying
            representation accepts a hidden argument that indicates what specific type they should
            take in each given context.</para>
          </footnote> (i.e., its type signature contains a '<literal>=&gt;</literal>').</para>

        <para>Even though CAFs must not accept lexical arguments, it is nevertheless possible to
        declare a CAF which equals a function of one or more arguments:<informalexample>
            <programlisting>cafAdd10Int :: Int -&gt; Int;
cafAdd10Int = add 10;
add10Int :: Int -&gt; Int;
add10Int x = add 10 x;</programlisting>
          </informalexample></para>

        <para>In the code above, <function>add10Int</function> and <function>cafAdd10Int</function>
        have the same type and represent functions with equivalent behaviors (viz., they both add 10
        to their single argument). However, <function>cafAdd10Int</function> is a CAF, whereas
        <function>add10Int</function> is not, because <function>add10Int</function> accepts a
        <emphasis>lexical</emphasis> argument (i.e., one which is specified in the function
        definition).</para>

        <para>Note also the distinction between polymorphic types and constrained types. A CAF may
        have a polymorphic type, so long as the polymorphic type is unconstrained:<informalexample>
            <programlisting>second :: [a] -&gt; a;
second = head `compose` tail;</programlisting>
          </informalexample><informalexample>
            <programlisting>secondOrderable :: Ord a =&gt; [a] -&gt; a;
secondOrderable = head `compose` tail;</programlisting>
          </informalexample></para>

        <para>In the above code, <function>second</function> is a CAF, whereas
        <function>secondOrderable</function> is not, since <function>secondOrderable</function> has
        a class constraint.</para>

        <para>CAL caches the value of each CAF after the first time it has been evaluated. This
        means that it is possible to use the value of a expensive-to-calculate CAF in multiple
        expressions (or in multiple parts of a single expression) without incurring the cost of
        evaluating it multiple times.<informalexample>
            <programlisting>largeSum :: Integer;
largeSum = sum (take 1000000 (List.repeat 1));</programlisting>
          </informalexample></para>

        <para>We can verify this using a (somewhat contrived) example. With
        <function>largeSum</function> defined as above, in a module in the current
        workspace:<informalexample>
            <literallayout><userinput>largeSum</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>1000000</computeroutput></literallayout>
          </informalexample><informalexample>
            <literallayout><userinput>largeSum</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>1000000</computeroutput></literallayout>
          </informalexample></para>

        <para>The first time that we evaluate <function>largeSum</function> in an ICE session, it
        takes an appreciable amount of time to execute (on one machine it took 10,250 milliseconds).
        Subsequent times, however, it should evaluate nearly instantaneously (0 milliseconds on the
        same machine).</para>

        <para>In the case of CAFs that represent function values (such as
        <function>cafAdd10Int</function> above), it is important to note that the value which is
        cached is not the value of any particular invocation (e.g., the value of
        <literal>16</literal> for <code>cafAdd10Int 6</code>), but rather the value of the function
        itself.</para>

        <para>Because the values of CAFs are always cached, it is important to be aware that CAFs
        that evaluate to large values can significantly increase the memory requirements of your
        program.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title xml:id="StandardLibraryReference">Standard Library Reference</title>

    <section>
      <title>Types</title>

      <section>
        <title><type>Dynamic</type></title>

        <para>The <type>Dynamic</type> type (provided by the <classname>Dynamic</classname> module)
        is used for holding values of other CAL types.</para>

        <para><type>Dynamic</type> values are created using the <function>toDynamic</function>
        function. They are extracted again using either the
        <function>fromDynamicWithDefault</function> function, or the
        <function>fromDynamic</function> function. Any type that is an instance of the
        <classname>Typeable</classname> class can be represented as a <type>Dynamic</type>
        value.</para>

        <para>Using the <type>Dynamic</type> type is generally considered poor functional
        programming practice, and frequently there are ways to re-express a solution to avoid its
        use. However, <type>Dynamic</type> is actually type-safe in the sense that run-time errors
        cannot occur because of the use of the "wrong" type. The reason using <type>Dynamic</type>
        is frowned upon somewhat is that the type system is not able to help the user with the
        process of his or her construction of CAL code as much. There is also a (small) performance
        penalty of carrying type information at runtime.</para>

        <section>
          <title>Data constructors</title>

          <para>The <type>Dynamic</type> type has no public data constructors. <type>Dynamic</type>
          values can only be created using the <function>toDynamic</function> function.</para>
        </section>

        <section>
          <title>Examples</title>

          <para><programlisting>listOfStringsAndNumbers :: [Dynamic];
listOfStringsAndNumbers = [toDynamic "fifty-five", toDynamic 55.0, toDynamic (55 :: Int)];
showStringOrDouble :: Dynamic -&gt; String;
showStringOrDouble x =
    let
        doubleValue :: Maybe Double;
        doubleValue = fromDynamic x;
    in
        case doubleValue of
        Nothing -&gt; fromDynamicWithDefault x "(not a String or Double)";
        Just value -&gt; Debug.show value;
        ;</programlisting></para>

          <para>With <function>showStringOrDouble</function> and
          <function>listOfStringsAndNumbers</function> defined as above:<informalexample>
              <literallayout><userinput>map showStringOrDouble listOfStringsAndNumbers</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>["fifty-five", "55.0", "(not a String or Double)"]</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title><type>Either a b</type></title>

        <para>The <type>Either</type> type represents values with two possibilities. A value of type
        <type>Either a b</type> is either <function>Left a</function> or <function>Right
        b</function>. For example, the list <code>[Left "abc", Right 2.0]</code> has type
        <type>Either String Double</type>.</para>

        <para>The <type>Either</type> type is sometimes used as an alternative to the
        <type>Maybe</type> type when representing the return type of a function that may fail. The
        <function>Left</function> data constructor is then used to hold failure information (i.e. an
        error message for example), and the <function>Right</function> data constructor is used to
        hold the successful return value.</para>

        <section>
          <title>Data constructors</title>

          <para><screen>Left     value :: a
Right    value :: b</screen></para>
        </section>

        <section>
          <title>Examples</title>

          <para>The <type>Either IOErrorType a</type> type is used by the
          <classname>File</classname> module to represent the result of functions that might signal
          an error.<programlisting>/**
 * Determines whether an
 * {@code ({@link Either@} {@link typeConstructor=IOError@} a)@}
 * value represents an IO error, i.e. in fact the value is of the
 * form {@code {@link Left@} ioError@}. This function is
 * therefore analogous to {@link Prelude.isJust@}.
 * 
 * @arg resultOrError an {@code (Either IOError a)@} value to be
 *                    processed.
 * @return {@link True@} if the IO operation succeeded, or
 *         {@link False@} if the IO operation failed.
 */
isIOSuccess :: Either IOErrorType a -&gt; Boolean;
public isIOSuccess !resultOrError =
    case resultOrError of
    Left {} -&gt; False;
    _ -&gt; True;
    ; </programlisting></para>
        </section>
      </section>

      <section>
        <title><type>Maybe a</type></title>

        <para>The <type>Maybe</type> type can be thought of as representing an optional value. For
        example, a value of type <type>Maybe Double</type> can be <function>Just 2.0</function>,
        indicating that the value <literal>2.0</literal> was supplied, or it can be
        <function>Nothing</function>, indicating that no <type>Double</type> value was
        supplied.</para>

        <para>Functions that perform operations that could fail (such as database access) frequently
        have a return type of <type>Maybe</type>, with a return value of
        <function>Nothing</function> indicating failure.</para>

        <para>The <function>fromJust</function> function can be used to extract the wrapped value
        from a <function>Just</function> value. The <function>maybeToList</function> function will
        convert a <type>Maybe</type> value to either a single-element list of the wrapped value (in
        the <function>Just</function> case) or an empty list (in the <function>Nothing</function>
        case).</para>

        <section>
          <title>Data constructors</title>

          <para><screen>Nothing
Just    value :: a</screen></para>
        </section>

        <section>
          <title>Examples</title>

          <para><programlisting>/**
 * {@code lookup key map@} returns the value corresponding to key
 * in the map (association list).
 * 
 * @arg key the key for which the map is to be searched.
 * @arg map the map (association list) to be searched.
 * @return the value corresponding to key in the map.
 */
lookup :: (Eq a) =&gt; a -&gt; [(a, b)] -&gt; Maybe b;
public lookup key !map =
    case map of
    [] -&gt; Nothing;
    mapHead : mapTail -&gt;
        if key == mapHead.#1 then
            Just mapHead.#2
        else
            lookup key mapTail;
    ;</programlisting></para>

          <para>With lookup defined as above:<informalexample>
              <literallayout><userinput>lookup "apple" [("orange", 2.49), ("apple", 1.29), ("pear", 3.29)]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Just 1.29</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>lookup "pomegranate" [("orange", 2.49), ("apple", 1.29), ("pear", 3.29)]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Nothing</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title><type>Ordering</type></title>

        <para><type>Ordering</type> is a simple enumerated type intended to represent the result of
        a comparison between two values.</para>

        <section>
          <title>Data constructors</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><function>LT</function></entry>

                    <entry>Represents "less than"</entry>
                  </row>

                  <row>
                    <entry><function>EQ</function></entry>

                    <entry>Represents a comparison of equal values</entry>
                  </row>

                  <row>
                    <entry><function>GT</function></entry>

                    <entry>Represents "greater than"</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>

        <section>
          <title>Examples</title>

          <para><informalexample>
              <literallayout><userinput>map (compare (0 :: Int)) (upFromTo (-2) 2)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[LT, LT, EQ, GT, GT]</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title><type>TypeRep</type></title>

        <para><type>TypeRep</type> values represent the type of expressions. The
        <type>TypeRep</type> type exists primarily to support dynamically-typed programming using
        the <type>Dynamic</type> type.</para>

        <section>
          <title>Data constructors</title>

          <para>The <type>TypeRep</type> class has no public data constructors. The only way to
          create a <type>TypeRep</type> value is by applying the <function>typeOf</function> method
          to an expression.</para>
        </section>

        <section>
          <title>Examples</title>

          <para><informalexample>
              <literallayout><userinput>typeOf "str1" == typeOf "str2"</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>typeOf EQ == typeOf LT</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>typeOf (4 + 5.0) == typeOf (4 + (5 :: Int))</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>
    </section>

    <section>
      <title xml:id="TypeClasses">Type classes</title>

      <section>
        <title><classname>Eq</classname></title>

        <para><classname>Eq</classname> is the class of types that can be compared for
        equality.</para>

        <section>
          <title>Methods</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><methodname>Equals</methodname></entry>

                    <entry>Returns <function>True</function> if the two arguments are equal. The
                    operator form of this method is <function role="operator">==</function>.</entry>
                  </row>

                  <row>
                    <entry><methodname>notEquals</methodname></entry>

                    <entry>Returns <function>True</function> if the two arguments are not equal. The
                    operator form of this method is <function role="operator">!=</function>.</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>

        <section>
          <title>Examples</title>

          <para><informalexample>
              <literallayout><userinput>"str1" == "str2"</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>EQ != LT</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>equals 'c' 'c'</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title><classname>Ord</classname></title>

        <para><classname>Ord</classname> is the class of types whose values have an order. Any type
        that is an instance of <classname>Ord</classname> can be used as input to the ordering
        operators (e.g., <code>False &lt; True</code> is a valid expression because
        <type>Boolean</type> is an instance of <classname>Ord</classname>).</para>

        <section>
          <title>Methods</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><methodname>lessThan</methodname></entry>

                    <entry>Returns <function>True</function> if the first argument is less than the
                    second. The operator form of this method is <function
                    role="operator">&lt;</function>.</entry>
                  </row>

                  <row>
                    <entry><methodname>lessThanEquals</methodname></entry>

                    <entry>Returns <function>True</function> if the first argument is less than or
                    equal to the second. The operator form of this method is <function
                    role="operator">&lt;=</function>.</entry>
                  </row>

                  <row>
                    <entry><methodname>greaterThan</methodname></entry>

                    <entry>Returns <function>True</function> if the first argument is greater than
                    the second. The operator form of this method is <function
                    role="operator">&gt;</function>.</entry>
                  </row>

                  <row>
                    <entry><methodname>greaterThanEquals </methodname></entry>

                    <entry>Returns <function>True</function> if the first argument is greater than
                    or equal to the second. The operator form of this method is <function
                    role="operator">&gt;=</function>.</entry>
                  </row>

                  <row>
                    <entry><methodname>compare</methodname></entry>

                    <entry>Return <function>EQ</function> if the first argument is equal to the
                    second, <function>LT</function> if the first argument is less than the second,
                    and <function>GT</function> if the first argument is greater than the
                    second.</entry>
                  </row>

                  <row>
                    <entry><methodname>max</methodname></entry>

                    <entry>Returns the greater of its two arguments</entry>
                  </row>

                  <row>
                    <entry><methodname>min</methodname></entry>

                    <entry>Returns the lesser of its two arguments</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>

        <section>
          <title>Examples</title>

          <para><informalexample>
              <literallayout><userinput>LT &lt;= EQ</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>0 :: Int &gt; 10</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>"this" &gt; "that"</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>max "this" "that"</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"this"</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>compare 0.0 1.0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>LT</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title><classname>Num</classname></title>

        <para><classname>Num</classname> is the class of numeric types (i.e., those that support the
        usual arithmetic operations). Any type that is an instance of <classname>Num</classname> can
        be used as input to arithmetic operators (e.g., <code>4.0 + 3.0</code> is a valid expression
        because <type>Double</type> is an instance of <classname>Num</classname>).</para>

        <section>
          <title>Methods</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><methodname>fromInteger</methodname></entry>

                    <entry>Converts an <type>Integer</type> to the nearest value of the instance
                    type.</entry>
                  </row>

                  <row>
                    <entry><methodname>toDouble</methodname></entry>

                    <entry>Converts a value of the instance type to the nearest <type>Double</type>
                    value.</entry>
                  </row>

                  <row>
                    <entry><methodname>negate</methodname></entry>

                    <entry>Returns a value of opposite sign. The operator form of this method is the
                    unary <function role="operator">-</function>.</entry>
                  </row>

                  <row>
                    <entry><methodname>abs</methodname></entry>

                    <entry>Returns the absolute value of a numeric value.</entry>
                  </row>

                  <row>
                    <entry><methodname>signum</methodname></entry>

                    <entry>Returns a value representing the sign of a number: <literal>-1</literal>
                    for negative numbers, 0 for 0, and 1 for positive numbers.</entry>
                  </row>

                  <row>
                    <entry><methodname>add</methodname></entry>

                    <entry>Adds two numbers. The operator form of this method is +.</entry>
                  </row>

                  <row>
                    <entry><methodname>subtract</methodname></entry>

                    <entry>Subtracts two numbers. The operator form of this method is binary
                    -.</entry>
                  </row>

                  <row>
                    <entry><methodname>multiply</methodname></entry>

                    <entry>Multiplies two numbers. The operator form of this method is *.</entry>
                  </row>

                  <row>
                    <entry><methodname>divide</methodname></entry>

                    <entry>Divides two numbers. The operator form of this method is /.</entry>
                  </row>

                  <row>
                    <entry><methodname>remainder</methodname></entry>

                    <entry>Returns the remainder from dividing two numbers. The operator form of
                    this method is %.</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>

        <section>
          <title>Examples</title>

          <para><informalexample>
              <literallayout><userinput>negate 7 :: Int</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>-7</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>3 * 9.0</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>27.0</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>signum (-900)</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>-1</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>fromInteger 500 :: Float</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>500.0</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title><classname>Inputable</classname></title>

        <para>Inputable is the class of all types that can be converted from Java objects to
        appropriate native CAL values using the input method. This class and the Outputable class
        help to simplify integration between Java and CAL code by providing a mapping between native
        CAL values and their Java equivalents (for example, between native CAL lists and Java arrays
        or List objects).</para>

        <section>
          <title>Methods</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><methodname>input</methodname></entry>

                    <entry>Converts a <classname>JObject</classname> to an appropriate native CAL
                    value.</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>
      </section>

      <section>
        <title><classname>Outputable</classname></title>

        <para><classname>Outputable</classname> is the class of all types that can be converted from
        native CAL values to Java objects using the <function>output</function> method. This class
        and the <classname>Inputable</classname> class help to simplify integration between Java and
        CAL code by providing a mapping between native CAL values and their Java equivalents (for
        example, between native CAL lists and Java arrays or <type>List</type> objects).</para>

        <section>
          <title>Methods</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><methodname>output</methodname></entry>

                    <entry>Converts a native CAL value to an appropriate
                    <type>JObject</type>.</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>
      </section>

      <section>
        <title><classname>Bounded</classname></title>

        <para><classname>Bounded</classname> is the class of all types that have upper and lower
        bounds on their values.</para>

        <section>
          <title>Methods</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><methodname>minBound</methodname></entry>

                    <entry>Returns the smallest possible value of this type.</entry>
                  </row>

                  <row>
                    <entry><methodname>maxBound</methodname></entry>

                    <entry>Returns the largest possible value of this type.</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>

        <section>
          <title>Examples</title>

          <para><informalexample>
              <literallayout><userinput>minBound :: Byte</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>-128</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>maxBound :: Int</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>2147483647</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>maxBound :: Ordering</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>GT</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title><classname>Appendable</classname></title>

        <para><classname>Appendable</classname> is the class of all sequence types that can be
        joined together using <methodname>append</methodname> or
        <methodname>concat</methodname>.</para>

        <section>
          <title>Methods</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><methodname>Empty</methodname></entry>

                    <entry>Returns the value that represents the empty sequence for this
                    type.</entry>
                  </row>

                  <row>
                    <entry><methodname>isEmpty</methodname></entry>

                    <entry>Returns true if its argument is an empty sequence.</entry>
                  </row>

                  <row>
                    <entry><methodname>Append</methodname></entry>

                    <entry>Returns a new value that consists of the concatenation of its two
                    arguments. The operator form of this method is <function
                    role="operator">++</function>.</entry>
                  </row>

                  <row>
                    <entry><methodname>Concat</methodname></entry>

                    <entry><para>Returns a new value that consists of the concatenation of the
                    elements of its argument list.</para><para>This method is provided for
                    efficiency reasons. <code>"a" ++ "b" ++ "c" ++ "d"</code> generates 2
                    intermediate values, whereas <code>concat ["a", "b", "c", "d"]</code> does not
                    generate any intermediate values.</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>

        <section>
          <title>Examples</title>

          <informalexample>
            <literallayout><userinput>append [2, 1, 2] [4, 5, 6, 7, 8] :: [Int]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[2, 1, 2, 4, 5, 6, 7, 8]</computeroutput></literallayout>
          </informalexample>

          <informalexample>
            <literallayout><userinput>concat ["string1", " ", "string 2", " ", "string 3"]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>"string1 string2 string3"</computeroutput></literallayout>
          </informalexample>

          <informalexample>
            <literallayout><userinput>concat [[12, 12], [6], [12, 12]]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[12, 12, 6, 12, 12]</computeroutput></literallayout>
          </informalexample>

          <informalexample>
            <literallayout><userinput>empty :: String</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>""</computeroutput></literallayout>
          </informalexample>

          <informalexample>
            <literallayout><userinput>empty :: [Int]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[]</computeroutput></literallayout>
          </informalexample>

          <informalexample>
            <literallayout><userinput>isEmpty [1.0]</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput></literallayout>
          </informalexample>

          <informalexample>
            <literallayout><userinput>isEmpty ""</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
          </informalexample>
        </section>
      </section>

      <section>
        <title><classname>Typeable</classname></title>

        <para>The <classname>Typeable</classname> class is the class of all types that have an
        associated <type>TypeRep</type> representation. All non-polymorphic CAL types, and all
        polymorphic types whose type argument variables are not higher-kinded are automatically
        instances of the <classname>Typeable</classname> class. There is no need to explicitly
        define <classname>Typeable</classname> instances for CAL types.</para>

        <para>The <classname>Typeable</classname> class exists primarily to support
        dynamically-typed programming using the <type>Dynamic</type> type (see <xref
        linkend="DynamicTyping" /> for more details).</para>

        <section>
          <title>Methods</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><methodname>typeOf</methodname></entry>

                    <entry>Returns a <type>TypeRep</type> value representing the type of a
                    value.</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>

        <section>
          <title>Examples</title>

          <para><informalexample>
              <literallayout><userinput>(typeOf "str") == (typeOf 'c')</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>False</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>(typeOf "string1") == (typeOf "string2")</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>True</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title><classname>Enum</classname></title>

        <para><classname>Enum</classname> is a type class intended to represent types whose values
        can be enumerated one by one, such as <type>Int</type>, <type>Long</type>,
        <type>Integer</type> and <type>Ordering</type>. It is also used for types such as
        <type>Double</type>, where an enumeration can be defined on a subset of the values, such as
        the series of values <type>1</type>, <type>1.5</type>, <type>2</type>, <type>2.5</type>,
        <type>3</type>.</para>

        <section>
          <title>Methods</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><methodname>upFrom</methodname></entry>

                    <entry>For numeric types, creates an ascending list starting from its
                    argument.</entry>
                  </row>

                  <row>
                    <entry><methodname>upFromThen</methodname></entry>

                    <entry>For numeric types, creates a list starting with the two arguments, and
                    then continuing by the difference of the two (see examples)</entry>
                  </row>

                  <row>
                    <entry><methodname>upFromTo</methodname></entry>

                    <entry>For numeric types, creates an ascending list starting from its first
                    argument and continuing until it gets to the second argument.</entry>
                  </row>

                  <row>
                    <entry><methodname>upFromThenTo</methodname></entry>

                    <entry>For numeric types, creates a list starting with the two arguments, and
                    then continuing by the difference of the two, and continuing until it gets to
                    the third argument. (see examples)</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>

        <section>
          <title>Examples</title>

          <para><informalexample>
              <literallayout><userinput>zip ["item_id", "item_description", "order_id"] (upFrom 1 :: [Int])</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>[("item_id", 1), ("item_description", 2), ("order_id", 3)]</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title><classname>IntEnum</classname></title>

        <para><classname>IntEnum</classname> is a type class that represents types where there is a
        mapping between the values of the type and the values (or a subset of the values) of the
        <type>Int</type> type.</para>

        <para>Enumerations (algebraic types whose data constructors all take 0 arguments) often need
        to be translated to and from <type>Int</type> values so that they can be stored in external
        locations (e.g., databases, files, preferences). This class makes it easy to generate the
        translation functions for such enumerations by deriving an instance.</para>

        <para>For all values x, the following must be true:<programlisting>intToEnum (enumToInt x) == x</programlisting></para>

        <para>It is possible for multiple <type>Int</type> values to map to the same value of the
        instance type. However, each instance type value must map only to a single <type>Int</type>
        value.</para>

        <para>Instances of this type can be derived for algebraic data types that are enumeration
        types (i.e., non-polymorphic algebraic data types where each data constructor takes zero
        arguments).</para>

        <section>
          <title>Methods</title>

          <para><informaltable>
              <tgroup align="left" cols="2">
                <tbody>
                  <row>
                    <entry><methodname>intToEnum</methodname></entry>

                    <entry>Returns the value that corresponds to the specified <type>Int</type>
                    value. Raises an error if there is no mapping for the provided <type>Int</type>
                    value.</entry>
                  </row>

                  <row>
                    <entry><methodname>intToEnumChecked</methodname></entry>

                    <entry>Returns <computeroutput><code>Just
                    <replaceable>value</replaceable></code></computeroutput>, where
                    <replaceable>value</replaceable> is the value that corresponds to the specified
                    <type>Int</type> value. If there is no mapping for the provided <type>Int</type>
                    value, returns Nothing.</entry>
                  </row>

                  <row>
                    <entry><methodname>enumToInt</methodname></entry>

                    <entry>Returns the <type>Int</type> value that corresponds to the provided
                    value.</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </section>

        <section>
          <title>Examples</title>

          <para><programlisting>data public MyColorEnum =
    Red |
    Green |
    Blue |
    Other
    deriving Enum, IntEnum;</programlisting></para>

          <para>With the above definition of MyColorEnum:<informalexample>
              <literallayout><userinput>enumToInt Red</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>0</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>enumToInt Other</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>3</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>intToEnum 2</userinput>
<emphasis role="bold-italic">returns</emphasis> <computeroutput>Blue</computeroutput></literallayout>
            </informalexample><informalexample>
              <literallayout><userinput>intToEnum 500</userinput>
<emphasis role="bold-italic">Error:</emphasis> <computeroutput>argument (100) does not correspond to a value of type 
MyColorEnum</computeroutput></literallayout>
            </informalexample></para>
        </section>
      </section>
    </section>

    <section>
      <title>Functions and methods</title>

      <para>This section presents a list of the (approximately) 50 most-commonly-used CAL functions
      and methods at the time that this document was written. A brief description is given for each
      function or method.</para>

      <para>The functions reside in different modules, so their fully-qualified names are given
      (e.g., <function>Prelude.compare</function> instead of just
      <function>compare</function>).</para>

      <para><informaltable>
          <tgroup align="left" cols="2">
            <tbody>
              <row>
                <entry><synopsis>List.all <parameter>pred</parameter> <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns <function>True</function> if the provided predicate evaluates
                to <function>True</function> on each element of the list.</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.append <parameter>a1</parameter> <parameter>a2</parameter></synopsis></entry>

                <entry><para>(method) Appends two <classname>Appendable</classname>s together.
                </para><para><type>String</type>s and <type>List</type>s are both
                <classname>Appendable</classname>.</para></entry>
              </row>

              <row>
                <entry><synopsis>List.chop <parameter>len</parameter> <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns list chopped into sublists of length
                <parameter>len</parameter>. Ex:</para><para><code>chop 1 [1.0, 2.0, 3.0] is [[1.0],
                [2.0], [3.0]]</code></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.compare <parameter>o1</parameter> <parameter>o2</parameter></synopsis></entry>

                <entry><para>(method) Compares two <classname>Ord</classname>s and returns
                <function>LT</function>, <function>GT</function>, or
                <function>EQ</function></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.concat <parameter>list</parameter></synopsis></entry>

                <entry><para>(method) Concatenates a list of <classname>Appendable</classname>s into
                a single list</para></entry>
              </row>

              <row>
                <entry><synopsis>List.concatMap <parameter>f</parameter> <parameter>list</parameter></synopsis></entry>

                <entry><para>Applies the function <parameter>f</parameter> to each element of list
                and then concatenates the resulting list.</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.const <parameter>k</parameter> <parameter>x</parameter></synopsis></entry>

                <entry><para>Always returns <parameter>k</parameter></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.doubleToString <parameter>num</parameter></synopsis></entry>

                <entry><para>Returns the <type>String</type> representation of a
                <type>Double</type></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.equals <parameter>e1</parameter> <parameter>e2</parameter></synopsis></entry>

                <entry><para>(method) Returns <function>True</function> if the two provided
                <classname>Eq</classname>s are equal, and <function>False</function>
                otherwise.</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.error <parameter>str</parameter></synopsis></entry>

                <entry><para>Raises an error</para></entry>
              </row>

              <row>
                <entry><synopsis>List.filter <parameter>pred</parameter> <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns a list of each element of list for which
                <parameter>pred</parameter> returns <function>True</function>.</para></entry>
              </row>

              <row>
                <entry><synopsis>List.foldLeft <replaceable>f</replaceable> <parameter>init</parameter> <parameter>list</parameter></synopsis></entry>

                <entry><para>"folds" the 2-argument function f among the elements of list in a
                left-associative fashion into a single result. Ex: </para><para><code>foldLeft add 0
                [1,2,3] = (add (add (add 0 1) 2) 3)</code></para></entry>
              </row>

              <row>
                <entry><synopsis>List.foldLeftStrict <parameter>f</parameter> <parameter>init</parameter> <parameter>list</parameter></synopsis></entry>

                <entry><para>Strict version of <function>foldLeft</function>. Equivalent to
                <function>foldLeft</function>, except that evaluation is forced at each stage of the
                computation. This version is used for efficiency reasons in certain situations.
                </para></entry>
              </row>

              <row>
                <entry><synopsis>List.foldRight <parameter>f</parameter> <parameter>init</parameter> <parameter>list</parameter></synopsis></entry>

                <entry><para>"folds" the 2-argument function <parameter>f</parameter> among the
                elements of list in a right-associative fashion into a single result. Ex:
                </para><para><code>foldRight divide 1 [1,2,3] = (divide 1 (divide 2 (divide 3
                1)))</code> </para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.fromJust <parameter>m</parameter></synopsis></entry>

                <entry><para>Converts a value <code>m = Just x</code> into
                <code>x</code>.</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.fst <parameter>tuple</parameter></synopsis></entry>

                <entry><para>Returns the first component of a 2-tuple (i.e. pair)</para></entry>
              </row>

              <row>
                <entry><synopsis>List.head <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns the first element of a list</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.input <parameter>obj</parameter></synopsis></entry>

                <entry><para>(method) Converts a Java object into an appropriately-typed CAL
                object</para></entry>
              </row>

              <row>
                <entry><synopsis>List.intersperse <parameter>x</parameter> <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns a list with x between each two elements of list. Ex:
                </para><para><code>intersperse 0 [1,2,3] = [1,0,2,0,3]</code></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.intToString <parameter>int</parameter></synopsis></entry>

                <entry><para>Returns the <type>String</type> representation of an
                <type>Int</type></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.isNothing <parameter>m</parameter></synopsis></entry>

                <entry><para>Returns <function>True</function> if <parameter>m</parameter> is
                <function>Nothing</function>, and <function>False</function> if
                <parameter>m</parameter> is <function>Just x</function> for some
                <varname>x</varname>.</para></entry>
              </row>

              <row>
                <entry><synopsis>List.last <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns the last element of list</para></entry>
              </row>

              <row>
                <entry><synopsis>List.length <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns the length of list</para></entry>
              </row>

              <row>
                <entry><synopsis>List.list2 <parameter>x</parameter> <parameter>y</parameter></synopsis></entry>

                <entry><para>Returns a 2-element list of <parameter>x</parameter> and
                <parameter>y</parameter></para></entry>
              </row>

              <row>
                <entry><synopsis>List.map <parameter>f</parameter> <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns a list of the results of <parameter>f</parameter> applied to
                each element of list. Ex: </para><para><code>map doubleToString [1.0, 2.0] = ["1.0",
                "2.0"]</code></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.max <parameter>a</parameter> <parameter>b</parameter></synopsis></entry>

                <entry><para>Returns the greater of <parameter>a</parameter> and
                <parameter>b</parameter></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.multiply <parameter>num1</parameter> <parameter>num2</parameter></synopsis></entry>

                <entry><para>(method) <parameter>num1</parameter> multiplied by
                <parameter>num2</parameter></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.not <parameter>bool</parameter></synopsis></entry>

                <entry><para>Logical NOT of a boolean value</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.output <parameter>val</parameter></synopsis></entry>

                <entry><para>(method) Converts a CAL values into an appropriately-type Java
                object</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.outputList <parameter>list</parameter></synopsis></entry>

                <entry><para>Converts a CAL list of CAL values into a Java list of
                appropriately-typed Java objects</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.remainder <parameter>x</parameter> <parameter>y</parameter></synopsis></entry>

                <entry><para>(method) The remainder of <parameter>x</parameter> divided by
                <parameter>y</parameter>.</para></entry>
              </row>

              <row>
                <entry><synopsis>List.reverse <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns a list whose elements are the reversed elements of list. Ex:
                </para><para><code>reverse [1,2,3] = [3,2,1]</code></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.round <parameter>num</parameter></synopsis></entry>

                <entry><para>Round a number to the nearest integer</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.seq <parameter>a</parameter> <parameter>b</parameter></synopsis></entry>

                <entry><para>Force the order of evaluation. <function>seq</function> evaluates a
                until it is in WHNF (weak head normal form), and then returns
                <parameter>b</parameter></para></entry>
              </row>

              <row>
                <entry><synopsis>Debug.show <parameter>x</parameter></synopsis></entry>

                <entry><para>(method) Returns the <type>String</type> representation of
                <parameter>x</parameter></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.sin <parameter>x</parameter></synopsis></entry>

                <entry><para>Trigonometric sine function</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.snd <parameter>tuple</parameter></synopsis></entry>

                <entry><para>Returns the second component of a 2-tuple (i.e. pair)</para></entry>
              </row>

              <row>
                <entry><synopsis>String.toList <parameter>str</parameter></synopsis></entry>

                <entry><para>Returns a list of the <type>Char</type>s that a string contains. Ex:
                </para><para><code>stringToCharacters "hello" =
                ['h','e','l','l','o']</code></para></entry>
              </row>

              <row>
                <entry><synopsis>List.subscript <parameter>list</parameter> <parameter>n</parameter></synopsis></entry>

                <entry><para>Returns the <phrase role="formula">n</phrase>th element of list.
                <phrase role="formula">N</phrase> is zero-based. Ex: </para><para><code>subscript 2
                [1,2,3,4] = 3</code></para></entry>
              </row>

              <row>
                <entry><synopsis>List.sum <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns the sum of a list of numbers.</para></entry>
              </row>

              <row>
                <entry><synopsis>List.tail <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns a list minus its first element. Ex: </para><para><code>tail
                [1,2,3] = [2,3]</code></para></entry>
              </row>

              <row>
                <entry><synopsis>List.take <parameter>n</parameter> <parameter>list</parameter></synopsis></entry>

                <entry><para>Returns the first <phrase role="formula">n</phrase> elements of
                list</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.toDouble <parameter>num</parameter></synopsis></entry>

                <entry><para>Converts a Number to a <type>Double</type></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.field1 <parameter>tuple</parameter></synopsis></entry>

                <entry><para>Returns the first component of a tuple (or the <varname>#1</varname>
                field of an arbitrary record)</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.field2 <parameter>tuple</parameter></synopsis></entry>

                <entry><para>Returns the second component of a tuple (or the <varname>#2</varname>
                field of an arbitrary record)</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.field3 <parameter>tuple</parameter></synopsis></entry>

                <entry><para>Returns the third component of a tuple (or the <varname>#3</varname>
                field of an arbitrary record)</para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.upFrom <parameter>n</parameter></synopsis></entry>

                <entry><para>Returns an infinite list of numbers starting from <varname>n</varname>
                and increasing by one. Ex: </para><para><code>upFrom 5.0 = [5.0, 6.0, 7.0,
                ...]</code></para></entry>
              </row>

              <row>
                <entry><synopsis>Prelude.upFromTo <parameter>start</parameter> <parameter>end</parameter></synopsis></entry>

                <entry><para>Returns a list of numbers starting from <varname>start</varname> and
                ending with <varname>end</varname>, inclusive. Ex: </para><para><code>upFromTo 5 10
                = [5,6,7,8,9,10]</code></para></entry>
              </row>

              <row>
                <entry><synopsis>List.zip <parameter>list1</parameter> <parameter>list2</parameter></synopsis></entry>

                <entry><para>Returns a list of pairs, where the first element of the <phrase
                role="formula">n</phrase>th pair is the <phrase role="formula">n</phrase>th element
                of <parameter>list1</parameter>, and the second element of the <phrase
                role="formula">n</phrase>th pair is the <phrase role="formula">n</phrase>th element
                of <parameter>list2</parameter>. Ex: </para><para><code>zip [1,2,3] ['a','b','c'] =
                [(1,'a'), (2,'b'), (3,'c')]</code></para></entry>
              </row>

              <row>
                <entry><synopsis>List.zip3 <parameter>list1</parameter> <parameter>list2</parameter> <parameter>list3</parameter></synopsis></entry>

                <entry><para>Returns a list of 3-tuples, where the first element of the <phrase
                role="formula">n</phrase>th pair is the <phrase role="formula">n</phrase>th element
                of <parameter>list1</parameter>, the second element of the <phrase
                role="formula">n</phrase>th pair is the <phrase role="formula">n</phrase>th element
                of <parameter>list2</parameter>, and the third element of the <phrase
                role="formula">n</phrase>th triple is the <phrase role="formula">n</phrase>th
                element of <parameter>list3</parameter>. Ex: </para><para>zip3 [1,2,3] ['a','b','c']
                [5,6,7]= [(1,'a',5), (2,'b',6), (3,'c',7)] </para></entry>
              </row>

              <row>
                <entry><synopsis>List.zipWith <parameter>f</parameter> <parameter>list1</parameter> <parameter>list2</parameter></synopsis></entry>

                <entry><para>Returns a list where the <phrase role="formula">n</phrase>th element is
                the result of applying the 2-argument function <parameter>f</parameter> to the
                <phrase role="formula">n</phrase>th element of <parameter>list1</parameter> and the
                <phrase role="formula">n</phrase>th element of <parameter>list2</parameter>. Ex:
                </para><para><code>zipWith add [1,2,3] [4,5,6] = [5,7,9]</code></para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>
    </section>
  </chapter>

  <appendix>
    <title>CAL source formatting conventions</title>

    <para>There are a number of conventions for formatting CAL source code. This section lists these
    conventions with examples. The general principle informing all of the formatting conventions is
    "indent as little as possible consistent with showing the logical structure and scoping of the
    program".</para>

    <section>
      <title>General guidelines</title>

      <para><itemizedlist>
          <listitem>
            <para>Use 4 spaces for each level of indentation.</para>
          </listitem>

          <listitem>
            <para>Don't use tabs.</para>
          </listitem>

          <listitem>
            <para>Insert a newline after an expression defining equals, and indent the expression
            one level of scope, unless the whole defining expression fits easily on one line.</para>
          </listitem>

          <listitem>
            <para>Insert newlines and start a new scope after <code>=</code>, <code>then</code>,
            <code>else</code>, <code>-&gt;</code>, <code>let</code>, <code>in</code>, and
            <code>where</code>. (but not after <code>of</code>. See <xref
            linkend="FormattingCaseExpressions" /> for detail.)</para>
          </listitem>

          <listitem>
            <para>It is good practice to include explicit type declarations even if they can be
            inferred.</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Formatting if-then-else expressions</title>

      <para>Here are some concrete examples of correctly-formatted if statements.<informalexample>
          <programlisting>toEnumForOrdering :: Int -&gt; Ordering;
private toEnumForOrdering index = 
    if index == 0 then
        LT
    else if index == 1 then
        EQ
    else if index == 2 then
        GT
    else
        error "Prelude.toEnumForOrdering: the index is out of range."
    ;</programlisting>
        </informalexample><informalexample>
          <programlisting>maxOrd :: Ord a =&gt; a -&gt; a -&gt; a;
public maxOrd x y = if x &gt;= y then x else y;</programlisting>
        </informalexample></para>

      <para>The first form (<function>toEnumForOrdering</function>) should be considered the
      default, and is the preferred form when the <code>then</code> and <code>else</code>
      expressions are long.</para>
    </section>

    <section>
      <title xml:id="FormattingCaseExpressions">Formatting case expressions</title>

      <para>Here are some concrete examples of correctly-formatted case expressions.<informalexample>
          <programlisting>equalsOrdering :: Ordering -&gt; Ordering -&gt; Boolean;
private equalsOrdering !x !y =
    case x of
    LT -&gt;
        case y of 
        LT -&gt; True;
        _ -&gt; False;
        ;
    EQ -&gt;
        case y of 
        EQ -&gt; True;
        _ -&gt; False;
        ;
    GT -&gt;
        case y of 
        GT -&gt; True;
        _ -&gt; False;
    ;</programlisting>
        </informalexample><informalexample>
          <programlisting>catMaybes :: [Maybe a] -&gt; [a];
public catMaybes ms =
    case ms of
    [] -&gt; [];
    x : xs -&gt;
        case x of
        Nothing -&gt; catMaybes xs;
        Just b  -&gt; b : catMaybes xs;
        ;
    ;</programlisting>
        </informalexample></para>

      <para>The most important point in formatting cases is to make sure that the <code>case</code>
      keyword aligns with its corresponding alternative patterns and its expression terminating
      semicolon (if needed). This greatly improves the readability of nested <code>case</code>s, as
      in the <function>catMaybes</function> example. It is very tempting to slightly abuse the
      minimal whitespace principle by aligning the arrows to improve clarity when the expressions
      following the pattern are short and thus kept on the same line as the arrows. Ex: the arrows
      following <function>Nothing</function> and <function>Just b</function> have been aligned
      vertically by inserting an extra space after <function>Just b</function>. Although this isn't
      strictly correct, it is not frowned upon.</para>
    </section>

    <section>
      <title>Formatting let expressions</title>

      <para><informalexample>
          <programlisting>lines :: [Char] -&gt; [[Char]];
public lines s = 
    if isNull s then []
    else
        let
            lineRestPair :: ([Char], [Char]);
            lineRestPair = break (\c -&gt; '\n' == c) s;

            line :: [Char];
            line = fst lineRestPair;

            rest :: [Char];
            rest = snd lineRestPair;
        in
            line : (if isNull rest then [] else lines (tail rest));</programlisting>
        </informalexample><informalexample>
          <programlisting>maximumBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; a;
public maximumBy comparisonFunction list =
    case list of
    [] -&gt; error "Prelude.maximumBy: empty list.";
    _ : _ -&gt;
        let
            max x y =
                case (comparisonFunction x y) of
                GT -&gt; x;
                _  -&gt; y;
                ;
        in            
            List.foldLeft1Strict max list;
    ;</programlisting>
        </informalexample></para>

      <para>Note that the <code>in</code> keyword lines up with its corresponding <code>let</code>,
      and that the expressions after both <code>let</code> and <code>in</code> are indented.</para>
    </section>

    <section>
      <title>Formatting data declarations, type classes, and instances</title>

      <para>The guidelines for formatting data declarations, type classes, and instances can mostly
      be inferred from the "least indentation principle". Some concrete examples: <informalexample>
          <programlisting>data public Attribute = 
    private ColourAttribute 
        attrName      :: String
        colours       :: [Color] |
    private BooleanAttribute 
        attrName      :: String
        boolVals      :: [Boolean] |
    private IntegerAttribute 
        attrName      :: String
        intVals       :: [Int] |
    private DoubleAttribute 
        attrName      :: String
        doubleVals    :: [Double] |
    private StringAttribute 
        attrName      :: String
        stringVals    :: [String] |
    private TimeAttribute 
        attrName      :: String
        timeVals      :: [Time] |
    private AttributeSetAttribute 
        attrName      :: String 
        childAttrSets :: [AttributeSet];</programlisting>
        </informalexample><informalexample>
          <programlisting>public class NamedDataFacet a where
    public getDisplayName :: a -&gt; String;
    public getUniqueIdentifier :: a -&gt; UniqueIdentifier a;
    ;</programlisting>
        </informalexample><informalexample>
          <programlisting>instance NamedDataFacet Field where
    getDisplayName = getFieldDisplayName;
    getUniqueIdentifier = getFieldUniqueIdentifier; 
    ;</programlisting>
        </informalexample></para>
    </section>

    <section>
      <title>CALDoc style guidelines</title>

      <section>
        <title>Using the <code>@see</code> tag</title>

        <para>When using the <code>@see</code> tag, it is recommended that references to type
        constructors, type classes and modules always appear with the appropriate context keywords.
        In other words, instead of writing:<informalexample>
            <programlisting>/** @see Ord */</programlisting>
          </informalexample>one should write:<informalexample>
            <programlisting>/** @see typeClass = Ord */</programlisting>
          </informalexample></para>

        <para>Also, if one <code>@see</code> block in a comment uses a context keyword, then all
        <code>@see</code> blocks in the comment should do so as well. For example: <informalexample>
            <programlisting>/**
 * @see typeClass = Ord
 * @see function = compare
 */</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>Using the <code>{@code}</code> and <code>{@link}</code> inline tags</title>

        <para>In a CALDoc comment, all CAL fragments should appear in either a <code>{@code}</code>
        or a <code>{@link}</code> inline tag. For example (taken from
        <function>List.map</function>):<informalexample>
            <programlisting>/**
 * {@code map mapFunction list@} applies the function {@code mapFunction@}
 * to each element of the list and returns the resulting list.
 * 
 * @arg mapFunction a function to be applied to each element of the list.
 * @arg list the list.
 * @return the list obtained by applying {@code mapFunction@} to
 *         each element of the list.
 */</programlisting>
          </informalexample></para>

        <para>Moreover, names of top-level functions, class methods, type and data constructors, and
        type classes should be hyperlinked with the <code>{@link}</code> tag. For
        example:<informalexample>
            <programlisting>/**
 * This is a cross reference to Prelude.Right: {@link Right@}
 * 
 * This is how you would write "Maybe a": {@code {@link Maybe@} a@}.
 *
 * This is a nice example fragment:
 * {@code {@link List.map@} {@link truncate@} [2.6, -2.7] == [2, 2]@}
 * 
 * To disambiguate, you would write {@link typeConstructor = String@}
 * or {@link module = String@}.
 */</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>Using the <code>@author</code> tag</title>

        <para>It is recommended to put only one author name per <code>@author</code> block, and let
        the documentation generator handle the generation of commas. For example:<informalexample>
            <programlisting>/**
 * @author Bo Ilic
 * @author Joseph Wong
 */</programlisting>
          </informalexample></para>
      </section>
    </section>
  </appendix>

  <appendix>
    <title>Suggested reading</title>

    <para>CAL is influenced by the Haskell language, so some knowledge of Haskell is an advantage to
    learning CAL. These are two excellent introductions to Haskell (and to functional programming in
    general):<itemizedlist>
        <listitem>
          <para><emphasis>The Craft of Functional Programming</emphasis> by Simon Thompson</para>
        </listitem>

        <listitem>
          <para><emphasis>A Gentle Introduction to Haskell</emphasis> (available at <link
          xlink:href="http://www.haskell.org/tutorial/">http://www.haskell.org/tutorial/</link>
          )</para>
        </listitem>
      </itemizedlist></para>
  </appendix>

  <appendix>
    <title>Language keywords</title>

    <para><literallayout> <code>case</code>
 <code>class</code>
 <code>data</code>
 <code>dataConstructor</code>
 <code>default</code>
 <code>deriving</code>
 <code>else</code>
 <code>foreign</code>
 <code>friend</code>
 <code>function</code>
 <code>if</code>
 <code>import</code>
 <code>in</code>
 <code>instance</code>
 <code>jvm</code>
 <code>let</code>
 <code>module</code>
 <code>of</code>
 <code>primitive</code>
 <code>private</code>
 <code>protected</code>
 <code>public</code>
 <code>then</code>
 <code>typeClass</code>
 <code>typeConstructor</code>
 <code>unsafe</code>
 <code>using</code>
 <code>where</code></literallayout></para>
  </appendix>
</book>