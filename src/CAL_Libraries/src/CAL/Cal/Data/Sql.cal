/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *  
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *  
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Sql.cal
 * Creation date: Feb 5, 2004.
 * By: Richard Webster
 */

/**
 * This module provides a combinator library for creating abstract SQL queries.
 * A query is represented by the type {@link typeConstructor = Query@}.
 * 
 * A new, empty query can be created by calling {@link newQuery@}.
 * 
 * {@code
 * qry0 = newQuery;
 * @}
 * 
 * To project a column or a SQL expression, use the {@link project@} function. 
 * There are several variations on this function, such as {@link projectColumn@} and {@link projectWithAliases@}.
 * 
 * {@code
 * qry1 = project qry0 [toUntypedExpr countryField, toUntypedExpr orderDateField]; 
 * @}
 * 
 * To add a restriction to the query, use the {@link restrict@} function.
 * 
 * {@code
 * qry2 = restrict qry1 (eqExpr countryField (stringConstant "Canada"));
 * @}
 * 
 * To add sorting to the query, use the {@link order@} function.
 * 
 * {@code
 * qry3 = order qry2 orderDateField True;
 * @}
 * 
 * To add a join to the query, use the {@link join@} function. 
 * 
 * {@code
 * joinInfo = makeJoinInfo (intField custTable "Customer ID") (intField ordersTable "Customer ID") InnerJoin;
 * qry4 = join qry3 joinInfo;
 * @}
 *      
 * An abstract {@link typeConstructor = Query@} can be converted to a concrete SQL query with the {@link queryText@} function. 
 * This function requires a {@link typeConstructor = SqlBuilder@} for a specific RDBMS as found in the module {@link module = "Cal.Data.SqlBuilder"@}.
 * 
 * See the module {@link module = "Cal.Test.Data.Sql_Tests"@} for examples of query construction.
 * 
 * There is some support for other types of SQL statements, such as ones to create/delete tables and inserting rows.
 * See the {@link Statement@} type.
 * 
 * @author Richard Webster
 */
module Cal.Data.Sql;
import Cal.Core.Prelude using
    typeConstructor = Byte, Int, Double, String, Boolean, Char, Integer, JObject, JList, Maybe, Ordering;
    dataConstructor = False, True, LT, EQ, GT, Nothing, Just;
    typeClass = Eq, Ord, Num, Inputable, Outputable;
    function = 
        append, compare, concat, const, doubleToString, equals, error, fromJust, fst, input,
        intToString, isNothing, isEmpty,  max, mod, not, output, round, seq, snd, toDouble,
        field1, field2, field3, upFrom, upFromTo;
    typeConstructor = Long;
    function = compose, fromMaybe, isJust, listToMaybe, maybeToList, longToString;
    ;
import Cal.Collections.List using  
    function = all, chop, filter, foldLeft, foldLeftStrict, foldRight, head, intersperse,
        last, length, list2, map, outputList, outputListWith, reverse, subscript, sum, tail, take,
        zip, zip3, zipWith;  
    function = any, concatMap, deleteFirsts, drop, elemIndex, isElem, mapIndexed, repeat, removeDuplicates, 
        removeDuplicatesBy, lookupWithDefault, find, groupBy, intersect, isSingletonList, sort;
    ;      
import Cal.Core.String using     
    function = toLowerCase;
    ;        
import Cal.Core.Debug using
    typeClass = Show;
    function = show;
    ;
import Cal.Utilities.TimeZone using
    typeConstructor = TimeZone;
    ;
import Cal.Utilities.Time using
    typeConstructor = Time;
    ;
import Cal.Utilities.PrettyPrinter using
    typeConstructor = Document;
    function = line, multilineText, nest, text;
    ;
import Cal.Data.SqlType using
    typeConstructor = SqlType;
    ;
import Cal.Collections.Set using
    typeConstructor = Set;
    ;
import Cal.Collections.Array using
    typeConstructor = Array;
    ;
import Cal.Data.DatabaseMetadata using
    typeConstructor = DatabaseReference, TableReference, TableDescription, FieldDescription,
                      TableConstraint;
    dataConstructor = PrimaryKeyConstraint, UniqueConstraint, ForeignKeyConstraint;
    function = getTableNameFromReference, makeTableReference;
    ;
import Cal.Utilities.UniqueIdentifier using
    typeConstructor = UniqueIdentifier;
    typeClass = UniquelyNamedItem;
    function = makeUniqueIdentifierByName;
    ;
import Cal.Utilities.Range using
    typeConstructor = Range;
    function = 
        hasLeftEndpoint, hasRightEndpoint, includesLeftEndpoint, 
        includesRightEndpoint, leftEndpoint, rightEndpoint;
    ;


/**
 * Associates a table resource with its alias for the query.
 */
data public QueryTable = 
    /**
     * A reference to an actual database table with a given alias for the query.
     * @arg tableRef    a reference to a database table by name
     * @arg tableAlias  the alias for the table in the query
     */
    private BaseTable 
        tableRef     :: !TableReference 
        tableAlias   :: !String 
    |
    /**
     * A nested SELECT query to be treated as a query table with a given alias.
     * @arg subquery    a database query to be treated as a query table
     * @arg tableAlias  the alias for the nested SELECT 'table' in the query
     */
    private SubQueryTable 
        subquery     :: Query 
        tableAlias   :: !String 
    |
    /**
     * A nested SELECT statement to be treated as a query table with a given alias.
     * @arg subqueryText  the SQL for a SELECT statement to be treated as a query table
     * @arg tableAlias    the alias for the nested SELECT 'table' in the query
     */
    private OpaqueSubQueryTable 
        subqueryText :: String 
        tableAlias   :: !String 
    ;

/**
 * Constructs a query table using the specified table name.
 * The table alias will be based on the table name.
 * @arg tableName  the name of the table to be used in the query
 * @return         a query table for the specified table using the table name as the alias
 */
makeQueryTable :: String -> QueryTable;
public makeQueryTable !tableName = makeQueryTableWithAlias tableName "";

/**
 * Constructs a query table using the specified table name and base alias name.
 * If no table alias is specified, the table name will be used as the alias.
 * @arg tableName   the name of the table to be used in the query
 * @arg tableAlias  the alias to use for the table in the query;
 *                  An empty alias name indicates that the table name should be used as the alias
 * @return          a query table for the specified table and alias
 */
makeQueryTableWithAlias :: String -> String -> QueryTable;
public makeQueryTableWithAlias !tableName !tableAlias = 
    let
        fixedAlias :: String;
        fixedAlias = if (isEmpty tableAlias) then tableName else tableAlias;
    in
        BaseTable (makeTableReference tableName) fixedAlias;

/**
 * Constructs a subquery table using the specified query and alias.
 * This function will remove any ordering from the subquery (unless it is a {@link TopN@}
 * query).
 * @arg subquery    a database query to be treated as a query table
 * @arg tableAlias  the alias to use for the table in the query;
 *                  If an empty alias is specified, then a default one will be generated.
 * @return          a query table for the nested SELECT query with the given alias
 */
makeSubQueryTable :: Query -> String -> QueryTable;
public makeSubQueryTable subquery !tableAlias = 
    let
        fixedAlias :: String;
        fixedAlias = if (isEmpty tableAlias) then "Q" else tableAlias;
    in
        SubQueryTable (fixSubqueryOrdering subquery) fixedAlias;

/**
 * Constructs a subquery table using the specified query text and alias.
 * The query text must be valid when used as a subquery.
 * In most cases, this means that it cannot contain an ORDER BY clause.
 * @arg subqueryText  a SELECT statement text to be treated as a query table
 * @arg tableAlias    the alias to use for the table in the query;
 *                    If an empty alias is specified, then a default one will be generated.
 * @return            a query table for the nested SELECT query with the given alias
 */
makeOpaqueSubQueryTable :: String -> String -> QueryTable;
public makeOpaqueSubQueryTable subqueryText !tableAlias = 
    let
        fixedAlias :: String;
        fixedAlias = if (isEmpty tableAlias) then "Q" else tableAlias;
    in
        OpaqueSubQueryTable subqueryText fixedAlias;

/**
 * Returns whether the specified table is a subquery table.
 * @arg queryTable  a query table
 * @return          True if the table is a subquery (or opaque subquery) table;
 *                  False if the table is a base database table
 */
isSubqueryTable :: QueryTable -> Boolean;
public isSubqueryTable !queryTable = 
    case queryTable of
    (SubQueryTable | OpaqueSubQueryTable) {} -> True;
    _ -> False;
    ;

/**
 * Returns the name of the table (without quotes).
 * An empty string is returned for the name of a subquery table.
 * @arg queryTable  a query table
 * @return          the name of the base database table, 
 *                  or an empty string if the query table is based on a subquery
 */
getQueryTableName :: QueryTable -> String;
public getQueryTableName !queryTable = 
    case queryTable of
    BaseTable {tableRef} -> getTableNameFromReference tableRef;
    _ -> "";
    ;

/**
 * Returns the table alias for a query table.
 * This is a composition of the base alias and the table ID to give a distinct alias for the table.
 * @arg queryTable  a query table
 * @return          the table alias for the query table
 */
getQueryTableAlias :: QueryTable -> String;
public getQueryTableAlias !queryTable = 
    case queryTable of
    (BaseTable | SubQueryTable | OpaqueSubQueryTable) {tableAlias} -> tableAlias;
    ;

/**
 * Query tables can be compared for equality.
 * This is based only on the table aliases, not the actual table information.
 */
instance Eq QueryTable where
    equals = equalsQueryTable;
    notEquals = notEqualsQueryTable;
    ;

equalsQueryTable :: QueryTable -> QueryTable -> Boolean;
private equalsQueryTable table1 table2 = 
    case table1 of
    BaseTable {tableAlias} -> 
        case table2 of
        // TODO: should this compare the tables as well? (This breaks the
        // SqlParser code currently.)
        BaseTable {tableAlias = tableAlias2} -> 
            tableAlias == tableAlias2;
//                && table == table2;
        _ -> False;
        ;
    SubQueryTable {tableAlias} -> 
        case table2 of
        // TODO: should this compare the subqueries as well? (This breaks the
        // SqlParser code currently.)
        SubQueryTable {tableAlias = tableAlias2} ->
            tableAlias == tableAlias2;
//                && subQuery == subQuery2;
        _ -> False;
        ;
    OpaqueSubQueryTable {tableAlias} -> 
        case table2 of
        OpaqueSubQueryTable {tableAlias = tableAlias2} ->
            tableAlias == tableAlias2;
//                && subqueryText == subqueryText2;
        _ -> False;
        ;
    ;

notEqualsQueryTable :: QueryTable -> QueryTable -> Boolean;
private notEqualsQueryTable table1 table2 = not (equalsQueryTable table1 table2);


/**
 * Query tables can be shown.
 * For subquery tables, the subquery text will not be shown since this may be too verbose.
 */
instance Debug.Show QueryTable where
    show = showQueryTable;
    ;

showQueryTable :: QueryTable -> String;
private showQueryTable table = 
    case table of
    BaseTable {tableRef, tableAlias} -> 
        if (getTableNameFromReference tableRef == tableAlias) then tableAlias
        else (show tableRef) ++ " AS " ++ tableAlias;
   (SubQueryTable | 
    OpaqueSubQueryTable) {tableAlias} -> "<subquery> AS " ++ tableAlias;
    ;


/**
 * Options for the query.
 */
data public QueryOption = 
    /**
     * This option indicates that only distinct rows should be returned for the query.
     */
    public Distinct 
    |
    /**
     * This option indicates that the first N rows should be returned.
     * @arg n         the number of rows to be returned
     * @arg percent   if True then the number with be interpretted as a percentage of the full set of rows,
     *                if False then the number will be interpretted as a number of rows
     * @arg withTies  if True then any rows that are considered equivalent order-wise to the Nth row will also be included in the results;
     *                if False then only the first N rows will be returned, even if there are ties
     */
    public TopN 
        n        :: !Int 
        percent  :: !Boolean 
        withTies :: !Boolean
    deriving Eq, Show
    ;

/**
 * Returns whether the query option specifies TopN criteria.
 * @arg option  a query option
 * @return      True if the query option specifies TopN criteria
 */
isTopNOption :: QueryOption -> Boolean;
public isTopNOption !option = 
    case option of
    TopN {} -> True;
    _ -> False;
    ;


/**
 * Information about a join between 2 tables.
 */
data public JoinInfo = 
    /**
     * Information about a join between 2 tables.
     * @arg leftTable       one of the query tables to be joined
     * @arg rightTable      the other query table to be joined
     * @arg fieldJoinExprs  Boolean expressions joining fields from the tables
     * @arg joinType        the type of join being performed (inner, left outer, right outer, or full outer)
     */
    private JoinInfo 
        leftTable      :: !QueryTable 
        rightTable     :: !QueryTable 
        fieldJoinExprs :: [TypedExpr Boolean] 
        joinType       :: !JoinType 
    deriving Eq
    ;


/**
 * Creates a join info using the query field info specified.
 * The expressions provided must both be {@link QueryField@}s.
 * The link expressions will be created to compare each pair of fields using
 * {@code '='@}.
 * If other link comparison are required, the {@link typeConstructor = JoinInfo@} can be constructed with
 * these explicitly.
 * @arg leftField   an expression for a field in the left table to be joined
 * @arg rightField  an expression for a field in the right table to be joined
 * @arg joinType    the type of join being performed (inner, left outer, right outer, or full outer)
 * @return          join info between the specified table fields
 */
makeJoinInfo :: Eq a => TypedExpr a -> TypedExpr a -> JoinType -> JoinInfo;
public makeJoinInfo !leftField !rightField !joinType =
    let
        tableFromQueryField fieldExpr = 
            case (toUntypedExpr fieldExpr) of
            QueryField {queryTable} -> queryTable;
            _ -> error ("The join fields must be QueryFields");
            ;

        leftTable :: QueryTable;
        leftTable  = tableFromQueryField leftField;

        rightTable :: QueryTable;
        rightTable = tableFromQueryField rightField;

        fieldJoinExpr :: TypedExpr Boolean;
        fieldJoinExpr = eqExpr leftField rightField;
    in
        JoinInfo leftTable rightTable [fieldJoinExpr] joinType;

/**
 * Creates a join info between 2 tables using the specified linking expression.
 * @arg leftTable    one of the query tables to be joined
 * @arg rightTable   the other query table to be joined
 * @arg linkingExpr  a Boolean expression joining fields from the tables
 * @arg joinType     the type of join being performed (inner, left outer, right outer, or full outer)
 */
makeJoinInfo2 :: QueryTable -> QueryTable -> TypedExpr Boolean -> JoinType -> JoinInfo;
public makeJoinInfo2 !leftTable !rightTable linkingExpr !joinType = 
    JoinInfo leftTable rightTable [linkingExpr] joinType;


/**
 * The types of joins that can be performed between two tables.
 */
data public JoinType = 
    /**
     * The inner join option indicates that rows should be returned where 
     * the join condition between the table is satisfied.
     */
    public InnerJoin 
    |
    /**
     * The left outer join option indicates that all rows from the left table should 
     * be included along with values from the right table where the join condition is satisfied.
     */
    public LeftOuterJoin 
    | 
    /**
     * The right outer join option indicates that all rows from the right table should 
     * be included along with values from the left table where the join condition is satisfied.
     */
    public RightOuterJoin
    |
    /**
     * The full outer join option indicates that all rows satisfying the join condition should be returned
     * as well as any unmatched rows from both the left and right tables.
     */
    public FullOuterJoin
    deriving Eq, Show
    ;

/**
 * A binary tree structure for representing joins.
 */
data public JoinNode = 
    /**
     * A node representing a single query table.
     * @arg table  a query table
     */
    public JoinTable 
        table       :: QueryTable 
    |
    /**
     * A node specifying a join between tables in two join trees.
     * @arg leftNode     one of the join trees to be joined
     * @arg rightNode    the other join tree to be joined
     * @arg linkingExpr  a Boolean expression joining tables in the join trees
     * @arg joinType     the type of join to be performed
     */
    public JoinSubtree 
        leftNode    :: JoinNode 
        rightNode   :: JoinNode 
        linkingExpr :: (TypedExpr Boolean) 
        joinType    :: JoinType  
    deriving Eq
    ;

/**
 * Join nodes can be shown.
 */
instance Debug.Show JoinNode where
    show = showJoinNode;
    ;

showJoinNode :: JoinNode -> String;
private showJoinNode !node = 
    case node of
    JoinTable joinTable -> show joinTable;
    JoinSubtree {leftNode, rightNode} -> "{" ++ (showJoinNode leftNode) ++ " -> " ++ (showJoinNode rightNode) ++ "}";
    ;


/**
 * A named set of joins.
 */
data public JoinSet = 
    /**
     * A named set of joins.
     * @arg name   the name of the join set
     * @arg joins  the root join of the join set
     */
    private JoinSet 
        name  :: !String 
        joins :: JoinNode
    deriving Show
    ;

/**
 * Construct a join set from a list of JoinInfo values.
 * @arg name   the name of the join set
 * @arg joins  the joins to be part of the set
 * @return     a join set with the specified name
 */
makeJoinSet :: String -> [JoinInfo] -> JoinSet;
public makeJoinSet !name joins = 
    makeJoinSet2 name (buildJoinTree joins);

/**
 * Construct a join set from a JoinNode tree
 * @arg name      the name of the join set
 * @arg joinTree  the root join of the join set
 * @return        a join set with the specified name
 */
makeJoinSet2 :: String -> JoinNode -> JoinSet;
public makeJoinSet2 !name joinTree = 
    JoinSet name joinTree;

/**
 * Returns the join info from the join set.
 * @arg joinSet  a join set
 * @return       the root join node of the set
 */
joinSetJoinTree :: JoinSet -> JoinNode;
public joinSetJoinTree !joinSet = 
    joinSet.JoinSet.joins;

// Implement the UniquelyNamedItem class.
instance UniquelyNamedItem JoinSet where
    getDisplayName = joinSetName;
    getUniqueIdentifier = joinSetUniqueIdentifier;
    ;

joinSetName !joinSet = joinSet.JoinSet.name;
joinSetUniqueIdentifier !joinSet = makeUniqueIdentifierByName (joinSetName joinSet);


/**
 * A database expression.
 */
data public Expr = 
    /**
     * A reference to a field in a query table.
     * @arg fieldName   the name of the field
     * @arg queryTable  the query table
     */
    private QueryField 
        fieldName     :: String 
        queryTable    :: QueryTable
    |
    /**
     * A literal value expression.
     * @arg constantValue  the constant value
     */
    private ConstExpr 
        constantValue :: ConstValue
    |
    /**
     * A parameter placeholder expression.
     * @arg parameter  the database parameter
     */
    private ParameterExpr
        parameter     :: Parameter
    |
    /**
     * A list of database expressions.
     * @arg listValues  the list of expressions
     */
    private ListExpr 
        listValues    :: [Expr]
    |
    /**
     * A function expression.
     * @arg func       an identifier for the database function
     * @arg arguments  the function argument expressions
     */
    private FunctionExpr 
        func          :: DbFunction 
        arguments     :: [Expr]
    |
    /**
     * A subquery expression.
     * The subquery must have a single projected column.
     * @arg subquery  the subquery to be treated as a database expression
     */
    private SubQueryExpr 
        subquery      :: Query
    deriving Eq, Show
    ;

/**
 * Returns {@link True@} if the expression represents a list.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a list; {@link False@} otherwise
 */
isListExpr :: Expr -> Boolean;
public isListExpr !expr = 
    case expr of
    ListExpr {} -> True;
    _ -> False;
    ;

/**
 * Returns the value expressions from a list expression.
 * An exception will be thrown if the expression is not a list expression.
 * @arg expr  a database expression
 * @return    the list of value expressions form a list expression
 */
getListFromListExpr :: Expr -> [Expr];
public getListFromListExpr !expr =
    case expr of
    ListExpr {listValues} -> listValues;
    _ -> error "Not a list expression";
    ;

/**
 * Returns {@link True@} if the expression represents a constant containing a string value.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a string literal; {@link False@} otherwise
 */
isStringConstExpr :: Expr -> Boolean;
public isStringConstExpr !expr = 
    case expr of
    ConstExpr {constantValue} ->
        case constantValue of
        StringValue {} -> True;
        _ -> False;
        ;
    _ -> False;
    ;

/**
 * Returns the string value from a constant expression.
 * An exception will be thrown if the expression is not a string constant expression.
 * @arg expr  a database expression
 * @return    the string value from the constant database expression
 */
getStringValueFromConstExpr :: Expr -> String;
public getStringValueFromConstExpr !expr =
    case expr of
    ConstExpr {constantValue} -> 
        case constantValue of
        StringValue {strValue} -> strValue;
        _ -> error "Not a string constant expression";
        ;
    _ -> error "Not a constant expression";
    ;

/**
 * Returns {@link True@} if the expression represents a constant containing a number value.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a numeric literal; {@link False@} otherwise
 */
isNumberConstExpr :: Expr -> Boolean;
public isNumberConstExpr !expr = 
    case expr of
    ConstExpr {constantValue} ->
        case constantValue of
        NumberValue {} -> True;
        _ -> False;
        ;
    _ -> False;
    ;

/**
 * Returns the number value from a constant expression.
 * An exception will be thrown if the expression is not a numeric constant expression.
 * @arg expr  a database expression
 * @return    the numeric value from the constant database expression
 */
getNumberValueFromConstExpr :: Expr -> Double;
public getNumberValueFromConstExpr !expr =
    case expr of
    ConstExpr {constantValue} -> 
        case constantValue of
        NumberValue {numValue} -> numValue;
        _ -> error "Not a number constant expression";
        ;
    _ -> error "Not a constant expression";
    ;

/**
 * Returns {@link True@} if the expression represents a constant containing a boolean value.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a Boolean constant; {@link False@} otherwise
 */
isBooleanConstExpr :: Expr -> Boolean;
public isBooleanConstExpr !expr = 
    case expr of
    ConstExpr {constantValue} ->
        case constantValue of
        BooleanValue {} -> True;
        _ -> False;
        ;
    _ -> False;
    ;

/**
 * Returns the boolean value from a constant expression.
 * An exception will be thrown if the expression is not a constant Boolean expression.
 * @arg expr  a database expression
 * @return    the Boolean value from the constant database expression
 */
getBooleanValueFromConstExpr :: Expr -> Boolean;
public getBooleanValueFromConstExpr !expr =
    case expr of
    ConstExpr {constantValue} -> 
        case constantValue of
        BooleanValue {boolValue} -> boolValue;
        _ -> error "Not a boolean constant expression";
        ;
    _ -> error "Not a constant expression";
    ;

/**
 * Returns {@link True@} if the expression represents a constant containing a time value.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a time constant; {@link False@} otherwise
 */
isTimeConstExpr :: Expr -> Boolean;
public isTimeConstExpr !expr = 
    case expr of
    ConstExpr {constantValue} ->
        case constantValue of
        TimeValue {} -> True;
        _ -> False;
        ;
    _ -> False;
    ;

/**
 * Returns the time value from a constant expression.
 * An exception will be thrown if the expression is not a time constant expression.
 * @arg expr  a database expression
 * @return    the time value from the constant database expression
 */
getTimeValueFromConstExpr :: Expr -> Time;
public getTimeValueFromConstExpr !expr =
    case expr of
    ConstExpr {constantValue} -> 
        case constantValue of
        TimeValue {timeValue} -> timeValue;
        _ -> error "Not a time constant expression";
        ;
    _ -> error "Not a constant expression";
    ;

/**
 * Returns {@link True@} if the expression represents a field in a query table.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a field in a query table; {@link False@} otherwise
 */
isQueryFieldExpr :: Expr -> Boolean;
public isQueryFieldExpr !expr = 
    case expr of
    QueryField {} -> True;
    _ -> False;
    ;

/**
 * Returns the query table from a query field expression.
 * An exception will be thrown if the expression is not a query field expression.
 * @arg expr  a database expression
 * @return    the field name from the query field expression
 */
getFieldNameFromQueryFieldExpr :: Expr -> String;
public getFieldNameFromQueryFieldExpr !expr =
    case expr of
    QueryField {fieldName} -> fieldName;
    _ -> error "Not a query field expression";
    ;

/**
 * Returns the field name from a query field expression.
 * An exception will be thrown if the expression is not a query field expression.
 * @arg expr  a database expression
 * @return    the query table from the query field expression
 */
getQueryTableFromQueryFieldExpr :: Expr -> QueryTable;
public getQueryTableFromQueryFieldExpr !expr =
    case expr of
    QueryField {queryTable} -> queryTable;
    _ -> error "Not a query field expression";
    ;

/**
 * Returns {@link True@} if the expression represents a function (or operator)
 * application.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a database function expression; {@link False@} otherwise
 */
isFunctionExpr :: Expr -> Boolean;
public isFunctionExpr !expr =
    case expr of
    FunctionExpr {} -> True;
    _ -> False;
    ;

/**
 * Returns the function type from a function expression.
 * An exception will be thrown if the expression is not a function expression.
 * @arg expr  a database expression
 * @return    the function identifier from the function expression
 */
getFunctionFromFunctionExpr :: Expr -> DbFunction;
public getFunctionFromFunctionExpr !expr =
    case expr of
    FunctionExpr {func} -> func;
    _ -> error "Not a function expression";
    ;

/**
 * Returns the arguments from a function expression.
 * An exception will be thrown if the expression is not a function expression.
 * @arg expr  a database expression
 * @return    the argument expressions from the function expression
 */
getArgumentsFromFunctionExpr :: Expr -> [Expr];
public getArgumentsFromFunctionExpr !expr =
    case expr of
    FunctionExpr {arguments} -> arguments;
    _ -> error "Not a function expression";
    ;

/**
 * Returns whether the expression represents an operator applied to one or more
 * arguments.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents an operator applied to one or
 *            more arguments; {@link False@} otherwise
 */
isOperatorExpr :: Expr -> Boolean;
public isOperatorExpr !expr =
    case expr of
    FunctionExpr {func} -> isOperator func;
    _ -> False;
    ;


/**
 * {@code TypedExpr@} wraps an untyped {@link Expr@} and adds information about the expression
 * data type.
 */
data public TypedExpr a = 
    private TypedExpr 
        untypedExpr :: Expr
    ;

/**
 * Returns the untyped expression from a typed expression.
 * @arg typedExpr  a typed database expression
 * @return         the untyped database expression
 */
toUntypedExpr :: TypedExpr a -> Expr;
public toUntypedExpr !typedExpr = typedExpr.TypedExpr.untypedExpr;

/**
 * Returns a typed expression from the untyped expression.
 * @arg untypedExpr  an untyped database expression
 * @return           the typed database expression
 */
toTypedExpr :: Expr -> TypedExpr a;
public toTypedExpr = TypedExpr;


/**
 * Returns the type of the values represented by this typed expression.
 * @arg expr  a database expression
 * @return    the type of the database expression
 */
typeOfExpr :: Prelude.Typeable a => TypedExpr a -> Prelude.TypeRep;
public typeOfExpr !expr = 
    head (Prelude.typeArguments (Prelude.typeOf expr));

// Allow typed expressions to be compared for equality.
instance Eq (TypedExpr a) where
    equals = equalsTypedExpr;
    notEquals = notEqualsTypedExpr;
    ;

// Allow typed expressions to be shown.
instance Show (TypedExpr a) where
    show = showTypedExpr;
    ;

showTypedExpr :: TypedExpr a -> String;
showTypedExpr !typedExpr = 
    show typedExpr.TypedExpr.untypedExpr;

/**
 * Checks whether 2 typed expressions are equal.
 */
private equalsTypedExpr !expr1 !expr2 = 
    (toUntypedExpr expr1) == (toUntypedExpr expr2);

private notEqualsTypedExpr !expr1 !expr2 = 
    not (equalsTypedExpr expr1 expr2);


/**
 * A constant value.
 */
data private ConstValue = 
    private NullValue
    |
    private StringValue
        strValue::String
    |
    private NumberValue
        numValue::Double
    |
    private BooleanValue
        boolValue::Boolean
    |
    private TimeValue
        timeValue::Time
    deriving Eq, Show
    ;

/**
 * Construct a database expression for a string literal.
 * @arg strValue  the string literal value
 * @return        the database expression for the string literal
 */
stringConstant :: String -> TypedExpr String;
public stringConstant strValue = 
    TypedExpr (ConstExpr (StringValue strValue));

/**
 * Construct a database expression for a numeric literal.
 * @arg numValue  the numeric literal value
 * @return        the database expression for the numeric literal
 */
numericConstant :: Num a => a -> TypedExpr a;
public numericConstant numValue = 
    TypedExpr (ConstExpr (NumberValue (toDouble numValue)));

/**
 * Construct a database expression for a Boolean value.
 * @arg boolValue  the Boolean value
 * @return         the database expression for the Boolean value
 */
booleanConstant :: Boolean -> TypedExpr Boolean;
public booleanConstant !boolValue = 
    if boolValue then trueConstant else falseConstant;

/**
 * A database expression for the Boolean value True.
 * @return  the database expression for the Boolean value True
 */
trueConstant :: TypedExpr Boolean;
public trueConstant = 
    TypedExpr (ConstExpr (BooleanValue True));

/**
 * A database expression for the Boolean value False.
 * @return  the database expression for the Boolean value False
 */
falseConstant :: TypedExpr Boolean;
public falseConstant = 
    TypedExpr (ConstExpr (BooleanValue False));

/**
 * Construct a database expression for a time literal.
 * @arg timeValue  the time literal value
 * @return         the database expression for the time literal
 */
timeConstant :: Time -> TypedExpr Time;
public timeConstant timeValue = 
    TypedExpr (ConstExpr (TimeValue timeValue));

/**
 * A database expression for a null value of some data type.
 * @return  a database expression for a null value
 */
nullValue :: TypedExpr a;
public nullValue = 
    TypedExpr (ConstExpr NullValue);

/**
 * Tests whether an untyped expression has the constant value of null.
 * This does not check whether an expression evaluates to null -- it simply
 * checks whether it has the constant value of null.
 * @arg expr  a database expression
 * @return    True if the expression has the constant value of null
 */
isNullValue :: Expr -> Boolean;
public isNullValue !expr = 
    case expr of
    ConstExpr {constantValue} -> 
        case constantValue of
        NullValue -> True;
        _ -> False;
        ;
    _ -> False;
    ;

/**
 * A database parameter that can be used in place of a value in a SQL statement.
 * The parameter values can be bound in when executing the SQL statement.
 * This is often used to execute the same statement multiple times with different values.
 */
data public Parameter = 
    /**
     * A parameter without a name.
     * The values for unnamed parameters will be bound based on the position of the
     * parameter in the SQL statement.
     */
    private UnnamedParameter 
    |
    /**
     * A parameter with an associated name.
     * Note: JDBC 3.0 only supports named parameter for CallableStatement.
     */
    private NamedParameter 
        name :: String
    deriving Eq, Show
    ;

/**
 * Returns whether the parameter is a named one.
 * @arg param  a database parameter
 * @return     True if the parameter is named one; False if the parameter is unnamed
 */
isUnnamedParameter :: Parameter -> Boolean;
public isUnnamedParameter !param =
    case param of
    UnnamedParameter -> True;
    _ -> False;
    ;

/**
 * Returns the name of a named parameter.
 * An error will be thrown if the parameter is unnamed.
 * @arg param  a database parameter
 * @return     the name of the named database parameter
 */
getParameterName :: Parameter -> String;
public getParameterName !param =
    case param of
    NamedParameter {name} -> name;
    _ -> error "Only a named parameter has a name!";
    ;

/**
 * Constructs an string expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a string database expression for a database parameter
 */
stringParameter :: Maybe String -> TypedExpr String;
public stringParameter !maybeParamName = TypedExpr $ untypedParameter maybeParamName;

/**
 * Constructs an integer expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a integer database expression for a database parameter
 */
integerParameter :: Maybe String -> TypedExpr Int;
public integerParameter !maybeParamName = TypedExpr $ untypedParameter maybeParamName;

/**
 * Constructs an double expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a double database expression for a database parameter
 */
doubleParameter :: Maybe String -> TypedExpr Double;
public doubleParameter !maybeParamName = TypedExpr $ untypedParameter maybeParamName;

/**
 * Constructs an Boolean expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a Boolean database expression for a database parameter
 */
booleanParameter :: Maybe String -> TypedExpr Boolean;
public booleanParameter !maybeParamName = TypedExpr $ untypedParameter maybeParamName;

/**
 * Constructs an time expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a time database expression for a database parameter
 */
timeParameter :: Maybe String -> TypedExpr Time;
public timeParameter !maybeParamName = TypedExpr $ untypedParameter maybeParamName;

/**
 * Constructs an untyped expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a database expression for a database parameter
 */
untypedParameter :: Maybe String -> Expr;
private untypedParameter !maybeParamName =
    case maybeParamName of
    Just paramName -> ParameterExpr $ NamedParameter paramName;
    Nothing        -> ParameterExpr $ UnnamedParameter;
    ;

/**
 * Constructs an untyped database expression for a list of values.
 * @arg listValues  a list of database expressions for the list value
 * @return          an untyped database expression for the list of values
 */
untypedListExpr :: [Expr] -> Expr;
public untypedListExpr listValues = ListExpr listValues;

/**
 * Constructs a typed database expression for a list of values.
 * This probably doesn't need to be exposed since it can only be used with 
 * the IN binary operator anyway.
 * @arg listValues  a list of database expressions for the list value
 * @return          a typed database expression for the list of values
 */
listExpr :: [TypedExpr a] -> TypedExpr [a];
private listExpr listValues = TypedExpr (ListExpr (map toUntypedExpr listValues));


/**
 * Creates a database expression based on a subquery.
 * Any ordering will be removed from the subquery (unless it uses {@link TopN@}).
 * The subquery must have a single projected column.
 * @arg subquery  the subquery to be treated as a database expression
 * @return        a database expression based on the subquery
 */
subQueryExpr :: Query -> Expr;
public subQueryExpr !subquery = 
    let
        // Remove any ordering from the subquery (unless it uses TopN).
        fixedSubquery = fixSubqueryOrdering subquery;
    in
        // Check that there is only 1 return column in the subquery.
        // TODO: is there a way to make this typed based on the (one and only) result column in the query?
        if (isSingletonList (getProjectedColumns fixedSubquery)) then SubQueryExpr fixedSubquery
        else error "Only subqueries returning a single column can be used as field expressions";


/**
 * Database expression functions and operators.
 */
data public DbFunction = 
    
    // Unary operators.
    public OpNot | public OpBitNot | public OpNegate
    | public OpIsNull | public OpIsNotNull
    | public OpExists
    
    // Binary operators
    | public OpEq | public OpLt | public OpLtEq | public OpGt | public OpGtEq | public OpNotEq 
    | public OpAnd | public OpOr
    | public OpLike | public OpIn
    | public OpCat
    | public OpPlus | public OpMinus | public OpMul | public OpDiv | public OpMod
    | public OpBitAnd | public OpBitOr | public OpBitXor
    
    // Other operators
    | public OpBetween | public OpCase_Simple | public OpCase_Searched

    // Conversion functions
    | public ConvertToStringFunction 
    | public ConvertToIntFunction 
    | public ConvertToDoubleFunction
    | public ConvertToTimeFunction

    // Numeric functions
    | public AbsFunction | public AcosFunction | public AsinFucntion | public AtanFunction | public Atan2Function
    | public CeilingFunction | public CosFunction | public CotFunction | public DegreesFunction | public ExpFunction
    | public FloorFunction | public LogFunction | public Log10Function | public ModFunction | public PiFunction
    | public PowerFunction | public RadiansFunction | public RandFunction | public RoundFunction | public SignFunction
    | public SinFunction | public SqrtFunction | public TanFunction | public TruncateFunction

    // String functions
    | public AsciiFunction | public CharFunction | public DifferenceFunction
    | public InsertFunction| public LcaseFunction | public LeftFunction | public LengthFunction | public LocateFunction
    | public LtrimFunction | public RepeatFunction | public ReplaceFunction | public RightFunction | public RtrimFunction
    | public SoundexFunction | public SpaceFunction | public SubstringFunction | public UcaseFunction

    // System functions
    | public DatabaseFunction | public UserFunction

    // Null-handling functions
    | public IfNullFunction | public NullIfFunction 

    // DateTime functions
    | public DayNameFunction | public DayOfWeekFunction | public DayOfMonthFunction | public DayOfYearFunction | public HourFunction | public MinuteFunction
    | public MonthFunction | public MonthNameFunction | public NowFunction | public QuarterFunction | public SecondFunction
    | public WeekFunction | public YearFunction
    | public DateTimeAddFunction timeInterval :: TimeInterval
    | public DateTimeDiffFunction timeInterval :: TimeInterval

    // Aggregation functions.
    | public AggrCount | public AggrSum | public AggrAvg | public AggrMin | public AggrMax
    | public AggrDistinctCount | public AggrDistinctSum | public AggrDistinctAvg
    | public AggrCountAll
    | public AggrStdDev | public AggrStdDevP | public AggrVar | public AggrVarP
    | public AggrOther  other :: String

    // A function with the specified name.
    | public FunctionOther funcName :: String

    deriving Eq, Show
    ;

/**
 * Possible time interval values for working with date/time values.
 */
data public TimeInterval = 
    public YearInterval 
    | public QuarterInterval
    | public MonthInterval
    | public DayInterval
    | public HourInterval
    | public MinuteInterval
    | public SecondInterval
    deriving Eq, Show
    ;

/**
 * Indicates whether a specified function is an aggregation function or not.
 * @arg fn  a database function identifier
 * @return  True if the specified function is an aggregation function
 */
isAggregationFunction :: DbFunction -> Boolean;
public isAggregationFunction !fn = 
    case fn of
   (AggrCount |
    AggrSum |
    AggrAvg |
    AggrMin |
    AggrMax |
    AggrDistinctCount |
    AggrDistinctSum   |
    AggrDistinctAvg   |
    AggrCountAll |
    AggrStdDev |
    AggrStdDevP |
    AggrVar |
    AggrVarP |
    AggrOther) {} -> True;
    _ -> False;
    ;

/**
 * Returns the default name of a database function.
 */
defaultFunctionName :: DbFunction -> String;
public defaultFunctionName !func =
    case func of
//    ConvertFunction -> "CONVERT";

    AbsFunction     -> "ABS";
    AcosFunction    -> "ACOS";
    AsinFucntion    -> "ASIN";
    AtanFunction    -> "ATAN";
    Atan2Function   -> "ATAN2";
    CeilingFunction -> "CEILING";
    CosFunction     -> "COS";
    CotFunction     -> "COT";
    DegreesFunction -> "DEGREES";
    ExpFunction     -> "EXP";
    FloorFunction   -> "FLOOR";
    LogFunction     -> "LOG";
    Log10Function   -> "LOG10";
    ModFunction     -> "MOD";
    PiFunction      -> "PI";
    PowerFunction   -> "POWER";
    RadiansFunction -> "RADIANS";
    RandFunction    -> "RAND";
    RoundFunction   -> "ROUND";
    SignFunction    -> "SIGN";
    SinFunction     -> "SIN";
    SqrtFunction    -> "SQRT";
    TanFunction     -> "TAN";
    TruncateFunction -> "TRUNCATE";

    AsciiFunction   -> "ASCII";
    CharFunction    -> "CHAR";
// TODO: use the OpCat operator instead...
//    ConcatFunction  -> "CONCAT";
    DifferenceFunction -> "DIFFERENCE";
    InsertFunction  -> "INSERT";
    LcaseFunction   -> "LCASE";
    LeftFunction    -> "LEFT";
    LengthFunction  -> "LENGTH";
    LocateFunction  -> "LOCATE";
    LtrimFunction   -> "LTRIM";
    RepeatFunction  -> "REPEAT";
    ReplaceFunction -> "REPLACE";
    RightFunction   -> "RIGHT";
    RtrimFunction   -> "RTRIM";
    SoundexFunction -> "SOUNDEX";
    SpaceFunction   -> "SPACE";
    SubstringFunction -> "SUBSTRING";
    UcaseFunction   -> "UCASE";
    DatabaseFunction -> "DATABASE";
    IfNullFunction  -> "IFNULL";
    NullIfFunction  -> "NULLIF";
    UserFunction    -> "USER";

    DayNameFunction -> "DAYNAME";
    DayOfWeekFunction -> "WEEKDAY";
    DayOfMonthFunction -> "DAY";
    DayOfYearFunction -> "DAYOFYEAR";
    HourFunction    -> "HOUR";
    MinuteFunction  -> "MINUTE";
    MonthFunction   -> "MONTH";
    MonthNameFunction -> "MONTHNAME";
    NowFunction     -> "NOW";
    QuarterFunction -> "QUARTER";
    SecondFunction  -> "SECOND";
//    TimestampAddFunction -> "TIMESTAMPADD";
//    TimestampDiffFunction -> "TIMESTAMPDIFF";
    WeekFunction    -> "WEEK";
    YearFunction    -> "YEAR";
    DateTimeAddFunction {} -> "DATEADD";
    DateTimeDiffFunction {} -> "DATEDIFF";

    AggrCount       -> "COUNT";
    AggrSum         -> "SUM";
    AggrAvg         -> "AVG";
    AggrMin         -> "MIN";
    AggrMax         -> "MAX";
    AggrStdDev      -> "STDDEV";
    AggrStdDevP     -> "STDDEVP";
    AggrVar         -> "VAR";
    AggrVarP        -> "VARP";
    AggrOther {other} -> other;

    // Note:  the following block of functions are generated specially, but names are included here for
    //        purposes of outputing to Java.
    AggrDistinctCount -> "DISTINCT COUNT";
    AggrDistinctSum   -> "DISTINCT SUM";
    AggrDistinctAvg   -> "DISTINCT AVG";
    AggrCountAll      -> "COUNT ALL";     

    FunctionOther {funcName} -> funcName;
    ;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// SQL Functions

/**
 * Constructs an untyped database expression for a call to a database function.
 * No checking will be done for the number or types of the arguments.
 * Where possible the appropriate type-safe function should be called to construct the 
 * function expression.
 * @arg func       an identifier for a database function
 * @arg arguments  a list of database expressions for the function arguments
 * @return         an untyped database expression for a call to the database function
 */
untypedFunctionExpr :: DbFunction -> [Expr] -> Expr;
public untypedFunctionExpr func arguments = FunctionExpr func arguments;

// Helper functions to construct typed function expressions.
// These should not be exposed.
functionExpr0 :: DbFunction -> TypedExpr a;
private functionExpr0 func = TypedExpr (untypedFunctionExpr func []);

functionExpr1 :: DbFunction -> TypedExpr a -> TypedExpr b;
private functionExpr1 func arg1 = TypedExpr (untypedFunctionExpr func [toUntypedExpr arg1]);

functionExpr2 :: DbFunction -> TypedExpr a -> TypedExpr b -> TypedExpr c;
private functionExpr2 func arg1 arg2 = TypedExpr (untypedFunctionExpr func [toUntypedExpr arg1, toUntypedExpr arg2]);

functionExpr3 :: DbFunction -> TypedExpr a -> TypedExpr b -> TypedExpr c -> TypedExpr d;
private functionExpr3 func arg1 arg2 arg3 = TypedExpr (untypedFunctionExpr func [toUntypedExpr arg1, toUntypedExpr arg2, toUntypedExpr arg3]);

functionExpr4 :: DbFunction -> TypedExpr a -> TypedExpr b -> TypedExpr c -> TypedExpr d -> TypedExpr e;
private functionExpr4 func arg1 arg2 arg3 arg4 = TypedExpr (untypedFunctionExpr func [toUntypedExpr arg1, toUntypedExpr arg2, toUntypedExpr arg3, toUntypedExpr arg4]);


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Unary operator expressions

/**
 * Constructs an untyped database expression for the application of a unary operator.
 * No checking will be done for the type of the argument.
 * Where possible the appropriate type-safe function should be called to construct the 
 * function expression.
 * @arg func      an identifier for a unary operator
 * @arg argument  a database expression to which the unary operator will be applied
 * @return        an untyped database expression for the application of the unary operator
 */
untypedUnaryExpr :: DbFunction -> Expr -> Expr;
public untypedUnaryExpr func argument = FunctionExpr func [argument];

/**
 * Constructs a database expression for the application of the 'not' operator to a Boolean argument.
 * @arg boolExpr  a Boolean database expression
 * @return        a Boolean database expression for the application of the 'not' operator to the argument expression
 */
notExpr :: TypedExpr Boolean -> TypedExpr Boolean;
public notExpr = functionExpr1 OpNot;

/**
 * Constructs a database expression for the application of the bitwise 'not' operator to an integer argument.
 * @arg intExpr  an integer database expression
 * @return       an integer database expression for the application of the bitwise 'not' operator to the argument expression
 */
bitwiseNotExpr :: TypedExpr Int -> TypedExpr Int;
public bitwiseNotExpr = functionExpr1 OpBitNot;

/**
 * Constructs a database expression for the negation of the numeric argument expression.
 * @arg numExpr  a numeric database expression
 * @return       a numeric database expression for the negation of the argument expression
 */
negateExpr :: Num a => TypedExpr a -> TypedExpr a;
public negateExpr = functionExpr1 OpNegate;

/**
 * Constructs a database expression to test whether an argument expression is null.
 * @arg expr  a database expression
 * @return    a Boolean database expression to test test whether an argument expression is null
 */
isNullExpr :: TypedExpr a -> TypedExpr Boolean;
public isNullExpr = functionExpr1 OpIsNull;

/**
 * Constructs a database expression to test whether an argument expression is non-null.
 * @arg expr  a database expression
 * @return    a Boolean database expression to test test whether an argument expression is non-null
 */
isNotNullExpr :: TypedExpr a -> TypedExpr Boolean;
public isNotNullExpr = functionExpr1 OpIsNotNull;

/**
 * Constructs a database expression to test whether the argument subquery expression returns any rows.
 * @arg subqueryExpr  a subquery expressoin
 * @return            a Boolean database expression to test whether the argument subquery expression returns any rows
 */
existsExpr :: TypedExpr [a] -> TypedExpr Boolean;
public existsExpr subqueryExpr = 
    // TODO: is there any way to make this only accept subqueries?
    functionExpr1 OpExists subqueryExpr;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Binary operator expressions

/**
 * Constructs an untyped database expression for the application of a binary operator.
 * No checking will be done for the types of the arguments.
 * Where possible the appropriate type-safe function should be called to construct the 
 * function expression.
 * @arg func           an identifier for a binary operator
 * @arg leftArgument   a database expression for the left argument to which the operator will be applied
 * @arg rightArgument  a database expression for the right argument to which the operator will be applied
 * @return             an untyped database expression for the application of the binary operator
 */
untypedBinaryExpr :: DbFunction -> Expr -> Expr -> Expr;
public untypedBinaryExpr func leftArgument rightArgument = FunctionExpr func [leftArgument, rightArgument];

/**
 * Constructs a database expression which test two operand expressions for equality.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test the operand expressions for equality
 */
eqExpr :: Eq a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public eqExpr = functionExpr2 OpEq;

/**
 * Constructs a database expression which tests two operand expressions for inequality.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test the operand expressions for inequality
 */
notEqExpr :: Eq a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public notEqExpr = functionExpr2 OpNotEq;

/**
 * Constructs a database expression to test whether the first operand is less than the second.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test whether the first operand is less than the second
 */
ltExpr :: Ord a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public ltExpr = functionExpr2 OpLt;

/**
 * Constructs a database expression to test whether the first operand is greater than the second.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test whether the first operand is greater than the second
 */
gtExpr :: Ord a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public gtExpr = functionExpr2 OpGt;

/**
 * Constructs a database expression to test whether the first operand is less than or equal to the second.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test whether the first operand is less than or equal to the second
 */
ltEqExpr :: Ord a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public ltEqExpr = functionExpr2 OpLtEq;

/**
 * Constructs a database expression to test whether the first operand is greater than or equal to the second.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test whether the first operand is greater than or equal to the second
 */
gtEqExpr :: Ord a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public gtEqExpr = functionExpr2 OpGtEq;

/**
 * Constructs a database expression to test whether both of the operand expressions are True.
 * @arg b1  a database expression for the first operand
 * @arg b2  a database expression for the second operand
 * @return     a Boolean database expression to test whether both of the operand expressions are True
 */
andExpr :: TypedExpr Boolean -> TypedExpr Boolean -> TypedExpr Boolean;
public andExpr !b1 b2 = 
    if (b1 == trueConstant) then b2
    else if (b2 == trueConstant) then b1
    else if (b1 == falseConstant || b2 == falseConstant) then falseConstant
    else functionExpr2 OpAnd b1 b2;

/**
 * Constructs a database expression to test whether either of the operand expressions are True.
 * @arg b1  a database expression for the first operand
 * @arg b2  a database expression for the second operand
 * @return     a Boolean database expression to test whether either of the operand expressions are True
 */
orExpr :: TypedExpr Boolean -> TypedExpr Boolean -> TypedExpr Boolean;
public orExpr b1 b2 = 
    if (b1 == falseConstant) then b2
    else if (b2 == falseConstant) then b1
    else if (b1 == trueConstant || b2 == trueConstant) then trueConstant
    else functionExpr2 OpOr b1 b2;

/**
 * Constructs a database expression to test whether the first string operand expression matches 
 * the pattern of the second operand expression.
 * @arg strExpr      a string database expression for the first operand
 * @arg patternExpr  a string database expression for the pattern against which the first operand will be tested
 * @return           a Boolean database expression to test whether first string operand expression matches 
 *                   the pattern of the second operand expression
 */
likeExpr :: TypedExpr String -> TypedExpr String -> TypedExpr Boolean;
public likeExpr = functionExpr2 OpLike;

/**
 * Constructs a database expression to test whether the value of the first operand is equal to the value
 * returned by one of the list operand expressions.
 * @arg leftExpr        a database expression for the first operand
 * @arg listValueExprs  a database expression for the values against the first operand will be tested
 * @return              a Boolean database expression to test whether the value of the first operand is one of 
 *                      the values returned by the list operand expression
 */
inExpr :: Eq a => TypedExpr a -> [TypedExpr a] -> TypedExpr Boolean;
public inExpr leftExpr listValueExprs = functionExpr2 OpIn leftExpr (listExpr listValueExprs);

/**
 * Constructs a database expression to test whether the value of the first operand is one of the values 
 * returned by the list operand expression.
 * @arg leftExpr        a database expression for the first operand
 * @arg listValuesExpr  a database expression for the values against the first operand will be tested
 * @return              a Boolean database expression to test whether the value of the first operand is one of 
 *                      the values returned by the list operand expression
 */
inExpr2 :: Eq a => TypedExpr a -> TypedExpr [a] -> TypedExpr Boolean;
public inExpr2 leftExpr listValuesExpr = functionExpr2 OpIn leftExpr listValuesExpr;

/**
 * Constructs a database expression to concatenate two string operand expressions.
 * @arg expr1  a string database expression for the first operand
 * @arg expr2  a string database expression for the second operand
 * @return     a string database expression to concatenate the string operand expressions
 */
concatExpr :: TypedExpr String -> TypedExpr String -> TypedExpr String;
public concatExpr = functionExpr2 OpCat;

/**
 * A helper function for constructing a numeric binary operator.
 * Do not expose this.
 */
numBinaryExpr :: Num a => DbFunction -> TypedExpr a -> TypedExpr a -> TypedExpr a;
private numBinaryExpr = functionExpr2;

/**
 * Constructs a database expression to add two numeric operand expressions.
 * @arg expr1  a numeric database expression for the first operand
 * @arg expr2  a numeric database expression for the second operand
 * @return     a numeric database expression to add the two numeric operand expressions
 */
public addExpr      = numBinaryExpr OpPlus;

/**
 * Constructs a database expression to subtract two numeric operand expressions.
 * @arg expr1  a numeric database expression for the first operand
 * @arg expr2  a numeric database expression for the second operand
 * @return     a numeric database expression to subtract the two numeric operand expressions
 */
public subtractExpr = numBinaryExpr OpMinus;

/**
 * Constructs a database expression to multiply two numeric operand expressions.
 * @arg expr1  a numeric database expression for the first operand
 * @arg expr2  a numeric database expression for the second operand
 * @return     a numeric database expression to multiply the two numeric operand expressions
 */
public multiplyExpr = numBinaryExpr OpMul;

/**
 * Constructs a database expression to divide two numeric operand expressions.
 * @arg expr1  a numeric database expression for the first operand
 * @arg expr2  a numeric database expression for the second operand
 * @return     a numeric database expression to divide the two numeric operand expressions
 */
public divideExpr   = numBinaryExpr OpDiv;

/**
 * Constructs a database expression to return the modulus of two numeric operand expressions.
 * @arg expr1  a numeric database expression for the first operand
 * @arg expr2  a numeric database expression for the second operand
 * @return     a numeric database expression to return the modulus of the two numeric operand expressions
 */
public modulusExpr  = numBinaryExpr OpMod;

/**
 * A helper function for constructing an integer binary operator.
 * Do not expose this.
 */
intBinaryExpr :: DbFunction -> TypedExpr Int -> TypedExpr Int -> TypedExpr Int;
private intBinaryExpr = functionExpr2;

/**
 * Constructs a database expression to perform a bitwise 'and' of two numeric operand expressions.
 * @arg expr1  an integer database expression for the first operand
 * @arg expr2  an integer database expression for the second operand
 * @return     an integer database expression to perform a bitwise 'and' of two numeric operand expressions
 */
public bitwiseAndExpr = intBinaryExpr OpBitAnd;

/**
 * Constructs a database expression to perform a bitwise 'or' of two numeric operand expressions.
 * @arg expr1  an integer database expression for the first operand
 * @arg expr2  an integer database expression for the second operand
 * @return     an integer database expression to perform a bitwise 'or' of two numeric operand expressions
 */
public bitwiseOrExpr  = intBinaryExpr OpBitOr;

/**
 * Constructs a database expression to perform a bitwise 'xor' of two numeric operand expressions.
 * @arg expr1  an integer database expression for the first operand
 * @arg expr2  an integer database expression for the second operand
 * @return     an integer database expression to perform a bitwise 'xor' of two numeric operand expressions
 */
public bitwiseXorExpr = intBinaryExpr OpBitXor;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Other operator expressions

/**
 * Constructs a database expression which test whether the value of one operand expression is between 
 * the value of two other operand expressions.
 * @arg leftExpr   a database expression to be tested
 * @arg lowerExpr  a database expression for the lower bound of the value range
 * @arg upperExpr  a database expression for the upper bound of the value range
 * @return         a Boolean database expression to test whether the value of one operand expression is between 
 *                 the value of two other operand expressions
 */
betweenExpr :: Ord a => TypedExpr a -> TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public betweenExpr leftExpr lowerExpr upperExpr = functionExpr3 OpBetween leftExpr lowerExpr upperExpr;

/**
 * Constructs a database expression for a simple case statement.
 * When this expression is evaluated, the result value of the matching WHEN clause will be returned.
 * If none of the WHEN values match the case value, then the ELSE value will be returned.
 * @arg caseExpr             a database expression for the value to be tested
 * @arg whenValueAndResults  a list of pairs of comparison values and the corresponding result values
 * @arg elseValue            a database expression for the value to be returned if none of the WHEN clauses match
 * @return                   a database expression for a simple case statement
 */
simpleCaseExpr :: Eq a => TypedExpr a -> [(TypedExpr a, TypedExpr b)] -> Maybe (TypedExpr b) -> TypedExpr b;
public simpleCaseExpr caseExpr whenValueAndResults elseValue = 
    let
        unTypedExprs = toUntypedExpr caseExpr 
                        : concatMap (\pr -> [toUntypedExpr (fst pr), toUntypedExpr (snd pr)]) whenValueAndResults 
                        ++ map toUntypedExpr (maybeToList elseValue);
    in
        TypedExpr (untypedFunctionExpr OpCase_Simple unTypedExprs);

/**
 * Construct a database expression for a searched case statement.
 * Each WHEN clause will contain a Boolean expression and a result value.
 * The result will be the result value for the first WHEN clause with a condition that returns True.
 * If none of the WHEN clause expressions return True, then the ELSE value will be returned.
 * @arg whenConditionAndResults  a list of pairs of Boolean condition expressions and result values
 * @arg elseValue                a database expression for the value to be returned if none of the WHEN clauses evaluate to True
 * @return                       a database expression for a searched case statement
 */
searchedCaseExpr :: [(TypedExpr Boolean, TypedExpr b)] -> Maybe (TypedExpr b) -> TypedExpr b;
public searchedCaseExpr whenConditionAndResults elseValue = 
    let
        unTypedExprs = concatMap (\pr -> [toUntypedExpr (fst pr), toUntypedExpr (snd pr)]) whenConditionAndResults 
                        ++ map toUntypedExpr (maybeToList elseValue);
    in
        TypedExpr (untypedFunctionExpr OpCase_Searched unTypedExprs);


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Numeric functions

absExpr :: Num a => TypedExpr a -> TypedExpr a;
public absExpr = functionExpr1 AbsFunction;

acosExpr :: TypedExpr Double -> TypedExpr Double;
public acosExpr = functionExpr1 AcosFunction;

asinExpr :: TypedExpr Double -> TypedExpr Double;
public asinExpr = functionExpr1 AsinFucntion;

atanExpr :: TypedExpr Double -> TypedExpr Double;
public atanExpr = functionExpr1 AtanFunction;

atan2Expr :: TypedExpr Double -> TypedExpr Double -> TypedExpr Double;
public atan2Expr = functionExpr2 Atan2Function;

ceilingExpr :: Num a => TypedExpr a -> TypedExpr Int;
public ceilingExpr = functionExpr1 CeilingFunction;

cosExpr :: TypedExpr Double -> TypedExpr Double;
public cosExpr = functionExpr1 CosFunction;

cotExpr :: TypedExpr Double -> TypedExpr Double;
public cotExpr = functionExpr1 CotFunction;

degreesExpr :: TypedExpr Double -> TypedExpr Double;
public degreesExpr = functionExpr1 DegreesFunction;

expExpr :: Num a => TypedExpr a -> TypedExpr Double;
public expExpr = functionExpr1 ExpFunction;

floorExpr :: Num a => TypedExpr a -> TypedExpr Int;
public floorExpr = functionExpr1 FloorFunction;

logExpr :: Num a => TypedExpr a -> TypedExpr Double;
public logExpr = functionExpr1 LogFunction;

log10Expr :: Num a => TypedExpr a -> TypedExpr Double;
public log10Expr = functionExpr1 Log10Function;

modExpr :: TypedExpr Int -> TypedExpr Int -> TypedExpr Int;
public modExpr = functionExpr2 ModFunction;

piExpr :: TypedExpr Double;
public piExpr = functionExpr0 PiFunction;

powerExpr :: (Num a, Num b) => TypedExpr a -> TypedExpr b -> TypedExpr a;
public powerExpr = functionExpr2 PowerFunction;

radiansExpr :: Num a => TypedExpr a -> TypedExpr Double;
public radiansExpr = functionExpr1 RadiansFunction;

randExpr :: TypedExpr Int -> TypedExpr Double;
public randExpr = functionExpr1 RandFunction;

roundExpr :: TypedExpr Double -> TypedExpr Int -> TypedExpr Double;
public roundExpr = functionExpr2 RoundFunction;

signExpr :: Num a => TypedExpr a -> TypedExpr Int;
public signExpr = functionExpr1 SignFunction;

sinExpr :: TypedExpr Double -> TypedExpr Double;
public sinExpr = functionExpr1 SinFunction;

sqrtExpr :: Num a => TypedExpr a -> TypedExpr Double;
public sqrtExpr = functionExpr1 SqrtFunction;

tanExpr :: TypedExpr Double -> TypedExpr Double;
public tanExpr = functionExpr1 TanFunction;

/**
 * TODO: is this the correct signature?
 */
truncateExpr :: Num a => TypedExpr a -> TypedExpr Int;
public truncateExpr = functionExpr1 TruncateFunction;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Conversion functions

/**
 * Converts an integer value to a double value.
 * The assumption here is that the database will do an implicit conversion
 * between these 2 types, so no function will be applied in the generated SQL.
 * A function could be used here if necessary.
 */
intToDoubleExpr :: TypedExpr Int -> TypedExpr Double;
public intToDoubleExpr expr = toTypedExpr (toUntypedExpr expr);

/**
 * Converts a value to a string value.
 */
convertToStringExpr :: TypedExpr a -> TypedExpr String;
public convertToStringExpr = functionExpr1 ConvertToStringFunction;

/**
 * Converts a value to a int value.
 */
convertToIntExpr :: TypedExpr a -> TypedExpr Int;
public convertToIntExpr = functionExpr1 ConvertToIntFunction;

/**
 * Converts a value to a double value.
 */
convertToDoubleExpr :: TypedExpr a -> TypedExpr Double;
public convertToDoubleExpr = functionExpr1 ConvertToDoubleFunction;



//////////////////////////////////////////////////////////////////////////////////////////////////////
// String functions
asciiExpr :: TypedExpr String -> TypedExpr Int;
public asciiExpr = functionExpr1 AsciiFunction;

charExpr :: TypedExpr Int -> TypedExpr String;
public charExpr = functionExpr1 CharFunction;

differenceExpr :: TypedExpr String -> TypedExpr String -> TypedExpr Int;
public differenceExpr = functionExpr2 DifferenceFunction;

insertExpr :: TypedExpr String -> TypedExpr Int -> TypedExpr Int -> TypedExpr String -> TypedExpr String;
public insertExpr stringExpr start length insertStr = functionExpr4 InsertFunction stringExpr start length insertStr;

lcaseExpr :: TypedExpr String -> TypedExpr String;
public lcaseExpr = functionExpr1 LcaseFunction;

leftExpr :: TypedExpr String -> TypedExpr Int -> TypedExpr String;
public leftExpr = functionExpr2 LeftFunction;

lengthExpr :: TypedExpr String -> TypedExpr Int;
public lengthExpr = functionExpr1 LengthFunction;

locateExpr :: TypedExpr String -> TypedExpr String -> TypedExpr Int;
public locateExpr searchExpr stringExpr = functionExpr2 LocateFunction searchExpr stringExpr;

locate2Expr :: TypedExpr String -> TypedExpr String -> TypedExpr Int -> TypedExpr Int;
public locate2Expr searchExpr stringExpr start = functionExpr3 LocateFunction searchExpr stringExpr start;

ltrimExpr :: TypedExpr String -> TypedExpr String;
public ltrimExpr = functionExpr1 LtrimFunction;

repeatExpr :: TypedExpr String -> TypedExpr Int -> TypedExpr String;
public repeatExpr stringExpr count = functionExpr2 RepeatFunction stringExpr count;

replaceExpr :: TypedExpr String -> TypedExpr String -> TypedExpr String -> TypedExpr String;
public replaceExpr stringExpr searchStr replacementStr = functionExpr3 ReplaceFunction stringExpr searchStr replacementStr;

rightExpr :: TypedExpr String -> TypedExpr Int -> TypedExpr String;
public rightExpr = functionExpr2 RightFunction;

rtrimExpr :: TypedExpr String -> TypedExpr String;
public rtrimExpr = functionExpr1 RtrimFunction;

soundexExpr :: TypedExpr String -> TypedExpr String;
public soundexExpr = functionExpr1 SoundexFunction;

spaceExpr :: TypedExpr Int -> TypedExpr String;
public spaceExpr nSpaces = functionExpr1 SpaceFunction nSpaces;

substringExpr :: TypedExpr String -> TypedExpr Int -> TypedExpr Int -> TypedExpr String;
public substringExpr stringExpr start length = functionExpr3 SubstringFunction stringExpr start length;

ucaseExpr :: TypedExpr String -> TypedExpr String;
public ucaseExpr = functionExpr1 UcaseFunction;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Misc functions

databaseExpr :: TypedExpr String;
public databaseExpr = functionExpr0 DatabaseFunction;

ifNullExpr :: TypedExpr a -> TypedExpr a -> TypedExpr a;
public ifNullExpr = functionExpr2 IfNullFunction;

nullIfExpr :: TypedExpr a -> TypedExpr a -> TypedExpr a;
public nullIfExpr = functionExpr2 NullIfFunction;

userExpr :: TypedExpr String;
public userExpr = functionExpr0 UserFunction;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Date/Time functions

dayNameExpr :: TypedExpr Time -> TypedExpr String;
public dayNameExpr = functionExpr1 DayNameFunction;

dayOfWeekExpr :: TypedExpr Time -> TypedExpr Int;
public dayOfWeekExpr = functionExpr1 DayOfWeekFunction;

dayOfMonthExpr :: TypedExpr Time -> TypedExpr Int;
public dayOfMonthExpr = functionExpr1 DayOfMonthFunction;

dayOfYearExpr :: TypedExpr Time -> TypedExpr Int;
public dayOfYearExpr = functionExpr1 DayOfYearFunction;

hourExpr :: TypedExpr Time -> TypedExpr Int;
public hourExpr = functionExpr1 HourFunction;

minuteExpr :: TypedExpr Time -> TypedExpr Int;
public minuteExpr = functionExpr1 MinuteFunction;

monthExpr :: TypedExpr Time -> TypedExpr Int;
public monthExpr = functionExpr1 MonthFunction;

monthNameExpr :: TypedExpr Time -> TypedExpr String;
public monthNameExpr = functionExpr1 MonthNameFunction;

nowExpr :: TypedExpr Time;
public nowExpr = functionExpr0 NowFunction;

quarterExpr :: TypedExpr Time -> TypedExpr Int;
public quarterExpr = functionExpr1 QuarterFunction;

secondExpr :: TypedExpr Time -> TypedExpr Int;
public secondExpr = functionExpr1 SecondFunction;

// TODO: create helper functions for TimestampAddFunction and
// TimestampDiffFunction...

weekExpr :: TypedExpr Time -> TypedExpr Int;
public weekExpr = functionExpr1 WeekFunction;

yearExpr :: TypedExpr Time -> TypedExpr Int;
public yearExpr = functionExpr1 YearFunction;

dateTimeAddExpr :: TimeInterval -> TypedExpr Int -> TypedExpr Time -> TypedExpr Time;
public dateTimeAddExpr timeInterval =  functionExpr2 (DateTimeAddFunction timeInterval);

dateTimeDiffExpr :: TimeInterval -> TypedExpr Time -> TypedExpr Time -> TypedExpr Int;
public dateTimeDiffExpr timeInterval = functionExpr2 (DateTimeDiffFunction timeInterval);


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Aggregate functions

untypedAggregationExpr :: DbFunction -> Expr -> Expr;
public untypedAggregationExpr aggrOp baseExpr = 
    if (isAggregationFunction aggrOp) then FunctionExpr aggrOp [baseExpr]
    else error "The specified function is not an aggregation function.";

countExpr :: TypedExpr a -> TypedExpr Int;
public countExpr = functionExpr1 AggrCount;

sumExpr :: Num a => TypedExpr a -> TypedExpr a;
public sumExpr = functionExpr1 AggrSum;

avgExpr :: Num a => TypedExpr a -> TypedExpr Double;
public avgExpr = functionExpr1 AggrAvg;

minExpr :: Ord a => TypedExpr a -> TypedExpr a;
public minExpr = functionExpr1 AggrMin;

maxExpr :: Ord a => TypedExpr a -> TypedExpr a;
public maxExpr = functionExpr1 AggrMax;

distinctCountExpr :: TypedExpr a -> TypedExpr Int;
public distinctCountExpr = functionExpr1 AggrDistinctCount;

distinctSumExpr :: Num a => TypedExpr a -> TypedExpr a;
public distinctSumExpr = functionExpr1 AggrDistinctSum;

distinctAvgExpr :: Num a => TypedExpr a -> TypedExpr Double;
public distinctAvgExpr = functionExpr1 AggrDistinctAvg;

countAllExpr :: TypedExpr Double;
public countAllExpr = functionExpr0 AggrCountAll;

stdDevExpr :: Num a => TypedExpr a -> TypedExpr Double;
public stdDevExpr = functionExpr1 AggrStdDev;

stdDevPExpr :: Num a => TypedExpr a -> TypedExpr Double;
public stdDevPExpr = functionExpr1 AggrStdDevP;

varianceExpr :: Num a => TypedExpr a -> TypedExpr Double;
public varianceExpr = functionExpr1 AggrVar;

variancePExpr :: Num a => TypedExpr a -> TypedExpr Double;
public variancePExpr = functionExpr1 AggrVarP;


/**
 * A database SELECT query.
 */
data public Query =
    private Query 
        options          :: [QueryOption]                 
        columns          :: [(Expr, String)]              
        restriction      :: (Maybe (TypedExpr Boolean))   
        orderings        :: [(Expr, Boolean)]             
        joins            :: [JoinNode]                    
        groups           :: [Expr]                        
        groupRestriction :: (Maybe (TypedExpr Boolean)) | 
    private Union 
        query1           :: Query     
        query2           :: Query
        unionAll         :: Boolean   
    deriving Eq, Show;

/**
 * Creates a new, empty query.
 */
newQuery :: Query;
public newQuery = Query [] [] Nothing [] [] [] Nothing;

/**
 * Combines the 2 queries into a Union query.
 */
unionQuery :: Query -> Query -> Boolean -> Query;
public unionQuery query1 query2 unionAll = 
    let
        query1Cols = getProjectedColumns query1;
        query2Cols = getProjectedColumns query2;

        // Remove any ordering from the first query.
        updatedQuery1 = removeOrdering query1;
    in
        // Check that the queries have the same number of columns.
        if (length query1Cols == length query2Cols) then Union updatedQuery1 query2 unionAll
        else error "Both queries in a Union must have the same number of columns";

/**
 * Produces a query which returns the intersection of the two specified queries.
 * The final result columns will be based on the first query.
 * The intersection will be performed on the corresponding columns in each
 * query.
 * It is ok for the queries to have different numbers of columns.
 */
intersectionQuery :: Query -> Query -> Query;
public intersectionQuery query1 query2 = 
    let
        origAliases = map snd (projectedColumnsWithAliases query1);

        // Set a known alias for the colums.
        itemColumnAliases = map (\i -> "COL_VALUE" ++ (intToString i)) (upFrom 1);

        // Wrap these subqueries in tables.
        subQueryTable1 = makeSubQueryTable (setColumnAliases query1 itemColumnAliases) "Q1";
        subQueryTable2 = makeSubQueryTable (setColumnAliases query2 itemColumnAliases) "Q2";

        nJoinColumns = length (zip (getProjectedColumns query1) (getProjectedColumns query2));
        joinInfos = map (\alias -> makeJoinInfo (stringField subQueryTable1 alias) (stringField subQueryTable2 alias) InnerJoin) (take nJoinColumns itemColumnAliases);

        resultCols = zip (map (untypedField subQueryTable1) itemColumnAliases) origAliases;
    in
        join2 (projectWithAliases newQuery resultCols) joinInfos;


/**
 * Produces a query which returns the intersection of the two specified queries.
 * The final result columns will be based on the first query.
 * The intersection will be performed on the specified expressions.
 */
intersectionQuery2 :: Query -> Query -> [(Expr, Expr)] -> Query;
public intersectionQuery2 query1 query2 compareExprs = 
    let
        origAliases = map snd (projectedColumnsWithAliases query1);

        compareExprs1 = if (isEmpty compareExprs) then getProjectedColumns query1
                        else map fst compareExprs;
        compareExprs2 = if (isEmpty compareExprs) then getProjectedColumns query2
                        else map snd compareExprs;

        // Ensure that all the comparison expressions are projected from both
        // queries.
        queryAllColumns1 = projectColumnsIfNecessary query1 compareExprs1;
        queryAllColumns2 = projectColumnsIfNecessary query2 compareExprs2;

        // Set a known alias for the colums.
        itemColumnAliases = map defaultColumnAlias (upFrom 0);

        // Wrap these subqueries in tables.
        subQueryTable1 = makeSubQueryTable (setColumnAliases queryAllColumns1 itemColumnAliases) "Q1";
        subQueryTable2 = makeSubQueryTable (setColumnAliases queryAllColumns2 itemColumnAliases) "Q2";

        // Find the join expression for each of the comparison expressions.
        lookupJoinExpr origQuery subQueryTable origExpr = 
            let
                indexInOrigQuery = fromJust (elemIndex origExpr (getProjectedColumns origQuery));
                alias = defaultColumnAlias indexInOrigQuery;
            in
                stringField subQueryTable alias;

        joinExprs1 = map (lookupJoinExpr queryAllColumns1 subQueryTable1) compareExprs1;
        joinExprs2 = map (lookupJoinExpr queryAllColumns2 subQueryTable2) compareExprs2;

        joinInfos = zipWith (\e1 e2 -> makeJoinInfo e1 e2 InnerJoin) joinExprs1 joinExprs2;

        resultCols = zip (map (untypedField subQueryTable1) itemColumnAliases) origAliases;
    in
        join2 (projectWithAliases newQuery resultCols) joinInfos;

/**
 * This is an alternate version of {@link intersectionQuery@}.
 * Instead of creating 2 subqueries and linking them, this function creates a
 * subquery for the second query
 * and links it directly to the first query (although special handling is needed
 * if the first query is uses {@link TopN@}).
 * This should give the same results as {@code intersectionQuery@}.
 * 
 * TODO: check which option is most efficient and get rid of the other one.
 */
alternateIntersectionQuery :: Query -> Query -> Query;
public alternateIntersectionQuery query1 query2 = 
    let
        origAliases = map snd (projectedColumnsWithAliases query1);

        // Set a known alias for the colums.
        itemColumnAliases = map defaultColumnAlias (upFrom 0);

        nJoinColumns = length (zip (getProjectedColumns query1) (getProjectedColumns query2));

        needToWrapQuery query = isTopNQuery query;
        wrapQueryIfNeeded query = if (needToWrapQuery query) then wrapQuery query else query;

        updatedQuery1 = wrapQueryIfNeeded query1;

        subQueryTable2 = makeSubQueryTable (setColumnAliases query2 itemColumnAliases) "";

        joinInfos = zipWith (\query1Col alias -> makeJoinInfo (toTypedExpr query1Col) (stringField subQueryTable2 alias) InnerJoin) (getProjectedColumns updatedQuery1) (take nJoinColumns itemColumnAliases);
    in
        setColumnAliases (join2 updatedQuery1 joinInfos) origAliases;


/**
 * Produces a query which returns the difference of the two specified queries.
 * The final result columns will be based on the first query.
 * The difference will be performed on the corresponding columns in each query.
 * It is ok for the queries to have different numbers of columns.
 */
differenceQuery :: Query -> Query -> Query;
public differenceQuery query1 query2 = 
    differenceQuery2 query1 query2 (zip (getProjectedColumns query1) (getProjectedColumns query2));


/**
 * Produces a query which returns the difference of the two specified queries.
 * The final result columns will be based on the first query.
 * The difference will be performed on the specified expressions.
 */
differenceQuery2 :: Query -> Query -> [(Expr, Expr)] -> Query;
public differenceQuery2 query1 query2 compareExprs = 
    let
        origAliases = map snd (projectedColumnsWithAliases query1);

        compareExprs1 = if (isEmpty compareExprs) then getProjectedColumns query1
                        else map fst compareExprs;
        compareExprs2 = if (isEmpty compareExprs) then getProjectedColumns query2
                        else map snd compareExprs;

        // Ensure that all the comparison expressions are projected from both
        // queries.
        queryAllColumns1 = projectColumnsIfNecessary query1 compareExprs1;
        queryAllColumns2 = projectColumnsIfNecessary query2 compareExprs2;

        // Take the first query, and add a restriction of the following form:
        //     NOT EXISTS (SELECT ... WHERE qry2Field1 <> qry1Field1 AND qry2Field2
        // <> qry1Field2 AND ....
        needToWrapQuery query = isTopNQuery query;
        wrapQueryIfNeeded query = if (needToWrapQuery query) then wrapQuery query else query;

        updatedQuery1 = wrapQueryIfNeeded queryAllColumns1;
        updatedQuery2 = wrapQueryIfNeeded queryAllColumns2;

        // Find the updated expression for each of the comparison expressions.
        lookupUpdatedExpr origQuery updatedQuery origExpr = 
            let
                lookupMap = zip (getProjectedColumns origQuery) (getProjectedColumns updatedQuery);
            in
                fromJust (List.lookup origExpr lookupMap);

        updatedCompareExprs1 = map (lookupUpdatedExpr queryAllColumns1 updatedQuery1) compareExprs1;
        updatedCompareExprs2 = map (lookupUpdatedExpr queryAllColumns2 updatedQuery2) compareExprs2;

        exclusionRestrictions = zipWith (\q2Col q1Col -> toTypedExpr (untypedBinaryExpr OpEq q2Col q1Col)) updatedCompareExprs2 updatedCompareExprs1;

        exclusionExpr = notExpr (existsExpr (toTypedExpr (subQueryExpr (restrict2 updatedQuery2 exclusionRestrictions))));

        restrictedQuery = restrict updatedQuery1 exclusionExpr;
        allResultExpr = getProjectedColumns restrictedQuery;
    in
        // Set the correct aliases and truncate the projected columns to match
        // the original list.
        projectWithAliases (removeProjectedColumns restrictedQuery) (zip allResultExpr origAliases);


/**
 * Returns a default column alias.
 * The column index is the zero-based index of the expression in the query's
 * projected columns.
 */
defaultColumnAlias :: Int -> String;
private defaultColumnAlias colIndex = "COL_VALUE" ++ (intToString (colIndex + 1));


/**
 * Adds the specified expression to the projected columns, if it isn't already
 * projected.
 */
projectColumnIfNecessary :: Query -> Expr -> Query;
private projectColumnIfNecessary !query !expr = 
    if (isElem expr (getProjectedColumns query)) then query
    else project query [expr];

/**
 * Adds the specified expressions to the projected columns, if they aren't
 * already projected.
 */
projectColumnsIfNecessary :: Query -> [Expr] -> Query;
private projectColumnsIfNecessary query exprs = foldLeftStrict projectColumnIfNecessary query exprs;


/**
 * Wraps the query in an outer query which projects the same columns as the
 * original.
 * The ordering from the original query is also preserved.
 */
wrapQuery :: Query -> Query;
public wrapQuery query = fst (wrapQuery2 query []);

/**
 * Wraps the query in an outer query which projects the same columns as the
 * original.
 * The ordering from the original query is also preserved.
 * The wrapped query will be returned along with wrapped versions of the
 * specified additional expressions.
 */
wrapQuery2 :: Query -> [Expr] -> (Query, [Expr]);
public wrapQuery2 query additionalExprs = 
    let
        origAliases = projectedColumnAliases query ++ repeat "";
        originalOrdering = orderingExpressions query;

        origProjectedExprs = getProjectedColumns query;
        origOrderingExprs = map fst originalOrdering;

        additionalProjectedExprs = deleteFirsts (removeDuplicates (origOrderingExprs ++ additionalExprs)) origProjectedExprs;

        itemColumnAliases = map defaultColumnAlias (upFrom 0);
        subQueryTable = makeSubQueryTable (setColumnAliases (project query additionalProjectedExprs) itemColumnAliases) "";

        allSubqueryProjectedExprs = origProjectedExprs ++ additionalProjectedExprs;
        wrappedQueryExprs = map (untypedField subQueryTable) itemColumnAliases;

        wrappedQueryProjectedExprs = take (length origProjectedExprs) wrappedQueryExprs;

        exprMap = zip allSubqueryProjectedExprs wrappedQueryExprs;
        lookupNewExpr origExpr = lookupWithDefault origExpr exprMap (error "Failed to find expression in wrapped query");

        // Preverse the ordering from the original query.
        newOrdering = map (\pr -> (lookupNewExpr (fst pr), snd pr)) originalOrdering;

        wrappedQuery = order2 (projectWithAliases newQuery (zip wrappedQueryProjectedExprs origAliases)) newOrdering;

        wrappedAdditionalExprs = map lookupNewExpr additionalExprs;
    in
        (wrappedQuery, wrappedAdditionalExprs);
   

/**
 * Returns a query field for the specified table.
 */
untypedField :: QueryTable -> String -> Expr;
public untypedField table fieldName = QueryField fieldName table;

stringField :: QueryTable -> String -> TypedExpr String;
public stringField table fieldName = TypedExpr (QueryField fieldName table);

booleanField :: QueryTable -> String -> TypedExpr Boolean;
public booleanField table fieldName = TypedExpr (QueryField fieldName table);

doubleField :: QueryTable -> String -> TypedExpr Double;
public doubleField table fieldName = TypedExpr (QueryField fieldName table);

intField :: QueryTable -> String -> TypedExpr Int;
public intField table fieldName = TypedExpr (QueryField fieldName table);

timeField :: QueryTable -> String -> TypedExpr Time;
public timeField table fieldName = TypedExpr (QueryField fieldName table);

binaryField :: QueryTable -> String -> TypedExpr (Array Byte);
public binaryField table fieldName = TypedExpr (QueryField fieldName table);


/**
 * Returns the query options.
 * For {@link Union@} queries, this will return the options for the first query.
 */
queryOptions :: Query -> [QueryOption];
public queryOptions query = 
    case query of
    Query {options} -> options;
    Union {query1}  -> queryOptions query1;
    ;

/**
 * Adds an option to the query.
 */
addOption :: Query -> QueryOption -> Query;
public addOption !query !newOption = 
    case (removeOption query newOption) of
    Query options columns restriction orderings joins groups groupRestriction ->
        Query (options ++ [newOption]) columns restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Add the option to both queries.
        Union (addOption query1 newOption) (addOption query2 newOption) unionAll;
    ;

/**
 * Removes the option of the same type as the specified one (even if the exact
 * values don't match).
 */
removeOption :: Query -> QueryOption -> Query;
public removeOption query optionTypeToRemove = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            remainingOptions = filter (\o -> not (isSameOptionType optionTypeToRemove o)) options;
        in
            Query remainingOptions columns restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Remove the option from both queries.
        Union (removeOption query1 optionTypeToRemove) (removeOption query2 optionTypeToRemove) unionAll;
    ;

/**
 * Returns whether the specified options are of the same type (not necessarily
 * the same value).
 */
isSameOptionType :: QueryOption -> QueryOption -> Boolean;
isSameOptionType !option1 !option2 = 
    case option1 of
    Distinct -> 
        case option2 of
        Distinct -> True;
        _ -> False;
        ;
    TopN {} -> 
        case option2 of
        TopN {} -> True;
        _ -> False;
        ;
    ;

/**
 * Returns whether a {@link TopN@} option is specified for the query.
 */
isTopNQuery :: Query -> Boolean;
private isTopNQuery !query =
    case query of
    Query {options} -> any isTopNOption options; 

    // Check whether either query is a topN query.
    Union {query1, query2} -> isTopNQuery query1 || isTopNQuery query2;
    ;


/**
 * Adds the specified expression as a result column in the query.
 */
projectColumn :: Query -> TypedExpr a -> Query;
public projectColumn query newColumn = 
    project query [toUntypedExpr newColumn];

/**
 * Adds the specified expression as a result column in the query.
 */
projectColumnWithAlias :: Query -> TypedExpr a -> String -> Query;
public projectColumnWithAlias query newColumn columnAlias = 
    projectWithAliases query [(toUntypedExpr newColumn, columnAlias)];

/**
 * Adds the specified expressions as result columns in the query.
 */
project :: Query -> [Expr] -> Query;
public project query newColumns = 
    let
        newColumnsAndAliases = zip newColumns (repeat "");
    in
        projectWithAliases query newColumnsAndAliases;

/**
 * Adds the specified expressions as result columns with the corresponding
 * aliases in the query.
 * 
 * TODO: don't add the same field multiple times...
 */
projectWithAliases :: Query -> [(Expr, String)] -> Query;
public projectWithAliases query newColumns = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        Query options (columns ++ newColumns) restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Product the column in both queries.
        Union (projectWithAliases query1 newColumns) (projectWithAliases query2 newColumns) unionAll;
    ;

/**
 * Returns the projected columns for the query.
 * For a {@link Union@} query, this will return only the projected columns for the first
 * query.
 * 
 * TODO: rename this to projectedColumns...
 */
getProjectedColumns :: Query -> [Expr];
public getProjectedColumns query = 
    case query of
    Query {columns} -> map fst columns;
    Union {query1}  -> getProjectedColumns query1;
    ;

/**
 * Returns the projected columns for the query.
 * For a {@link Union@} query, this will return only the projected columns for the first
 * query.
 */
projectedColumnsWithAliases :: Query -> [(Expr, String)];
public projectedColumnsWithAliases query = 
    case query of
    Query {columns} -> columns;
    Union {query1}  -> projectedColumnsWithAliases query1;
    ;

/**
 * Returns the aliases for the query's projected columns.
 */
projectedColumnAliases :: Query -> [String];
public projectedColumnAliases query = map snd (projectedColumnsWithAliases query);

/**
 * Removes all projected columns from the query.
 */
removeProjectedColumns :: Query -> Query;
public removeProjectedColumns query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        Query options [] restriction orderings joins groups groupRestriction;
    Union query1 query2 unionAll -> 
        // Remove the projected columns from both queries.
        Union (removeProjectedColumns query1) (removeProjectedColumns query2) unionAll;
    ;

/**
 * Removes the specified expression from the projected columns list.
 * For {@link Union@} queries, the specified expression will be removed from the both
 * queries along with the
 * corresponding columns in the other query.
 */
removeProjectedColumn :: Query -> Expr -> Query;
public removeProjectedColumn query exprToRemove = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        Query options (filter (\c -> (fst c) != exprToRemove) columns) restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        let
            exprIndicesInQuery qry = 
                case qry of
                Query {columns}        -> List.findIndices (\c -> fst c == exprToRemove) columns;
                Union {query1, query2} -> removeDuplicates (exprIndicesInQuery query1 ++ exprIndicesInQuery query2);
                ;

            // Determine the combined set of indices to be removed.
            indicesToRemove = exprIndicesInQuery query;

            // Remove the appropriate columns from a query.
            removeExprs qry =
                case qry of
                Query options columns restriction orderings joins groups groupRestriction ->
                    let
                        newColumns = map snd (filter (\pr -> not (isElem (fst pr) indicesToRemove)) (zip (upFrom 0) columns));
                    in
                        Query options newColumns restriction orderings joins groups groupRestriction;
                Union query1 query2 unionAll -> 
                    Union (removeExprs query1) (removeExprs query2) unionAll;
                ;
        in
            removeExprs query;
    ;

/**
 * Sets the aliases for the first N projected columns.
 * Any other existing aliases will be left untouched.
 */
setColumnAliases :: Query -> [String] -> Query;
public setColumnAliases query newAliases = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        let
            oldAliases = map snd columns;
            projectedExprs = map fst columns;

            finalAliases = newAliases ++ (drop (length newAliases) oldAliases);
            newColumns = zip projectedExprs finalAliases;
        in
            Query options newColumns restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Set the column aliases in both queries.
        Union (setColumnAliases query1 newAliases) (setColumnAliases query2 newAliases) unionAll;
    ;


/**
 * Adds a restriction on the rows returned by the query.
 */
restrict :: Query -> TypedExpr Boolean -> Query;
public restrict !query !newRestriction = 
    let
        // Returns a list of expressions which are ANDed together, if any.
        getAndedExprs :: TypedExpr Boolean -> [TypedExpr Boolean];
        getAndedExprs expr = 
            case (toUntypedExpr) expr of
            FunctionExpr {func, arguments} -> 
                case func of
                OpAnd -> concatMap (Prelude.compose getAndedExprs toTypedExpr) arguments;
                _ -> [expr];
                ;
            _ -> [expr];
            ;


        restrictHelper :: Query -> TypedExpr Boolean -> Query;
        restrictHelper !query !newRestriction = 
            case query of
            Query options columns restriction orderings joins groups groupRestriction -> 
                let
                    mergedRestriction = 
                        case restriction of
                        Nothing -> newRestriction;
                        Just restrictionValue -> andExpr restrictionValue newRestriction;
                        ;

                    mergedGroupRestriction = 
                        case groupRestriction of
                        Nothing -> newRestriction;
                        Just groupRestrictionValue -> andExpr groupRestrictionValue newRestriction;
                        ;
                in
                    // Don't change anything if the new criteria is simply
                    // 'True'.
                    if (newRestriction == trueConstant) then
                        query
                    else if (isGroupRestriction newRestriction) then
                        Query options columns restriction orderings joins groups (Just mergedGroupRestriction)
                    else
                        Query options columns (Just mergedRestriction) orderings joins groups groupRestriction;

            Union query1 query2 unionAll -> 
                // Restrict both queries.
                Union (restrict query1 newRestriction) (restrict query2 newRestriction) unionAll;
            ;
        in
            // Split up the restriction into separate ANDed expressions and apply
            // each individually.
            // This is needed in cases where the restriction expression contains
            // some record restrictions
            // and some group restrictions.
            foldLeftStrict restrictHelper query (getAndedExprs newRestriction);


/**
 * Adds the specified restrictions on the rows returned by the query.
 */
restrict2 :: Query -> [TypedExpr Boolean] -> Query;
public restrict2 query newRestrictions = 
    foldLeftStrict restrict query newRestrictions;

/**
 * Returns whether the restriction expression applies to groups or record
 * values.
 */
isGroupRestriction :: TypedExpr Boolean -> Boolean;
private isGroupRestriction restriction = exprUsesAggregation (toUntypedExpr restriction);

/**
 * Returns whether the expression uses aggregate functions.
 * 
 * TODO: is there anything else to look for?
 */
exprUsesAggregation :: Expr -> Boolean;
public exprUsesAggregation expr =
    case expr of
   (QueryField |
    ConstExpr |
    SubQueryExpr) {} -> False;
    ListExpr {listValues} -> any exprUsesAggregation listValues;
    FunctionExpr {func, arguments} -> isAggregationFunction func || (any exprUsesAggregation arguments);
    ;


/**
 * Returns the restriction expressions (including group restrictions) for the
 * query.
 * For a {@link Union@} query, this only returns the restrictions for the first query.
 */
restrictionExpressions :: Query -> [TypedExpr Boolean];
public restrictionExpressions query = 
    case query of
    Query {restriction, groupRestriction} -> 
        (Prelude.maybeToList restriction) ++ (Prelude.maybeToList groupRestriction);

    Union {query1} -> 
        restrictionExpressions query1;
    ;


/**
 * Adds sorting on the specified expression.
 */
order :: Ord a => Query -> TypedExpr a -> Boolean -> Query;
public order query sortExpr sortAscending = order2 query [(toUntypedExpr sortExpr, sortAscending)];

/**
 * Adds sorting on the specified fields.
 */
order2 :: Query -> [(Expr, Boolean)] -> Query;
public order2 query newOrderings = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        Query options columns restriction (orderings ++ newOrderings) joins groups groupRestriction;
    Union query1 query2 unionAll -> 
        // Add ordering to only the 2nd query.
        Union query1 (order2 query2 newOrderings) unionAll;
    ;

/**
 * Returns the ordering info for the query.
 */
orderingExpressions :: Query -> [(Expr, Boolean)];
public orderingExpressions query = 
    case query of
    Query {orderings} ->  orderings;
    Union {query2} -> orderingExpressions query2;
    ;

/**
 * Removes all ordering from the query.
 */
removeOrdering :: Query -> Query;
public removeOrdering query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        Query options columns restriction [] joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Remove ordering from both queries (even though the first one
        // shouldn't have any ordering to begin with).
        Union (removeOrdering query1) (removeOrdering query2) unionAll;
    ;


/**
 * Projects the specified expressions from the query, and group and order (ASC) on the expressions.
 */
projectGroupAndOrder :: Query -> [Expr] -> Query;
public projectGroupAndOrder !query !exprs = 
    order2 (group2 (project query exprs) exprs) (zip exprs $ repeat True);


/**
 * Adds a join between 2 tables.
 */
join :: Query -> JoinInfo -> Query;
public join !query newJoinInfo = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        let
            newJoinNodes = applyJoinInfo joins newJoinInfo;
        in
            Query options columns restriction orderings newJoinNodes groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Add the join to both queries.
        Union (join query1 newJoinInfo) (join query2 newJoinInfo) unionAll;
    ;

/**
 * Adds the specified joins to the query.
 */
join2 :: Query -> [JoinInfo] -> Query;
public join2 query newJoins = 
    foldLeft join query newJoins;

/**
 * Adds the specified join nodes to the query.
 */
addJoins :: Query -> [JoinNode] -> Query;
public addJoins query newJoins = 
    setJoins query (joins query ++ newJoins);

/**
 * Sets the join information for the query as a list of join node trees.
 * This will replace any existing join info.
 */
setJoins :: Query -> [JoinNode] -> Query;
public setJoins query newJoins = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        Query options columns restriction orderings (cleanupJoinNodes newJoins) groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Set the joins in both queries.
        Union (setJoins query1 newJoins) (setJoins query2 newJoins) unionAll;
    ;

/**
 * Returns the join information from the query.
 * For a {@link Union@} query, the joins from the first query will be returned.
 */
joins :: Query -> [JoinNode];
public joins query = 
    case query of
    Query {joins} -> joins;
    Union {query1} -> joins query1;
    ;

/**
 * Constructs a single join tree based on the list of join info items.
 * This will throw an error if a single set of joins cannot be produced from the
 * join info items
 * (which would likely mean that there are tables or groups of tables which are
 * not linked in some way).
 */
buildJoinTree :: [JoinInfo] -> JoinNode;
public buildJoinTree joinInfo = 
    let
        joinTrees = foldLeftStrict applyJoinInfo [] joinInfo;
    in
        if (isEmpty joinInfo) then
            error "No join info items were specified"
        else if (isSingletonList joinTrees) then
            head joinTrees
        else
            error "The join info items could not be combined into a single join tree";

/**
 * Apply a single join info item to the list of join nodes.
 * Returns the new list of top-level join nodes.
 */
applyJoinInfo :: [JoinNode] -> JoinInfo -> [JoinNode];
private applyJoinInfo !oldNodes !joinInfo = 
    case joinInfo of
    JoinInfo {leftTable, rightTable, fieldJoinExprs, joinType} ->
        let
            // Returns whether the join node subtree contains a node for the
            // specified table.
            joinSubtreeIncludesTable :: QueryTable -> JoinNode -> Boolean;
            joinSubtreeIncludesTable table node = 
                case node of
                JoinTable {table=joinTable} -> table == joinTable;
                JoinSubtree {leftNode, rightNode} ->
                    (joinSubtreeIncludesTable table leftNode) || (joinSubtreeIncludesTable table rightNode);
                ;

            // Determine which join trees contain the left and right tables.
            // The first item, if any, in each list will be the join tree
            // containing the appropriate table.
            leftResults  = snd (List.break (joinSubtreeIncludesTable leftTable) oldNodes);
            rightResults = snd (List.break (joinSubtreeIncludesTable rightTable) oldNodes);

            leftTableTree  = 
                case leftResults of
                [] -> JoinTable leftTable;
                leftResultsHead : _ -> leftResultsHead;
                ;

            rightTableTree = 
                case rightResults of
                [] -> JoinTable rightTable;
                rightResultsHead : _ -> rightResultsHead;
                ;

            // Check whether both tables are already used in the same join node
            // tree.
            tablesFromSameTree = (length leftResults == length rightResults) && not (isEmpty leftResults);

            // Combine the individual field join expressions into a single
            // linking expressions.
            linkingExpr :: TypedExpr Boolean;
            linkingExpr = 
                case fieldJoinExprs of
                [] -> error "No field join expressions were specified for a join.";
                _ -> List.foldRight1 andExpr fieldJoinExprs;    // TODO: is this correct?
                ;

            // Construct a new join node tree which includes the join between
            // the left and right tables.
            newNode = if (tablesFromSameTree) then 
                          addLinkExprInSubtree leftTableTree
                      else 
                          JoinSubtree leftTableTree rightTableTree linkingExpr joinType;

            // If the left and right tables already belong to the same join
            // tree, then the linking criteria
            // will need to be added to an existing join node in this tree.
            // This will be added to the first node (closest to the table nodes)
            // that has both tables in its subtree.
            addLinkExprInSubtree :: JoinNode -> JoinNode;
            addLinkExprInSubtree node = 
                case node of
                JoinTable {} -> node;
                JoinSubtree {leftNode, rightNode, linkingExpr=oldLinkingExpr, joinType} -> 
                    let
                        // TODO: perhaps the join types should be compared (and
                        // an error raised if they are not compatible).
                        //       It would also be important to check whether the join
                        // is reversed in this case.

                        // This will return whether this is the first node which
                        // has the 2 tables in common.
                        isCommonNodeForTables :: Boolean;
                        isCommonNodeForTables = 
                            case node of
                            JoinTable {} -> False;
                            JoinSubtree {leftNode, rightNode} -> 
                                (joinSubtreeIncludesTable leftTable leftNode) && (joinSubtreeIncludesTable rightTable rightNode)
                                || (joinSubtreeIncludesTable rightTable leftNode) && (joinSubtreeIncludesTable leftTable rightNode);
                            ;

                        combinedLinkingExpr = andExpr oldLinkingExpr linkingExpr;
                    in
                        if (isCommonNodeForTables) then JoinSubtree leftNode rightNode combinedLinkingExpr joinType
                        else JoinSubtree (addLinkExprInSubtree leftNode) (addLinkExprInSubtree rightNode) linkingExpr joinType;
                ;

            // Remove the appropriate node(s) from the old list of join trees.
            nodesToPreserve = filter (\node -> not (joinSubtreeIncludesTable leftTable node || joinSubtreeIncludesTable rightTable node)) oldNodes;

            newNodes = cleanupJoinNodes (newNode : nodesToPreserve);
        in
// TODO: remove this debugging code later...
//Debug.trace ("applyJoinInfo: " ++ (show leftTable) ++ " to " ++ (show
// rightTable) ++ "\n result = " ++ (showJoinNodes newNodes) ++ "\n\n")
// newNodes;
            newNodes;
    ;

/**
 * Connects up any separate join trees with common tables.
 * Also, clean up any unlinked tables which also are included in a join.
 */
cleanupJoinNodes :: [JoinNode] -> [JoinNode];
private cleanupJoinNodes joinNodes = 
    let
        allJoinTables :: [QueryTable];
        allJoinTables = concatMap getJoinTreeTables joinNodes;

        tablesWithSpecifiedAlias :: [QueryTable];
        tablesWithSpecifiedAlias = 
            filter (\t -> 
                       case t of
                       BaseTable {tableRef, tableAlias} -> getTableNameFromReference tableRef != tableAlias;
                       _ -> False;
                   )
                   allJoinTables;

        fixTableName table = fromMaybe table (find (equals table) tablesWithSpecifiedAlias);

        fixJoinTableNames join = 
            case join of
            JoinTable table ->
                JoinTable (fixTableName table);
            JoinSubtree leftNode rightNode linkingExpr joinType -> 
                JoinSubtree (fixJoinTableNames leftNode) (fixJoinTableNames rightNode) linkingExpr joinType;
            ;

        joinNodesWithFixedTableNames :: [JoinNode];
        joinNodesWithFixedTableNames = map fixJoinTableNames joinNodes;

        // Removed any unjoined tables which are included in a join.
        cleanupUnjoinedTables :: [JoinNode] -> [JoinNode];
        cleanupUnjoinedTables joinNodes = 
            let
                isUnlinkedTable node = 
                    case node of
                    JoinTable {} -> True;
                    _ -> False;
                    ;

                getUnlinkedTable node = node.JoinTable.table;

                isTableUsedInJoin table = 
                    let
                        joinSubtreeNodes = filter (compose not isUnlinkedTable) joinNodes;
                        tablesUsedInJoins = removeDuplicates (concatMap getJoinTreeTables joinSubtreeNodes);
                    in
                        isElem table tablesUsedInJoins;
            in
                filter (\n -> not (isUnlinkedTable n && isTableUsedInJoin (getUnlinkedTable n))) joinNodes;

        // Combine join trees with tables in common, where possible.
        consolidateJoinNodes :: [JoinNode] -> [JoinNode];
        consolidateJoinNodes nodes = 
            case nodes of
            [] -> [];
            n : ns -> 
                let
                    nTables  = getJoinTreeTables n;
                    nsTables = removeDuplicates (concatMap getJoinTreeTables ns);

                    tablesOverlap = not (isEmpty (intersect nTables nsTables));

                    // Attempt to break the first node into a list of JoinInfo
                    // items.
                    nodeJoinInfos :: [JoinInfo];
                    nodeJoinInfos = joinNodeToJoinInfo n;
                in
                    // If the first node has tables in common with one or more
                    // of the other nodes
                    // then attempt to break it into JoinInfo items and apply
                    // them to the remaining nodes.
                    if (tablesOverlap && not (isEmpty nodeJoinInfos)) then foldLeftStrict applyJoinInfo ns nodeJoinInfos
                    else n : consolidateJoinNodes ns;
            ;
    in
        consolidateJoinNodes (cleanupUnjoinedTables joinNodesWithFixedTableNames);


/**
 * Attempts to break a {@link JoinNode@} into one or more {@link typeConstructor = JoinInfo@}s.
 * An empty list will be returned if the join node could not be represented
 * using {@code JoinInfo@}s.
 * 
 * TODO: instead of converting JoinNodes to JoinInfo, it would be better to
 * combine JoinNodes directly...
 */
joinNodeToJoinInfo :: JoinNode -> [JoinInfo];
private joinNodeToJoinInfo joinNode = 
    case joinNode of
    JoinSubtree {leftNode, rightNode, linkingExpr, joinType} -> 
        let
            leftTables  = getJoinTreeTables leftNode;
            rightTables = getJoinTreeTables rightNode;

            linkExprTables = getExpressionTables False (toUntypedExpr linkingExpr);

            leftTable  = if (isSingletonList leftTables) then listToMaybe leftTables 
                         else find (\t -> isElem t linkExprTables) leftTables;
            rightTable = if (isSingletonList rightTables) then listToMaybe rightTables 
                         else find (\t -> isElem t linkExprTables) rightTables;

            leftJoinInfos  = joinNodeToJoinInfo leftNode;
            rightJoinInfos = joinNodeToJoinInfo leftNode;

            joinInfos = 
                case leftTable of
                Nothing -> [];
                Just leftTableValue ->
                    case rightTable of
                    Nothing -> [];
                    Just rightTableValue ->
                        [makeJoinInfo2 leftTableValue rightTableValue linkingExpr joinType];
                    ;
                ;
        in
            leftJoinInfos ++ rightJoinInfos ++ joinInfos;

    _ -> [];
    ;


/**
 * Forces the specified table to be included in the query, even if no fields
 * from it are used in the rest of the query.
 */
addUnjoinedTable :: Query -> QueryTable -> Query;
public addUnjoinedTable query newUnjoinedTable = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        let
            // Only add the unjoined table if it doesn't already appear in the
            // join trees.
            joinTables = concatMap getJoinTreeTables joins;
            newJoins = if (isElem newUnjoinedTable joinTables) then joins
                       else joins ++ [JoinTable newUnjoinedTable];
        in
            Query options columns restriction orderings newJoins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Add the table to both queries.
        Union (addUnjoinedTable query1 newUnjoinedTable) (addUnjoinedTable query2 newUnjoinedTable) unionAll;
    ;

/**
 * Adds grouping to the query.
 */
groupUntyped :: Query -> Expr -> Query;
private groupUntyped !query newGroup = 
    group2 query [newGroup];

/**
 * Adds grouping to the query.
 */
group :: Ord a => Query -> TypedExpr a -> Query;
public group query newGroup = groupUntyped query (toUntypedExpr newGroup);

/**
 * Adds grouping on the specified fields.
 */
group2 :: Query -> [Expr] -> Query;
public group2 query groupFields = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        Query options columns restriction orderings joins (groups ++ groupFields) groupRestriction;

    Union query1 query2 unionAll -> 
        // Add grouping to both queries.
        Union (group2 query1 groupFields) (group2 query2 groupFields) unionAll;
    ;



/**
 * Returns a list of the tables used in the query.
 * This will only include fields used in subqueries if the option is specified.
 */
getQueryTables :: Boolean -> Query -> [QueryTable];
public getQueryTables includeSubqueryTables query = 
    case query of
    Query {columns, restriction, orderings, joins, groups, groupRestriction} ->
        let
            columnExprs = map fst columns;
            restrictionExprs = 
                case restriction of
                Nothing -> [];
                Just restrictionValue -> [toUntypedExpr restrictionValue];
                ;

            groupRestrictionExprs = 
                case groupRestriction of
                Nothing -> [];
                Just groupRestrictionValue -> [toUntypedExpr groupRestrictionValue];
                ;

            orderingExprs = map fst orderings;
            allExprs = columnExprs ++ restrictionExprs ++ orderingExprs ++ groups ++ groupRestrictionExprs;

            exprTables = concatMap (getExpressionTables includeSubqueryTables) allExprs;

            tableAndSubTables queryTable = 
                case queryTable of
               (BaseTable |
                OpaqueSubQueryTable) {} -> [queryTable];
                SubQueryTable {subquery} -> 
                    if (includeSubqueryTables) then queryTable : getQueryTables True subquery else [queryTable];
                ;
            joinTablesOnly = concatMap getJoinTreeTables joins;
            joinTablesAndSubTables = concatMap tableAndSubTables joinTablesOnly;
            joinTables = if (includeSubqueryTables) then joinTablesAndSubTables else joinTablesOnly;
        in
            removeDuplicates (exprTables ++ joinTables);

    Union {query1, query2} -> 
        removeDuplicates ((getQueryTables includeSubqueryTables query1) ++ (getQueryTables includeSubqueryTables query2));
    ;

/**
 * Returns all the tables used in the specified expression.
 */
getExpressionTables :: Boolean -> Expr -> [QueryTable];
public getExpressionTables includeSubqueryTables expr = 
    let
        expressionTablesHelper expr = 
            case expr of
            QueryField {fieldName, queryTable} -> 
                case queryTable of
               (BaseTable |
                OpaqueSubQueryTable) {} -> [queryTable];
                SubQueryTable {subquery} -> 
                    if includeSubqueryTables then queryTable : getQueryTables True subquery
                    else [queryTable];
                ;
            ConstExpr {} -> [];
            ListExpr  {listValues} -> concatMap expressionTablesHelper listValues;
            FunctionExpr {arguments} -> concatMap expressionTablesHelper arguments;
            SubQueryExpr {subquery} -> if (includeSubqueryTables) then getQueryTables True subquery else [];
            ;
    in
        removeDuplicates (expressionTablesHelper expr);


/**
 * Returns a list of columns that belong to the given table and that are
 * referenced from within the given query. Only references from joins
 * and QueryField expressions in the list of projected columns are returned.
 * 
 * NOTE: This method was written to support the UBO PoC, so it is not meant
 * to be generally useful.  See module AggregationInfo.
 * 
 * @arg query The query.
 * @arg targetTable The table we're searching for references to.
 * @return A list of expressions that represent the columns belonging to
 *         targetTable.
 */
getColumnsForTable :: Query -> QueryTable -> [Expr];
public getColumnsForTable query targetTable = 
    case query of
    Query {columns, joins} ->
        let
            // Search the list of columns for references to the given table.
            // Only look for QueryField references, not references contained in 
            // functions.
            columnExprs = map fst columns;

            exprFilter :: Expr -> Boolean;
            exprFilter expr = 
                case expr of
                QueryField {fieldName, queryTable} -> queryTable == targetTable; 
                _ -> False;
                ;
                
            filteredColumns = filter exprFilter columnExprs;
            
            // Search the list of joins for references to the given table.  
            // Include references inside functions because these are part of the
            // join expressions.
            getColumnsFromExpr :: Expr -> [Expr];
            getColumnsFromExpr expr = 
                case expr of 
                QueryField {queryTable} -> if (queryTable == targetTable) then [expr] else  [];
                FunctionExpr {arguments} -> concatMap getColumnsFromExpr arguments;
                _ -> [];
                ;
            
            getColumnsFromJoins :: JoinNode -> [Expr];
            getColumnsFromJoins joinNode = 
                case joinNode of
                JoinTable {} -> [];
                JoinSubtree {leftNode, rightNode, linkingExpr} -> 
                    let 
                        expr = toUntypedExpr linkingExpr;
                    in
                        (getColumnsFromExpr expr) 
                        ++ (getColumnsFromJoins leftNode)
                        ++ (getColumnsFromJoins rightNode);
                ;
                    
            filteredJoins = concatMap getColumnsFromJoins joins;
            
        in
            removeDuplicates (filteredColumns ++ filteredJoins);
    ;

    
/**
 * Returns all the leaf tables from the specified join tree.
 */
getJoinTreeTables :: JoinNode -> [QueryTable];
public getJoinTreeTables rootJoinNode = 
    let
        getTablesHelper node = 
            case node of
            JoinTable {table} -> [table];
            JoinSubtree {leftNode, rightNode} -> (getTablesHelper leftNode) ++ (getTablesHelper rightNode);
            ;
    in
        removeDuplicates (getTablesHelper rootJoinNode);


/**
 * Applies the specified table modification function to all tables in the query.
 */
modifyTablesInQuery :: (QueryTable -> QueryTable) -> Query -> Query;
public modifyTablesInQuery updateTableFn !query = 
    let
        updateTypedExprTables :: TypedExpr a -> TypedExpr a;
        updateTypedExprTables expr = toTypedExpr (modifyTablesInExpr updateTableFn (toUntypedExpr expr));

        updateOrderingTables :: (Expr, Boolean) -> (Expr, Boolean);
        updateOrderingTables ordering = (modifyTablesInExpr updateTableFn (fst ordering), snd ordering);
    in
        case query of
        Query options columns restriction orderings joins groups groupRestriction ->
            let
                newColumns = map (\pr -> (modifyTablesInExpr updateTableFn (fst pr), snd pr)) columns;
                newRestriction = 
                    case restriction of
                    Nothing -> Nothing;
                    Just restrictionValue -> Just (updateTypedExprTables restrictionValue);
                    ;
                newGroupRestriction = 
                    case groupRestriction of
                    Nothing -> Nothing;
                    Just groupRestrictionValue -> Just (updateTypedExprTables groupRestrictionValue);
                    ;
                newOrderings = map updateOrderingTables orderings;
                newJoins = map (modifyTablesInJoinNode updateTableFn) joins;
                newGroups = map (modifyTablesInExpr updateTableFn) groups;
            in
                Query options newColumns newRestriction newOrderings newJoins newGroups newGroupRestriction;

        Union query1 query2 unionAll -> 
            Union (modifyTablesInQuery updateTableFn  query1) (modifyTablesInQuery updateTableFn  query2) unionAll;
    ;

/**
 * Applies the specified table modification function to all tables in the expression.
 */
modifyTablesInExpr :: (QueryTable -> QueryTable) -> Expr -> Expr;
public modifyTablesInExpr updateTableFn !expr = 
    case expr of
    QueryField {fieldName, queryTable} -> QueryField fieldName (updateTableFn queryTable);
    ConstExpr {} -> expr;
    ListExpr {listValues} -> ListExpr (map (modifyTablesInExpr updateTableFn) listValues);
    FunctionExpr {func, arguments} -> FunctionExpr func (map (modifyTablesInExpr updateTableFn) arguments);
    SubQueryExpr {subquery} -> SubQueryExpr (modifyTablesInQuery updateTableFn subquery);
    ;

/**
 * Applies the specified table modification function to all tables in the typed expression.
 */
modifyTablesInTypedExpr :: (QueryTable -> QueryTable) -> TypedExpr a -> TypedExpr a;
public modifyTablesInTypedExpr updateTableFn !typedExpr = 
    toTypedExpr (modifyTablesInExpr updateTableFn (toUntypedExpr typedExpr));

/**
 * Applies the specified table modification function to all tables in the join node.
 */
modifyTablesInJoinNode :: (QueryTable -> QueryTable) -> JoinNode -> JoinNode;
public modifyTablesInJoinNode updateTableFn !join =
    let
        updateBooleanExprTables :: TypedExpr Boolean -> TypedExpr Boolean;
        updateBooleanExprTables expr = toTypedExpr (modifyTablesInExpr updateTableFn (toUntypedExpr expr));
    in
        case join of
        JoinTable table ->
            JoinTable (updateTableFn table);
        JoinSubtree leftNode rightNode linkingExpr joinType -> 
            JoinSubtree (modifyTablesInJoinNode updateTableFn leftNode) 
                        (modifyTablesInJoinNode updateTableFn rightNode) 
                        (updateBooleanExprTables linkingExpr) joinType;
        ;

/**
 * Applies the specified table modification function to all tables in the join set.
 */
modifyTablesInJoinSet :: (QueryTable -> QueryTable) -> JoinSet -> JoinSet;
public modifyTablesInJoinSet updateTableFn !joinSet = 
    case joinSet of
    JoinSet {name, joins} -> 
        JoinSet name (modifyTablesInJoinNode updateTableFn joins);
    ;

/**
 * Applies the specified query modification function to the query and any
 * subqueries that it contains.
 */
modifyQueries :: (Query -> Query) -> Query -> Query;
public modifyQueries updateQueryFn query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            updateTableQueries queryTable = 
                case queryTable of
               (BaseTable |
                OpaqueSubQueryTable) {} -> queryTable;
                SubQueryTable {subquery, tableAlias} -> SubQueryTable (modifyQueries updateQueryFn subquery) tableAlias;
                ;

            updateExprQueries expr = 
                case expr of
                QueryField fieldName queryTable -> QueryField fieldName (updateTableQueries queryTable);
                ConstExpr constantValue -> expr;
                ListExpr listValues -> ListExpr (map updateExprQueries listValues);
                FunctionExpr func arguments -> FunctionExpr func (map updateExprQueries arguments);
                SubQueryExpr subquery -> SubQueryExpr (modifyQueries updateQueryFn subquery);
                ;

            updateTypedExprQueries expr = toTypedExpr (updateExprQueries (toUntypedExpr expr));

            updateOrderingQueries ordering = (updateExprQueries (fst ordering), snd ordering);

            updateJoinQueries join = 
                case join of
                JoinTable table ->
                    JoinTable (updateTableQueries table);
                JoinSubtree leftNode rightNode linkingExpr joinType -> 
                    JoinSubtree (updateJoinQueries leftNode) (updateJoinQueries rightNode) (updateTypedExprQueries linkingExpr) joinType;
                ;

            newColumns = map (\pr -> (updateExprQueries (fst pr), snd pr)) columns;
            newRestriction = 
                case restriction of
                Nothing -> Nothing;
                Just restrictionValue -> Just (updateTypedExprQueries restrictionValue);
                ;
            newGroupRestriction = 
                case groupRestriction of
                Nothing -> Nothing;
                Just groupRestrictionValue -> Just (updateTypedExprQueries groupRestrictionValue);
                ;
            newOrderings = map updateOrderingQueries orderings;
            newJoins = map updateJoinQueries joins;
            newGroups = map updateExprQueries groups;
        in
            updateQueryFn (Query options newColumns newRestriction newOrderings newJoins newGroups newGroupRestriction);

    Union query1 query2 unionAll -> 
        updateQueryFn (Union (modifyQueries updateQueryFn query1) (modifyQueries updateQueryFn query2) unionAll);
    ;


/**
 * Removed any joins which are including any tables which are otherwise unused
 * in the query.
 * An unused table will not be removed if is being used to join other tables
 * that are used in the query.
 */
removeUnusedTables :: Query -> Query;
public removeUnusedTables query = removeUnusedTables2 [] query;

/**
 * Removed any joins which are including any tables which are otherwise unused
 * in the query.
 * An unused table will not be removed if is being used to join other tables
 * that are used in the query.
 * Tables used by the anchorFields expressions will not be removed either.
 */
removeUnusedTables2 :: [Expr] -> Query -> Query;
public removeUnusedTables2 anchorFields query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            // Get the list of tables used in the query, excluding the joins and
            // unjoined tables in the main query.
            queryTables :: [QueryTable];
            queryTables = getQueryTables False (Query options columns restriction orderings [] groups groupRestriction);

            // Get the list of tables used by the anchor field expressions.
            anchorFieldTables :: [QueryTable];
            anchorFieldTables = concatMap (getExpressionTables True) anchorFields;

            // Get the combined list of tables in use.
            tablesInUse :: [QueryTable];
            tablesInUse = removeDuplicates (queryTables ++ anchorFieldTables);
        in
            Query options columns restriction orderings (removeUnusedTablesInJoinSets tablesInUse joins) groups groupRestriction;

    Union query1 query2 unionAll -> 
        Union (removeUnusedTables2 anchorFields query1) (removeUnusedTables2 anchorFields query2) unionAll;
    ;


/**
 * Returns a modified list of join nodes containing only the joins required for the specified tables.
 * This function will call itself recursively until no more tables can be removed.
 */
removeUnusedTablesInJoinSets :: [QueryTable] -> [JoinNode] -> [JoinNode];
removeUnusedTablesInJoinSets tablesInUse !joins = 
    let
        joinTables = removeDuplicates (concatMap getJoinTreeTables joins);
        unusedJoinTables = deleteFirsts joinTables tablesInUse;

        subtreeNodesInTree joinTree = 
            case joinTree of
            JoinSubtree {leftNode, rightNode} -> joinTree : (subtreeNodesInTree leftNode) ++ (subtreeNodesInTree rightNode);
            _ -> [];
            ;
        allSubtreeNodes = concatMap subtreeNodesInTree joins;

        // Only allow this table to be removed if the only join node
        // that refers to it in the linking expression
        // is its parent subtree node (or none at all).
        canRemoveTable table = 
            let
                subtreeUsesTableInLinkExpr node = 
                    case node of
                    JoinSubtree {linkingExpr} -> isElem table (getExpressionTables False (toUntypedExpr linkingExpr));
                    _ -> False;
                    ;

                subtreesUsingTableInLinkExpr = filter subtreeUsesTableInLinkExpr allSubtreeNodes;

                nodeJoinsTable node = 
                    case node of
                    JoinSubtree {leftNode, rightNode} ->
                        let
                            childNodeIsTable childNode = 
                                case childNode of
                                JoinTable childTable -> childTable == table;
                                _ -> False;
                                ;
                        in
                            (childNodeIsTable leftNode) || (childNodeIsTable rightNode);
                    _ -> False;
                    ;
            in
                isEmpty subtreesUsingTableInLinkExpr 
                    || isEmpty (tail subtreesUsingTableInLinkExpr) && nodeJoinsTable (head subtreesUsingTableInLinkExpr);

        tablesToRemove = filter canRemoveTable unusedJoinTables;

        removeTablesFromJoinTree :: JoinNode -> Maybe JoinNode;
        removeTablesFromJoinTree joinTree = 
            case joinTree of
            JoinTable {table} -> if (isElem table tablesToRemove) then Nothing else Just joinTree;
            JoinSubtree {leftNode, rightNode, linkingExpr, joinType} -> 
                let
                    newLeft = removeTablesFromJoinTree leftNode;
                    newRight = removeTablesFromJoinTree rightNode;
                in
                    case newLeft of
                    Nothing ->
                        newRight;
                    Just newLeftValue ->
                        case newRight of
                        Nothing ->
                            newLeft;
                        Just newRightValue ->
                            Just (JoinSubtree newLeftValue newRightValue linkingExpr joinType);
                        ;
                    ;
            ;

        newJoins = List.mapJust removeTablesFromJoinTree joins;
    in
        if (isEmpty tablesToRemove) then joins
        else removeUnusedTablesInJoinSets tablesInUse newJoins;

/**
 * Returns the best set of joins for the fields in the specified query.
 * An error will be thrown if an appropriate join set cannot be found.
 * If multiple join sets can be used for the query tables, then an error will be returned unless each 
 * of the compatible join sets uses the same joins to connect these tables (ignoring any joins unrelated to the 
 * tables in the query).
 * If a single table is required, then an arbitrary join set (containing this table) will be returned.
 * If no tables are needed, then {@link Nothing@} is returned.
 */
getBestJoinSetForQueryFields :: [JoinSet] -> Query -> [Expr] -> Maybe (UniqueIdentifier JoinSet) -> Maybe JoinSet;
public getBestJoinSetForQueryFields !joinSets !sqlQuery !anchorFieldExpressions !preferredJoinSetID = 
    let
        // Take anchor fields into account when determining which tables are in use.
        qryWithAnchorFields = project sqlQuery anchorFieldExpressions;

        // Don't include subquery tables or tables from within subqueries.
        queryTables = filter (\t -> not (isSubqueryTable t)) (getQueryTables False qryWithAnchorFields);

        // Returns True if the join set contains all the query tables.
        joinSetContainsQueryTables :: JoinSet -> Boolean;
        joinSetContainsQueryTables joinSet = 
            let
                joinTree = joinSetJoinTree joinSet;
                joinTreeTables = getJoinTreeTables joinTree;
            in
                // Check whether all the query tables are included in the join tree tables list.
                isEmpty (List.deleteFirsts queryTables joinTreeTables);

        // Determine which of the join sets contain all the necessary tables.
        compatibleJoinSets :: [JoinSet];
        compatibleJoinSets = filter joinSetContainsQueryTables joinSets;

        // Try to find the preferred join set (if any) in the list of compatible sets.
        preferredJoinSet :: Maybe JoinSet;
        preferredJoinSet = 
            case preferredJoinSetID of
            Nothing -> Nothing;
            Just preferredJoinSetID -> UniqueIdentifier.findMatchingUniquelyNamedItemById compatibleJoinSets preferredJoinSetID;
            ;
    in
        // Return Nothing if no tables are involved.
        if (isEmpty queryTables) then
            Nothing
        else if (List.isSingletonList queryTables) then 
            // Use an arbitrary join set if only 1 table is used.
            Prelude.listToMaybe compatibleJoinSets
        else if (isEmpty compatibleJoinSets) then
            // Throw an error if there are multiple tables and no appropriate join set could be found.
            error ("The dictionary does not contain a join set that includes all the specified fields."
                ++ "\nQuery: " ++ show sqlQuery
                ++ "\nAnchorFieldExpressions: " ++ show anchorFieldExpressions
                ++ "\nTables: " ++ show queryTables
                ++ "\nJoin Sets: " ++ show joinSets
                )
        else if (List.isSingletonList compatibleJoinSets) then
            // If a single join set is compatible, then use it.
            Prelude.listToMaybe compatibleJoinSets
        else if (isJust preferredJoinSet) then
            // If there are multiple compatible join sets, then check whether one of them is the preferred one (if any).
            preferredJoinSet
        else
            // There are multiple compatible join sets (and no preferred one is specified).
            // Reduce each of these to the joins involving the query tables.
            // If the remaining joins are equivalent in each set, then it is safe to return an arbitrary one of these, 
            // since they will all be the same as far as this query is concerned.
            // If the join sets use different joins to connect the tables in the query, then throw an error since
            // there is no way to know which join path is indended.
            let
                // Reduce each compatible join set such that it only includes the query tables.
                reducedJoinSets :: [[JoinNode]];
                reducedJoinSets = 
                    map (removeUnusedTablesInJoinSets queryTables # List.list1 # joinSetJoinTree) compatibleJoinSets;
            in
                // Check whether each compatible join set uses the same joins to connect the query tables.
                // TODO: perhaps more care needs to be taken when comparing whether 2 join nodes are equivalent...
                //       In some cases, the order and/or direction of the joins can be ignored.
                if (List.lengthAtLeast 2 (List.removeDuplicates reducedJoinSets)) then 
                    error "There is more than one join set compatible with the specified query."
                else 
                    Prelude.listToMaybe compatibleJoinSets;

/**
 * Adds the necessary grouping to the query to make it valid if there is any
 * grouping or aggregation.
 */
fixQueryForGroupBy :: Query -> Query;
private fixQueryForGroupBy query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            getExprAggregationExprs expr = 
                case expr of
                ListExpr {listValues} -> 
                    concatMap getExprAggregationExprs listValues;
                FunctionExpr {func, arguments} -> 
                    if (isAggregationFunction func) then [expr]
                    else concatMap getExprAggregationExprs arguments;
                _ -> [];
                ;

            allExprs = map fst columns ++ map fst orderings ++ map toUntypedExpr (maybeToList groupRestriction);
            aggregateExprs = concatMap getExprAggregationExprs allExprs;

            groupByNeeded = not (isEmpty groups) || not (isEmpty aggregateExprs);

            addGroupExprs !curGrouping !expr = 
                // If the expression is already grouped then nothing else is
                // necessary.
                if (isElem expr curGrouping) then 
                    curGrouping
                else
                    case expr of
                    QueryField {} -> curGrouping ++ [expr];
                    ConstExpr {} -> curGrouping;
                    ListExpr {listValues} -> foldLeftStrict addGroupExprs curGrouping listValues;
                    FunctionExpr {func, arguments} -> 
                        if (isAggregationFunction func) then curGrouping
                        else foldLeftStrict addGroupExprs curGrouping arguments;
                    SubQueryExpr {} -> curGrouping;
                    ;

            newGrouping = foldLeftStrict addGroupExprs groups allExprs;
        in
            if (groupByNeeded) then Query options columns restriction orderings joins newGrouping groupRestriction
            else query;

    Union query1 query2 unionAll -> 
        Union (fixQueryForGroupBy query1) (fixQueryForGroupBy query2) unionAll;
    ;

/**
 * Removes any constant expressions from the grouping and ordering lists.
 */
removeConstantGroupingAndOrdering :: Query -> Query;
removeConstantGroupingAndOrdering !query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            newGroups :: [Expr];
            newGroups = filter (not # isExprConstant) groups;

            newOrderings :: [(Expr, Boolean)];
            newOrderings = filter (\!ord -> not (isExprConstant (field1 ord))) orderings;
        in
            // Handle the (common) case where nothing needs to be changed.
            if (length newGroups == length groups || length newOrderings == length orderings) then query
            else Query options columns restriction newOrderings joins newGroups groupRestriction;

    Union query1 query2 unionAll -> 
        Union (removeConstantGroupingAndOrdering query1) (removeConstantGroupingAndOrdering query2) unionAll;
    ;


/**
 * Returns whether the expression is a constant value or an expression composed of only constant values.
 */
isExprConstant :: Expr -> Boolean;
isExprConstant !expr = 
    case expr of
    QueryField {} -> False;
    ConstExpr {} -> True;
    ListExpr {listValues} -> 
        // Check whether all of the list values are constant.
        List.all isExprConstant listValues;
    FunctionExpr {arguments} -> 
        // Check whether all of the function argument values are constant.
        List.all isExprConstant arguments;
    SubQueryExpr {} -> 
        // For now, just assume that subqueries are never constant.
        // TODO: should the case where the subquery contains only constant values be handled?
        False;
    ;



//////////////////////////////////////////////////////////////////
// SQL Builder

/**
 * This is a helper object which is passed through the SQL builder code to keep
 * track of intermediate state.
 */
data public SqlBuilderState = 
    private SqlBuilderState 
        outerQueryTables :: [QueryTable];

/**
 * Creates an empty SQL builder state object.
 */
private newSqlBuilderState = SqlBuilderState [];

getStateOuterQueryTables :: SqlBuilderState -> [QueryTable];
private getStateOuterQueryTables !builderState = builderState.SqlBuilderState.outerQueryTables;

addQueryTablesToState :: SqlBuilderState -> [QueryTable] -> SqlBuilderState;
private addQueryTablesToState builderState newTables = 
    case builderState of
    SqlBuilderState {outerQueryTables} -> SqlBuilderState (removeDuplicates (outerQueryTables ++ newTables));
    ;


/**
 * This type holds various functions needed for converting primitive values to
 * text for the SQL query.
 */
data PrimitiveValueBuilder = 
    private PrimitiveValueBuilder
        intToSqlFn          :: (Int -> Document)                         // (intVal)
        doubleToSqlFn       :: (Double -> Document)                      // (doubleVal)
        stringToSqlFn       :: (String -> Document)                      // (stringVal)
        timeToSqlFn         :: (Time -> TimeZone -> Document)            // (timeVal, timeZone)
        booleanToSqlFn      :: (Boolean -> Document)                     // (boolVal)
        nullToSqlFn         :: Document 
        timeIntervalToSqlFn :: (TimeInterval -> Document)                // (timeInterval)
        ;

/**
 * Constructs a new SQL primitive value builder with the specified functions.
 */
makePrimitiveValueBuilder :: (Int -> Document)                    // intToSql
                                                                  // (intVal)
                             -> (Double -> Document)              // doubleToSql
                                                                  // (doubleVal)
                             -> (String -> Document)              // stringToSql
                                                                  // (stringVal)
                             -> (Time -> TimeZone -> Document)    // timeToSql
                                                                  // (timeVal
                                                                  // timeZone)
                             -> (Boolean -> Document)             // booleanToSql
                                                                  // (boolVal)
                             -> Document                          // nullToSql
                             -> (TimeInterval -> Document)        // timeIntervalToSql(timeInterval)
                             -> PrimitiveValueBuilder;
makePrimitiveValueBuilder = PrimitiveValueBuilder;


/**
 * The SQL Builder holds the various functions needed to construct the SQL query
 * text from a {@link typeConstructor = Query@}.
 * Different instances of this should be created for the different SQL
 * 'flavours'.
 */
data public SqlBuilder = 
    private SqlBuilder 
        prepareQueryFn :: 
            // (builderState query)
            (SqlBuilderState -> Query -> Query)        

        constructQueryFn :: 
            // (builderState selectBody fromBody whereBody 
            //               groupByBody havingBody orderByBody)
            (SqlBuilderState -> Document -> Document -> Document -> 
                                Document -> Document -> Document -> Document)

                    
        constructUnionQueryFn :: 
            // (builderState query1Text query2Text unionAll)
            (SqlBuilderState -> Document -> Document -> Boolean -> Document)

        buildSelectClauseFn ::
            // (builderState options exprsAndAliases)
            (SqlBuilderState -> [QueryOption] -> [(Expr, String)] -> Document)   
            
        buildFromClauseFn ::
            // (builderState joins)
            (SqlBuilderState -> [JoinNode] -> Document)
            
        buildWhereClauseFn ::
            // (builderState restrictions joins)
            (SqlBuilderState -> (Maybe Expr) -> [JoinNode] -> Document)
            
        buildOrderByClauseFn ::
            // (builderState orderExpressions)
            (SqlBuilderState -> [(Expr, Boolean)] -> Document)
            
        buildGroupByClauseFn ::
            // (builderState groupExpressions)
            (SqlBuilderState -> [Expr] -> Document)
        
        buildHavingClauseFn ::
            // (builderState groupRestrictions)
            (SqlBuilderState -> (Maybe Expr) -> Document)
            
        buildCreateDatabaseStatementFn ::
            // (databaseRef skipIfDatabaseExists)
            (DatabaseReference -> Boolean -> Document)

        buildDropDatabaseStatementFn ::
            // (databaseRef onlyIfDatabaseExists)
            (DatabaseReference -> Boolean -> Document)

        buildCreateTableStatementFn ::
            // (tableDesc skipIfTableExists)
            (TableDescription -> Boolean -> Document)

        buildCreateViewStatementFn :: 
            // (viewRef viewDefinition)
            (TableReference -> Query -> Boolean -> Document)

        buildDropTableStatementFn ::
            // (tableRef onlyIfTableExists)
            (TableReference -> Boolean -> Document)
            
        buildDropViewStatementFn ::
            // (viewRef onlyIfViewExists)
            (TableReference -> Boolean -> Document)
            
        buildInsertValuesStatementFn ::
            // (tableRef maybeDestColumns rowValues)
            (TableReference -> Maybe [String] -> [Expr] -> Document)

        buildInsertQueryValuesStatementFn :: 
            // (tableRef maybeDestColumns insertQuery)
            (TableReference -> Maybe [String] -> Query -> Document)

        buildUpdateValuesStatementFn :: 
            // (builderState tableRef destColumns newValues condition)
            (SqlBuilderState -> TableReference -> [String] -> [Expr] -> TypedExpr Boolean -> Document)

        buildDeleteRowsStatementFn :: 
            // (builderState tableRef, condition)
            (SqlBuilderState -> TableReference -> TypedExpr Boolean -> Document)

        buildCommitStatementFn ::
            Document
            
        buildFieldDescriptionFn ::
            // (fieldDesc)
            (FieldDescription -> Document)
            
        buildFieldTypeFn ::
            // (dataType)
            (SqlType -> Document)

        parameterToSqlFn ::
            (Parameter -> Document)
        
        listToSqlFn ::
            // (builderState exprList)
            (SqlBuilderState -> [Expr] -> Document)
            
        functionToSqlFn ::
            // (builderState func argExprs)
            (SqlBuilderState -> DbFunction -> [Expr] -> Document)

        functionNameFn :: 
            // (dbFunction)
            (DbFunction -> String)
        
        operatorTextFn :: 
            // (operator)
            (DbFunction -> String)
        
        addParensFn ::
            // (exprText)
            (Document -> Document)
            
        quoteIdentifierFn ::
            // (indentifierText)
            (String -> Document)

        buildTableAndAliasTextFn ::
            // (queryTable)
            (SqlBuilderState -> QueryTable -> Document)

        makeSafeNameFn ::
            // (name)
            (String -> String)

        primitiveValueBuilder ::
            PrimitiveValueBuilder
        
        ;

///**
// * Constructs a new SQL builder with the specified functions.
// */
//makeSqlBuilder :: (SqlBuilderState -> Query -> Query)                                    // prepareQuery(builderState
//                                                                                         // query)
//                   
//                   -> (SqlBuilderState -> Document -> Document -> Document -> 
//                                      Document -> Document -> Document -> Document)      // constructQuery
//                                                                                         // (builderState
//                                                                                         // selectBody
//                                                                                         // fromBody
//                                                                                         // whereBody
//                                                                                         // groupByBody
//                                                                                         // havingBody
//                                                                                         // orderByBody)
//                   -> (SqlBuilderState -> Document -> Document -> Boolean -> Document)   // constructUnionQuery
//                                                                                         // (builderState
//                                                                                         // query1Text
//                                                                                         // query2Text
//                                                                                         // unionAll)
//
//                   -> (SqlBuilderState -> [QueryOption] -> [(Expr, String)] -> Document) // buildSelectClause
//                                                                                         // (builderState
//                                                                                         // options
//                                                                                         // exprsAndAliases)
//                   -> (SqlBuilderState -> [JoinNode] -> Document)                        // buildFromClause
//                                                                                         // (builderState
//                                                                                         // joins)
//                   -> (SqlBuilderState -> (Maybe Expr) -> [JoinNode] -> Document)        // buildWhereClause
//                                                                                         // (builderState
//                                                                                         // restrictions
//                                                                                         // joins)
//                   -> (SqlBuilderState -> [(Expr, Boolean)] -> Document)                 // buildOrderByClause
//                                                                                         // (builderState
//                                                                                         // orderExpressions)
//                   -> (SqlBuilderState -> [Expr] -> Document)                            // buildGroupByClause
//                                                                                         // (builderState
//                                                                                         // groupExpressions)
//                   -> (SqlBuilderState -> (Maybe Expr) -> Document)                      // buildHavingClause
//                                                                                         // (builderState
//                                                                                         // groupRestrictions)
//
//                   -> (DatabaseReference -> Boolean -> Document)                         // buildCreateDatabaseStatement
//                                                                                         // (databaseRef
//                                                                                         // skipIfDatabaseExists)
//                   -> (DatabaseReference -> Boolean -> Document)                         // buildDropDatabaseStatement
//                                                                                         // (databaseRef
//                                                                                         // onlyIfDatabaseExists)
//                   -> (TableDescription -> Boolean -> Document)                          // buildCreateTableStatement
//                                                                                         // (table
//                                                                                         // fieldDescriptions
//                                                                                         // constraints
//                                                                                         // skipIfTableExists)
//                   -> (TableReference -> Query -> Boolean -> Document)                   // buildCreateViewStatement
//                                                                                         // (viewRef
//                                                                                         // viewDefinition)
//                   -> (TableReference -> Boolean -> Document)                            // buildDropTableStatement
//                                                                                         // (table
//                                                                                         // onlyIfTableExists)
//                   -> (TableReference -> Boolean -> Document)                            // buildDropViewStatement
//                                                                                         // (viewRef
//                                                                                         // onlyIfViewExists)
//                   -> (TableReference -> Maybe [String] -> [Expr] -> Document)           // buildInsertValuesStatement
//                                                                                         // (table
//                                                                                         // rowValues)
//                   -> (TableReference -> Maybe [String] -> Query -> Document)            // buildInsertQueryValuesStatement
//                                                                                         // (table
//                                                                                         // insertQuery)
//                   
//                   -> (SqlBuilderState -> TableReference -> [String] -> [Expr] -> TypedExpr Boolean -> Document) // buildUpdateValuesStatementFn
//                                                                                         // (table
//                                                                                         // destColumns
//                                                                                         // newValues
//                                                                                         // condition
//            
//                   -> (SqlBuilderState -> TableReference -> TypedExpr Boolean -> Document) // buildDeleteRowsStatementFn 
//                                                                                         // (table
//                                                                                         // condition)
//                   -> Document
//                   -> (FieldDescription -> Document)                                     // buildFieldDescription
//                                                                                         // (fieldDesc)
//                   -> (SqlType -> Document)                                              // buildFieldType
//                                                                                         // (dataType)
//
//                   -> (Parameter -> Document)
//                   -> (SqlBuilderState -> [Expr] -> Document)                            // listToSql
//                                                                                         // (builderState
//                                                                                         //  exprList)
//                   -> (SqlBuilderState -> DbFunction -> [Expr] -> Document)              // functionToSql
//                                                                                         // (builderState
//                                                                                         //  func
//                                                                                         //  argExprs)
//                   -> (DbFunction -> String)                                             // functionName (function)
//                   -> (DbFunction -> String)                                             // operatorText (function)
//        
//                   -> (Document -> Document)                                             // addParens
//                                                                                         // (exprText)
//                   -> (String -> Document)                                               // quoteIdentifier
//                                                                                         // (indentifierText)
//
//                   -> (SqlBuilderState -> QueryTable -> Document)                        // buildTableAndAliasText
//                                                                                         // (queryTable)
//
//                   -> (String -> String)                                                 // makeSafeName
//                                                                                         // (name)
//
//                   -> PrimitiveValueBuilder                                              // primitiveValueBuilder
//                   -> SqlBuilder;
//public makeSqlBuilder = SqlBuilder;

/**
 * Constructs a SqlBuilder using the functions provided in a record.
 * The advantage of this approach is that a SqlBuilder can easily override selected functions from the record of another SqlBuilder.
 */
makeSqlBuilder :: { prepareQuery                    :: SqlBuilderState -> Query -> Query,
                    constructQuery                  :: SqlBuilder -> SqlBuilderState -> Document -> Document -> Document -> Document -> Document -> Document -> Document,
                    constructUnionQuery             :: SqlBuilder -> SqlBuilderState -> Document -> Document -> Boolean -> Document,
                     
                    buildSelectClause               :: SqlBuilder -> SqlBuilderState -> [QueryOption] -> [(Expr, String)] -> Document,
                    buildFromClause                 :: SqlBuilder -> SqlBuilderState -> [JoinNode] -> Document,
                    buildWhereClause                :: SqlBuilder -> SqlBuilderState -> (Maybe Expr) -> [JoinNode] -> Document,
                    buildOrderByClause              :: SqlBuilder -> SqlBuilderState -> [(Expr, Boolean)] -> Document,
                    buildGroupByClause              :: SqlBuilder -> SqlBuilderState -> [Expr] -> Document,
                    buildHavingClause               :: SqlBuilder -> SqlBuilderState -> (Maybe Expr) -> Document,
                     
                    buildCreateDatabaseStatement    :: SqlBuilder -> DatabaseReference -> Boolean -> Document,
                    buildDropDatabaseStatement      :: SqlBuilder -> DatabaseReference -> Boolean -> Document,
                    buildCreateTableStatement       :: SqlBuilder -> TableDescription -> Boolean -> Document,
                    buildCreateViewStatement        :: SqlBuilder -> TableReference -> Query -> Boolean -> Document,
                    buildDropTableStatement         :: SqlBuilder -> TableReference -> Boolean -> Document,
                    buildDropViewStatement          :: SqlBuilder -> TableReference -> Boolean -> Document,
                    buildInsertValuesStatement      :: SqlBuilder -> TableReference -> Maybe [String] -> [Expr] -> Document,
                    buildInsertQueryValuesStatement :: SqlBuilder -> TableReference -> Maybe [String] -> Query -> Document,
                    buildUpdateValuesStatement      :: SqlBuilder -> SqlBuilderState -> TableReference -> [String] -> [Expr] -> TypedExpr Boolean -> Document,
                    buildDeleteRowsStatement        :: SqlBuilder -> SqlBuilderState -> TableReference -> TypedExpr Boolean -> Document,
                    buildCommitStatement            :: SqlBuilder -> Document,
                     
                    buildFieldDescription           :: SqlBuilder -> FieldDescription -> Document,
                    buildFieldType                  :: SqlType -> Document,
                    parameterToSql                  :: SqlBuilder -> Parameter -> Document,
                    listToSql                       :: SqlBuilder -> SqlBuilderState -> [Expr] -> Document,
                    functionToSql                   :: SqlBuilder -> SqlBuilderState -> DbFunction -> [Expr] -> Document,
                    functionName                    :: DbFunction -> String,
                    operatorText                    :: DbFunction -> String,
                    addParens                       :: Document -> Document,
                    quoteIdentifier                 :: String -> Document,
                    buildTableAndAliasText          :: SqlBuilder -> SqlBuilderState -> QueryTable -> Document,
                    makeSafeName                    :: String -> String,
                     
                    intToSql                        :: Int -> Document,
                    doubleToSql                     :: Double -> Document,
                    stringToSql                     :: String -> Document,
                    timeToSql                       :: Time -> TimeZone -> Document,
                    booleanToSql                    :: Boolean -> Document,
                    nullToSql                       :: Document,
                    timeIntervalToSql               :: TimeInterval -> Document
                  } -> SqlBuilder;
public makeSqlBuilder sqlBuilderFns = 
    let
        valueBuilder :: PrimitiveValueBuilder;
        valueBuilder = 
            makePrimitiveValueBuilder sqlBuilderFns.intToSql
                                      sqlBuilderFns.doubleToSql
                                      sqlBuilderFns.stringToSql
                                      sqlBuilderFns.timeToSql
                                      sqlBuilderFns.booleanToSql
                                      sqlBuilderFns.nullToSql
                                      sqlBuilderFns.timeIntervalToSql;
       
        sqlBuilder = SqlBuilder (sqlBuilderFns.prepareQuery)
                                (sqlBuilderFns.constructQuery sqlBuilder)
                                (sqlBuilderFns.constructUnionQuery sqlBuilder)
                                (sqlBuilderFns.buildSelectClause sqlBuilder)
                                (sqlBuilderFns.buildFromClause sqlBuilder)
                                (sqlBuilderFns.buildWhereClause sqlBuilder)
                                (sqlBuilderFns.buildOrderByClause sqlBuilder)
                                (sqlBuilderFns.buildGroupByClause sqlBuilder)
                                (sqlBuilderFns.buildHavingClause sqlBuilder)
                                (sqlBuilderFns.buildCreateDatabaseStatement sqlBuilder)
                                (sqlBuilderFns.buildDropDatabaseStatement sqlBuilder)
                                (sqlBuilderFns.buildCreateTableStatement sqlBuilder)
                                (sqlBuilderFns.buildCreateViewStatement sqlBuilder)
                                (sqlBuilderFns.buildDropTableStatement sqlBuilder)
                                (sqlBuilderFns.buildDropViewStatement sqlBuilder)
                                (sqlBuilderFns.buildInsertValuesStatement sqlBuilder)
                                (sqlBuilderFns.buildInsertQueryValuesStatement sqlBuilder)
                                (sqlBuilderFns.buildUpdateValuesStatement sqlBuilder)
                                (sqlBuilderFns.buildDeleteRowsStatement sqlBuilder)
                                (sqlBuilderFns.buildCommitStatement sqlBuilder)
                                (sqlBuilderFns.buildFieldDescription sqlBuilder)
                                (sqlBuilderFns.buildFieldType)
                                (sqlBuilderFns.parameterToSql sqlBuilder)
                                (sqlBuilderFns.listToSql sqlBuilder)
                                (sqlBuilderFns.functionToSql sqlBuilder)
                                (sqlBuilderFns.functionName)
                                (sqlBuilderFns.operatorText)
                                (sqlBuilderFns.addParens)
                                (sqlBuilderFns.quoteIdentifier)
                                (sqlBuilderFns.buildTableAndAliasText sqlBuilder)
                                (sqlBuilderFns.makeSafeName)
                                valueBuilder;
    in
        sqlBuilder;

/**
 * This function gives the SQL builder a chance to alter the structure of the
 * query in order to simplify building of the query text.
 */
prepareToBuildQueryText :: SqlBuilder -> SqlBuilderState -> Query -> Query;
private prepareToBuildQueryText !sqlBuilder builderState query = 
    (sqlBuilder.SqlBuilder.prepareQueryFn) builderState query;
 
/**
 * Constructs a complete SQL query from the component parts.
 */
constructQuery :: SqlBuilder -> SqlBuilderState -> Document -> Document -> Document -> Document -> Document -> Document -> Document;
private constructQuery !sqlBuilder builderState selectBody fromBody whereBody groupByBody havingBody orderByBody = 
    (sqlBuilder.SqlBuilder.constructQueryFn) builderState selectBody fromBody whereBody groupByBody havingBody orderByBody;

constructUnionQuery :: SqlBuilder -> SqlBuilderState -> Document -> Document -> Boolean -> Document;
private constructUnionQuery !sqlBuilder builderState query1Text query2Text unionAll = 
    (sqlBuilder.SqlBuilder.constructUnionQueryFn) builderState query1Text query2Text unionAll;


/**
 * Constructs the text of the SELECT clause for the query, not including the
 * 'SELECT' keyword (or equivalent).
 */
buildSelectClause  :: SqlBuilder -> SqlBuilderState -> [QueryOption] -> [(Expr, String)] -> Document;
private buildSelectClause !sqlBuilder builderState options exprsAndAliases = 
    (sqlBuilder.SqlBuilder.buildSelectClauseFn) builderState options exprsAndAliases;

/**
 * Constructs the text of the FROM clause for the query, not including the 'FROM'
 * keyword (or equivalent).
 */
buildFromClause :: SqlBuilder -> SqlBuilderState -> [JoinNode] -> Document;
private buildFromClause !sqlBuilder builderState joins = 
    (sqlBuilder.SqlBuilder.buildFromClauseFn) builderState joins;

/**
 * Constructs the text of the WHERE clause for the query, not including the
 * 'WHERE' keyword (or equivalent).
 */
buildWhereClause :: SqlBuilder -> SqlBuilderState -> (Maybe Expr) -> [JoinNode] -> Document;
private buildWhereClause !sqlBuilder builderState restrictions joins = 
    (sqlBuilder.SqlBuilder.buildWhereClauseFn) builderState restrictions joins;

/**
 * Constructs the text of the ORDER BY clause for the query, not including the
 * 'ORDER BY' keyword (or equivalent).
 */
buildOrderByClause :: SqlBuilder -> SqlBuilderState -> [(Expr, Boolean)] -> Document;
private buildOrderByClause !sqlBuilder builderState orderExpressions = 
    (sqlBuilder.SqlBuilder.buildOrderByClauseFn) builderState orderExpressions;

/**
 * Constructs the text of the GROUP BY clause for the query, not including the
 * 'GROUP BY' keyword (or equivalent).
 */
buildGroupByClause :: SqlBuilder -> SqlBuilderState -> [Expr] -> Document;
private buildGroupByClause !sqlBuilder builderState groupExpressions = 
    (sqlBuilder.SqlBuilder.buildGroupByClauseFn) builderState groupExpressions;

/**
 * Constructs the text of the HAVING clause for the query, not including the
 * 'HAVING' keywork (or equivalent).
 */
buildHavingClause :: SqlBuilder -> SqlBuilderState -> (Maybe Expr) -> Document;
private buildHavingClause !sqlBuilder builderState groupRestrictions = 
    (sqlBuilder.SqlBuilder.buildHavingClauseFn) builderState groupRestrictions;

/**
 * Returns the primitive value builder associated with the SQL builder.
 */
primitiveValueBuilder :: SqlBuilder -> PrimitiveValueBuilder;
private primitiveValueBuilder !sqlBuilder = sqlBuilder.SqlBuilder.primitiveValueBuilder;

/**
 * Builds the SQL text for an int constant.
 */
intToSql :: SqlBuilder -> Int -> Document;
private intToSql !sqlBuilder intVal = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.intToSqlFn intVal;

/**
 * Builds the SQL text for a double constant.
 */
doubleToSql :: SqlBuilder -> Double -> Document;
private doubleToSql !sqlBuilder doubleVal = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.doubleToSqlFn doubleVal;

/**
 * Builds the SQL text for a string constant.
 */
stringToSql :: SqlBuilder -> String -> Document;
private stringToSql !sqlBuilder stringVal = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.stringToSqlFn stringVal;

/**
 * Builds the SQL text for a time constant.
 */
timeToSql :: SqlBuilder -> Time -> TimeZone -> Document;
private timeToSql !sqlBuilder timeVal timeZone = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.timeToSqlFn timeVal timeZone;

/**
 * Builds the SQL text for a boolean constant.
 */
booleanToSql :: SqlBuilder -> Boolean -> Document;
private booleanToSql !sqlBuilder boolVal = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.booleanToSqlFn boolVal;

/**
 * Builds the SQL text for a null value constant.
 */
nullToSql :: SqlBuilder -> Document;
private nullToSql !sqlBuilder = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.nullToSqlFn;

/**
 * Builds the SQL text for a time interval constant.
 */
timeIntervalToSql :: SqlBuilder -> TimeInterval -> Document;
public timeIntervalToSql !sqlBuilder timeInterval = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.timeIntervalToSqlFn timeInterval;

/**
 * Builds the SQL text for a list of expressions.
 */
parameterToSql :: SqlBuilder -> Parameter -> Document;
private parameterToSql !sqlBuilder !parameter =
    sqlBuilder.SqlBuilder.parameterToSqlFn parameter;

/**
 * Builds the SQL text for a list of expressions.
 */
listToSql :: SqlBuilder -> SqlBuilderState -> [Expr] -> Document;
private listToSql !sqlBuilder builderState exprList = 
    (sqlBuilder.SqlBuilder.listToSqlFn) builderState exprList;

/**
 * Builds the SQL text for a SQL function application.
 */
functionToSql :: SqlBuilder -> SqlBuilderState -> DbFunction -> [Expr] -> Document;
private functionToSql !sqlBuilder builderState func argExprs = 
    (sqlBuilder.SqlBuilder.functionToSqlFn) builderState func argExprs;

/**
 * Returns the name for a SQL function.
 */
functionName :: SqlBuilder -> DbFunction -> String;
public functionName !sqlBuilder !func = 
    sqlBuilder.SqlBuilder.functionNameFn func;

/**
 * Returns the text for a SQL operator.
 */
operatorText :: SqlBuilder -> DbFunction -> String;
public operatorText !sqlBuilder !operator = 
    sqlBuilder.SqlBuilder.operatorTextFn operator;

/**
 * Adds parentheses around some expression text.
 */
addParens :: SqlBuilder -> Document -> Document;
public addParens !sqlBuilder exprText = 
    (sqlBuilder.SqlBuilder.addParensFn) exprText;

/**
 * Adds quotes to a name (such as a table).
 */
quoteIdentifier :: SqlBuilder -> String -> Document;
public quoteIdentifier !sqlBuilder indentifierText = 
    (sqlBuilder.SqlBuilder.quoteIdentifierFn) indentifierText;

/**
 * Builds a table name and optional table alias.
 */
buildTableAndAliasText :: SqlBuilder -> SqlBuilderState -> QueryTable -> Document;
public buildTableAndAliasText !sqlBuilder builderState queryTable = 
    (sqlBuilder.SqlBuilder.buildTableAndAliasTextFn) builderState queryTable;


/**
 * Returns a 'safe' version of the specified name.
 */
makeSafeSqlName :: SqlBuilder -> String -> String;
public makeSafeSqlName !sqlBuilder name = 
    (sqlBuilder.SqlBuilder.makeSafeNameFn) name;

/**
 * Returns 'safe' versions of the specified names.
 * The names will all be distinct.
 */
makeSafeSqlNames :: SqlBuilder -> [String] -> [String] -> [String];
public makeSafeSqlNames sqlBuilder namesInUse names = 
    let
        safeNames = map (makeSafeSqlName sqlBuilder) names;
    in
        makeUniqueNames namesInUse safeNames;

/**
 * Returns an updated version of the name list where each name is unique.
 * The name comparisons are not case sensitive.
 * The names will be made unique by appending an integer to the end of the name.
 * 
 * TODO: perhaps this should take into account the maximum length for various
 * names for the database...
 */
makeUniqueNames :: [String] -> [String] -> [String];
public makeUniqueNames namesAlreadyInUse names = 
    let
        makeUniqueNamesHelper :: Set String -> [String] -> [String];
        makeUniqueNamesHelper namesInUse names = 
            case names of
            [] -> [];
            n : ns -> 
                let
                    uniqueName = getUniqueName namesInUse n 0;
                    updatedNamesInUse = Set.insert (toLowerCase uniqueName) namesInUse;
                in
                    uniqueName : makeUniqueNamesHelper updatedNamesInUse ns;
            ;

        getUniqueName :: Set String -> String -> Int -> String;
        getUniqueName namesInUse name attemptN = 
            let
                attemptedName = if (attemptN == 0) then name else name ++ (intToString attemptN);
            in
                if (isEmpty attemptedName) then
                    attemptedName
                else if (Set.member (toLowerCase attemptedName) namesInUse) then 
                    getUniqueName namesInUse name (attemptN + 1)
                else 
                    attemptedName;
    in
        makeUniqueNamesHelper (Set.fromList (map toLowerCase namesAlreadyInUse)) names;


/**
 * Builds the query text for a single expression.
 * Note that this should only be called to generate text for top-level
 * expressions.
 * For expressions embedded in a SQL query or other expressions, call
 * {@link expressionText2@} instead and provide the appropriate {@code builderState@}.
 */
expressionText :: SqlBuilder -> Expr -> String;
public expressionText builder expr = 
    let
        displayWidth = 1 :: Int;
        doc = expressionText2 builder newSqlBuilderState expr;
    in
        PrettyPrinter.pretty displayWidth doc;

/**
 * Builds the query text for a single expression.
 */
expressionText2 :: SqlBuilder -> SqlBuilderState -> Expr -> Document;
public expressionText2 builder builderState expr = 
    let
        // TODO: how should this info be supplied?
        timeZone = TimeZone.currentTimeZone;
    in
        case expr of
        QueryField {fieldName, queryTable} -> 
            let
                tableAlias = quoteIdentifier builder (getQueryTableAlias queryTable);
                fieldNameText = quoteIdentifier builder fieldName;
            in
                if (isEmpty tableAlias) then fieldNameText
                else tableAlias ++ text "." ++ fieldNameText;

        ConstExpr {constantValue} ->
            case constantValue of
            NullValue -> nullToSql builder;
            StringValue {strValue} -> stringToSql builder strValue;
            NumberValue {numValue} -> doubleToSql builder numValue;
            BooleanValue {boolValue} -> booleanToSql builder boolValue;
            TimeValue {timeValue} -> timeToSql builder timeValue timeZone;
            _ -> error "Unknown constant value type";
        ;
        
        ParameterExpr {parameter} ->
            parameterToSql builder parameter;

        ListExpr {listValues} ->
            listToSql builder builderState listValues;

        FunctionExpr {func, arguments} ->
            functionToSql builder builderState func arguments;

        SubQueryExpr {subquery} ->
            addParens builder (nest 4 (line ++ queryText2 builder builderState (fixSubqueryOrdering subquery)) ++ line);
    ;


/**
 * Returns whether the function is really an operator (in-fix).
 */
isOperator :: DbFunction -> Boolean;
public isOperator func = operatorPrecedence func > 0;

/**
 * Returns the precedence of the specified operator.
 * An operation with a higher precendence value will be done first.
 */
operatorPrecedence :: DbFunction -> Int;
public operatorPrecedence func = 
    case func of
    OpNot    -> 5;
    OpBitNot -> 7;
    OpNegate -> 7;

    OpEq     -> 4;
    OpLt     -> 4;
    OpLtEq   -> 4;
    OpGt     -> 4;
    OpGtEq   -> 4;
    OpNotEq  -> 4;

    OpAnd    -> 2;
    OpOr     -> 1;

    OpLike   -> 4;
    OpIn     -> 4;

    OpCat    -> 5;

    OpPlus   -> 5;
    OpMinus  -> 5;
    OpMul    -> 6;
    OpDiv    -> 6;
    OpMod    -> 6;

    OpBetween -> 4;
    OpCase_Simple -> 4;
    OpCase_Searched -> 4;

    OpBitAnd -> 3;
    OpBitOr  -> 3;
    OpBitXor -> 3;

    OpExists -> 9;

    OpIsNull -> 8;
    OpIsNotNull -> 8;

    _ -> 0; // Not an operator.
    ;

exprOperatorPrecedence :: Expr -> Int;
public exprOperatorPrecedence expr = 
    case expr of
    FunctionExpr {func} -> operatorPrecedence func;
    _ -> 0; // Not an operator.
    ;


/**
 * Removes ordering for the subquery unless it is required (as with a {@link TopN@}
 * query).
 */
private fixSubqueryOrdering subquery = if (isTopNQuery subquery) then subquery else removeOrdering subquery;


/**
 * Builds the query text for a table name (including quotes where needed).
 */
tableNameText :: SqlBuilder -> SqlBuilderState -> QueryTable -> Document;
public tableNameText builder builderState queryTable = 
    case queryTable of
    BaseTable {tableRef} ->
        quoteIdentifier builder (getTableNameFromReference tableRef); // TODO:
                                                                      // quote
                                                                      // each
                                                                      // part of
                                                                      // the
                                                                      // qualified
                                                                      // name...
    SubQueryTable {subquery} -> 
        addParens builder (nest 4 (line ++ queryText2 builder builderState (fixSubqueryOrdering subquery)) ++ line);

    OpaqueSubQueryTable {subqueryText} -> 
        addParens builder (nest 4 (line ++ multilineText subqueryText) ++ line);
    ;

/**
 * Generates the SQL text for the specified database query.
 */
queryText :: SqlBuilder -> Boolean -> Query -> String;
public queryText builder !forDisplay query = 
    let
        displayWidth = 1 :: Int;
        width = if forDisplay then displayWidth :: Int else Prelude.maxBound;
    in
        PrettyPrinter.pretty width $ queryTextDocument builder query;

/**
 * Generates the SQL text document for the specified database query.
 */
queryTextDocument :: SqlBuilder -> Query -> Document;
public queryTextDocument builder query = 
    let
        builderState = newSqlBuilderState;
        fixedGroupingQuery = modifyQueries fixQueryForGroupBy query;
        removedConstantsQuery = modifyQueries removeConstantGroupingAndOrdering fixedGroupingQuery;

        preparedQuery = modifyQueries (prepareToBuildQueryText builder builderState) removedConstantsQuery;
    in
        queryText2 builder builderState preparedQuery;

/**
 * Generates the SQL text for the specified database query.
 */
queryText2 :: SqlBuilder -> SqlBuilderState -> Query -> Document;
private queryText2 builder builderState query = 
    case (checkValidQuery query) of
    Query {options, columns, restriction, orderings, joins, groups, groupRestriction} ->
        let
            // For a subquery, exclude any tables which are used in outer
            // queries.
            allQueryTables = getQueryTables False query;
            outerQueryTables = getStateOuterQueryTables builderState;
            queryTables = deleteFirsts allQueryTables outerQueryTables;

            newBuilderState = addQueryTablesToState builderState queryTables;

            untypedRestriction = 
                case restriction of
                Nothing -> Nothing;
                Just restrictionValue -> Just (toUntypedExpr restrictionValue);
                ;
            untypedGroupRestriction = 
                case groupRestriction of
                Nothing -> Nothing;
                Just groupRestrictionValue -> Just (toUntypedExpr groupRestrictionValue);
                ;

            // Include extra JoinTables for any tables in use in the query that
            // aren't already included in the joins.
            updatedJoins = 
                let
                    joinTables = removeDuplicates (concatMap getJoinTreeTables joins);
                    tablesNotInJoins = deleteFirsts queryTables joinTables;
                in
                    joins ++ (map JoinTable tablesNotInJoins);

            // Avoid including the same expression multiple times in the GROUP
            // BY or ORDER BY clause.
            updatedGrouping  = removeDuplicates groups;
            updatedOrderings = removeDuplicatesBy (\o1 o2 -> fst o1 == fst o2) orderings;

            selectBody  = buildSelectClause builder newBuilderState options columns;
            fromBody    = buildFromClause builder newBuilderState updatedJoins;
            whereBody   = buildWhereClause builder newBuilderState untypedRestriction updatedJoins;
            groupByBody = buildGroupByClause builder newBuilderState updatedGrouping;
            havingBody  = buildHavingClause builder newBuilderState untypedGroupRestriction;
            orderByBody = buildOrderByClause builder newBuilderState updatedOrderings;
        in
            constructQuery builder newBuilderState selectBody fromBody whereBody groupByBody havingBody orderByBody;

    Union {query1, query2, unionAll} -> 
        let
            // Enclose any child UNION in quotes if its union type doesn't match
            // the outer one.
            childQueryText childQuery = 
                let
                    baseQueryText = queryText2 builder builderState childQuery;
                in
                    case childQuery of
                    Union {unionAll=innerUnionAll} ->
                        if (innerUnionAll != unionAll) then addParens builder baseQueryText 
                        else baseQueryText;
                    _ -> baseQueryText;
                    ;
            query1Text = queryText2 builder builderState query1;
            query2Text = childQueryText query2;
        in
            constructUnionQuery builder builderState query1Text query2Text unionAll;
    ;


///**
// * Assigns unique table aliases to each table in the query.
// */
//makeUniqueQueryTableAliases :: Query -> Query;
//public makeUniqueQueryTableAliases query = 
//    let
//        // Get the list of all base alias and ID combinations from the query.
//        allQueryTables :: [QueryTable];
//        allQueryTables = getQueryTables True query;
//
//        aliasInfoForTable :: QueryTable -> (String, Long);
//        aliasInfoForTable table = 
//            case table of
//            (BaseTable| SubQueryTable | OpaqueSubQueryTable) {baseAlias, tableID} -> (baseAlias, tableID);
//            ;
//
//        tableAliasInfo :: [(String, Long)];
//        tableAliasInfo = removeDuplicates (map aliasInfoForTable allQueryTables);
//
//        newTableAliasInfoMap :: [((String, Long), Long)];
//        newTableAliasInfoMap = map (\aliasInfo -> (aliasInfo, nextTableID)) tableAliasInfo;
//
//        lookupNewTableAlias :: String -> Long -> Long;
//        lookupNewTableAlias baseAlias oldTableID = lookupWithDefault (baseAlias, oldTableID) 
//                                                                     newTableAliasInfoMap
//                                                                     (error ("Failed to find new table alias for '" ++ baseAlias ++ "'"));
//        updateQueryTableFn table = 
//            case table of
//            BaseTable table baseAlias tableID -> 
//                BaseTable table baseAlias (lookupNewTableAlias baseAlias tableID);
//            SubQueryTable subquery baseAlias tableID -> 
//                SubQueryTable (modifyTablesInQuery updateQueryTableFn subquery) baseAlias (lookupNewTableAlias baseAlias tableID);
//            OpaqueSubQueryTable subqueryText baseAlias tableID -> 
//                OpaqueSubQueryTable subqueryText baseAlias (lookupNewTableAlias baseAlias tableID);
//            ;
//    in
//        modifyTablesInQuery updateQueryTableFn query;


/**
 * Throws an error if the query is not valid.
 */
checkValidQuery :: Query -> Query;
private checkValidQuery query = 
    // TODO: check other aspects of the query...
    checkValidGroupByQuery (checkValidResultColumns query);


/**
 * Checks that there is at least one return column.
 * 
 * TODO: also check that the return columns are of valid types.... (Is a
 * ListExpr valid as a return column?)
 */
checkValidResultColumns :: Query -> Query;
private checkValidResultColumns query = 
    case query of
    Query {columns} ->
        if (isEmpty columns) then error "At least one return column must be specified in the query."
        else query;
    Union {query1, query2, unionAll} -> 
        Union (checkValidResultColumns query1) (checkValidResultColumns query2) unionAll;
    ;

/**
 * If there is any grouping fields in the query, then this will
 * check that all the return column expressions are group on or
 * are aggregate expressions.
 */
checkValidGroupByQuery :: Query -> Query;
private checkValidGroupByQuery query = 
    case query of
    Query {columns, groups} ->
        let
            isGroupingExpression expr = isElem expr groups;

            expressionOk expr = 
                // First check whether this is one of the grouping
                // expressions for the query.
                if (isGroupingExpression expr) then True
                else
                    case expr of
                    QueryField {} -> 
                        // This is only ok if this is a grouping expression
                        // (which has already been checked).
                        False;

                    ConstExpr {} ->
                        // Constant expressions are always ok.
                        True;

                    ListExpr  {listValues} ->
                        all expressionOk listValues;    // TODO: is this
                                                        // correct?

                    FunctionExpr {func, arguments} ->
                        // Aggregate expressions are always ok.
                        if (isAggregationFunction func) then True
                        else all expressionOk arguments;

                    SubQueryExpr {} -> 
                        // TODO: is this ok?
                        True;
                    ;

            columnExprs  = map fst columns;
            allColumnsOk = all expressionOk columnExprs;
        in
            if (isEmpty groups || allColumnsOk) then query
            else error "Invalid grouping query specified.";

    Union {query1, query2, unionAll} -> 
        Union (checkValidGroupByQuery query1) (checkValidGroupByQuery query2) unionAll;
    ;


/**
 * SQL statements to modify tables and/or values.
 */
data public Statement = 
    private CreateDatabaseStatement // CREATE DATABASE is not part of the SQL-92 standard, but most DB servers support it
        databaseRef          :: DatabaseReference
        skipIfDatabaseExists :: Boolean
    |
    private DropDatabaseStatement // DROP DATABASE is not part of the SQL-92 standard, but most DB servers support it
        databaseRef          :: DatabaseReference
        onlyIfDatabaseExists :: Boolean
    |
    private CreateTableStatement 
        tableDesc         :: TableDescription 
        skipIfTableExists :: Boolean
    |
    private CreateViewStatement
        viewRef           :: TableReference 
        viewDefinition    :: Query
        skipIfViewExists  :: Boolean
    |
    private DropTableStatement 
        tableRef          :: TableReference 
        onlyIfTableExists :: Boolean
    |
    private DropViewStatement
        viewRef           :: TableReference 
        onlyIfViewExists  :: Boolean
    |
    private InsertValuesStatement 
        tableRef          :: TableReference 
        maybeDestColumns  :: (Maybe [String])
        rowValues         :: [Expr]
    |
    private InsertQueryValuesStatement 
        tableRef          :: TableReference 
        maybeDestColumns  :: (Maybe [String])
        insertQuery       :: Query
    |
    private UpdateValuesStatement
        tableRef          :: TableReference 
        destColumns       :: [String]
        newValues         :: [Expr]
        condition         :: (TypedExpr Boolean)
    |
    private DeleteRowsStatement
        tableRef          :: TableReference
        condition         :: (TypedExpr Boolean)
    |
    private CommitStatement
    |
    private CompoundStatement 
        statements        :: [Statement]
    ;

makeCreateDatabaseStatement :: DatabaseReference -> Boolean -> Statement;
public makeCreateDatabaseStatement = CreateDatabaseStatement;

makeDropDatabaseStatement :: DatabaseReference -> Boolean -> Statement;
public makeDropDatabaseStatement = DropDatabaseStatement;

makeCreateTableStatement :: TableDescription -> Boolean -> Statement;
public makeCreateTableStatement = CreateTableStatement;

makeCreateViewStatement :: TableReference -> Query -> Boolean -> Statement;
public makeCreateViewStatement = CreateViewStatement;

makeDropTableStatement :: TableReference -> Boolean -> Statement;
public makeDropTableStatement = DropTableStatement;

makeDropViewStatement :: TableReference -> Boolean -> Statement;
public makeDropViewStatement = DropViewStatement;

makeInsertValuesStatement :: TableReference -> [Expr] -> Statement;
public makeInsertValuesStatement tableRef rowValues = 
    InsertValuesStatement tableRef Nothing rowValues;

makeInsertValuesByColumnStatement :: TableReference -> [String] -> [Expr] -> Statement;
public makeInsertValuesByColumnStatement tableRef destColumns rowValues = 
    InsertValuesStatement tableRef (Just destColumns) rowValues;

makeInsertQueryValuesStatement :: TableReference -> Query -> Statement;
public makeInsertQueryValuesStatement tableRef insertQuery = 
    InsertQueryValuesStatement tableRef Nothing insertQuery;
                     
makeInsertQueryValuesByColumnStatement :: TableReference -> [String] -> Query -> Statement;
public makeInsertQueryValuesByColumnStatement tableRef destColumns insertQuery = 
    InsertQueryValuesStatement tableRef (Just destColumns) insertQuery;

makeUpdateValuesStatement :: TableReference -> [String] -> [Expr] -> TypedExpr Boolean -> Statement;
public makeUpdateValuesStatement tableRef destColumns newValues condition = 
    UpdateValuesStatement tableRef destColumns newValues condition;

makeDeleteRowsStatement :: TableReference -> TypedExpr Boolean -> Statement;
public makeDeleteRowsStatement tableRef condition =
    DeleteRowsStatement tableRef condition;

makeCommitStatement :: Statement;
public makeCommitStatement = CommitStatement;

/**
 * Creates a compound statement from a list of statements.  This function
 * will attempt to flatten any compound statements contained in the argument
 * list.
 */
makeCompoundStatement :: [Statement] -> Statement;
public makeCompoundStatement statements =
    let
       makeCompoundStatementHelper :: Statement -> [Statement];
       makeCompoundStatementHelper stmt =
           case stmt of
           CompoundStatement {statements} -> statements;
           _ -> [stmt];
           ;
    in
        CompoundStatement (concatMap makeCompoundStatementHelper statements); 

/**
 * Linearizes the structure of the given statement by extracting all
 * statements nested in any compound statement.  This function will be
 * invoked recursively on all compound statements.  If the given statement
 * is not a compound statement, then it will be returned as is.  
 * @arg statement
 * @return A linearized/flattened list of statement.
 */
linearizeStatement :: Statement -> [Statement];
public linearizeStatement statement =
    let
        serializeStatementFoldFn :: Statement -> [Statement] -> [Statement];
        serializeStatementFoldFn !stmt stmtList =
            case stmt of
            CompoundStatement {statements} ->
                foldRight serializeStatementFoldFn stmtList statements;
            _ ->
                stmt : stmtList;
            ;
    in
        foldRight serializeStatementFoldFn [] [statement];

/**
 * Breaks a compound statement into multiple compound statements with a smaller
 * statement count.  This function assumes that it is not possible to create
 * nested compound statements.
 */
splitCompoundStatement :: Statement -> Int -> [Statement];
public splitCompoundStatement stmt maxCount =
    case stmt of
    CompoundStatement {statements} ->
        List.map makeCompoundStatement (chop maxCount statements);
    _ -> [stmt];
    ;

/**
 * Generates the SQL text for a statement.
 */
statementText :: SqlBuilder -> Boolean -> Statement -> String;
public statementText !builder !forDisplay statement = 
    case builder of
    SqlBuilder {buildCreateDatabaseStatementFn,
                buildDropDatabaseStatementFn,
                buildCreateTableStatementFn,
                buildCreateViewStatementFn,
                buildDropTableStatementFn,
                buildDropViewStatementFn,
                buildInsertValuesStatementFn,
                buildInsertQueryValuesStatementFn,
                buildUpdateValuesStatementFn,
                buildDeleteRowsStatementFn,
                buildCommitStatementFn} ->
        let
            displayWidth = 1 :: Int;
            width = if forDisplay then displayWidth :: Int else Prelude.maxBound;

            docForStatement statement = 
                case statement of
                CreateDatabaseStatement {databaseRef, skipIfDatabaseExists} ->
                    buildCreateDatabaseStatementFn databaseRef skipIfDatabaseExists;
                DropDatabaseStatement {databaseRef, onlyIfDatabaseExists} ->
                    buildDropDatabaseStatementFn databaseRef onlyIfDatabaseExists;
                CreateTableStatement {tableDesc, skipIfTableExists} -> 
                    buildCreateTableStatementFn tableDesc skipIfTableExists;
                CreateViewStatement {viewRef, viewDefinition, skipIfViewExists} -> 
                    buildCreateViewStatementFn viewRef viewDefinition skipIfViewExists;
                DropTableStatement {tableRef, onlyIfTableExists} -> 
                    buildDropTableStatementFn tableRef onlyIfTableExists;
                DropViewStatement {viewRef, onlyIfViewExists} -> 
                    buildDropViewStatementFn viewRef onlyIfViewExists;
                InsertValuesStatement {tableRef, maybeDestColumns, rowValues} -> 
                    buildInsertValuesStatementFn tableRef maybeDestColumns rowValues;
                InsertQueryValuesStatement {tableRef, maybeDestColumns, insertQuery} -> 
                    buildInsertQueryValuesStatementFn tableRef maybeDestColumns insertQuery;
                UpdateValuesStatement {tableRef, destColumns, newValues, condition} -> 
                    buildUpdateValuesStatementFn newSqlBuilderState tableRef destColumns newValues condition;
                DeleteRowsStatement {tableRef, condition} -> 
                    buildDeleteRowsStatementFn newSqlBuilderState tableRef condition;
                CommitStatement ->
                    buildCommitStatementFn;
                CompoundStatement {statements} -> 
                    // Include a ';' after each statement in a compound statement.
                    PrettyPrinter.group $ PrettyPrinter.stack $ List.map (\stmt -> docForStatement stmt ++ text ";") statements;
                ;
        in
            PrettyPrinter.pretty width (docForStatement statement);
    ;

/**
 * Generates the text for a table field description.
 */
fieldDescriptionText :: SqlBuilder -> FieldDescription -> Document;
public fieldDescriptionText !builder fieldDesc = 
    (builder.SqlBuilder.buildFieldDescriptionFn) fieldDesc;

/**
 * Generates the text for a field data type.
 */
fieldTypeText :: SqlBuilder -> SqlType -> Document;
public fieldTypeText !builder !dataType = 
    (builder.SqlBuilder.buildFieldTypeFn) dataType;


/**
 * @arg query The query for which we want the groups.
 * @return The list of groups for the given query, or if the query is a union
 *         then the groups for the first query in the union.
 */
getGroups :: Query -> [Expr];
public getGroups query =
    case query of
    Query {groups, columns} -> 
        let
            filter expr = 
                case expr of 
                QueryField {} -> [expr];
                _ -> [];
                ;
                
            cols = concatMap (\col -> filter col.#1) columns;
        in 
            groups ++ cols;
    Union {query1} -> getGroups query1;
    ;


/**
 * @return True when a given function is a function of two parameters
 */
isBinaryFunction :: DbFunction -> Boolean;
public isBinaryFunction dbFun = 
    case dbFun of
    (OpEq 
    | OpLt 
    | OpLtEq 
    | OpGt 
    | OpGtEq 
    | OpNotEq 
    | OpAnd 
    | OpOr 
    | OpLike 
    | OpIn 
    | OpCat 
    | OpPlus 
    | OpMinus 
    | OpMul 
    | OpDiv 
    | OpMod 
    | OpBitAnd 
    | OpBitOr 
    | OpBitXor) -> True;   
    _ -> False;
    ;

/**
 * It applies ConvertToTime function to the passed in expression. Use it when you want the end result to be evaluated to the explicit cast call.
 * 
 * @return function expr
 */
convertToTimeExpr :: TypedExpr a -> TypedExpr Time;
public convertToTimeExpr = functionExpr1 ConvertToTimeFunction;

   
/**
 * Use it to check if the expression's part uses binary function.
 * 
 * @return True when expression uses binary function
 * @see function = isBinaryFunction 
 */
exprUsesBinaryFunction :: Expr -> Boolean;
public exprUsesBinaryFunction expr = 
    case expr of
    QueryField fieldName queryTable -> False;
    ConstExpr  constantValue -> False;
    ListExpr  listValues -> any exprUsesBinaryFunction listValues;
    FunctionExpr func arguments -> isBinaryFunction func || (any exprUsesBinaryFunction arguments);
    SubQueryExpr subquery -> False;
    ;

/**
 * The function recurses the Expr Boolean and makes sure that every item involved in operation against time constant 
 * is casted to datetime format explictly.
 *
 * Use it to make expression to be evaluated to explicit casts.
 * 
 * @arg expr
 * @return transformed expr
 * @see function = convertToTimeExpr
 */ 
convertDateQueryFieldsToTimeExprs :: TypedExpr Boolean -> TypedExpr Boolean;
public convertDateQueryFieldsToTimeExprs expr = 
    //TODO: get more metadata into the field object
    let
        convertNonTimeConstExpr :: Expr -> Expr;
        convertNonTimeConstExpr exprToConvert = 
            if (isTimeConstExpr exprToConvert) then
                exprToConvert
            else
                toUntypedExpr(convertToTimeExpr (toTypedExpr exprToConvert));
        
        convertionHelper :: Expr -> Expr;
        convertionHelper untypedExpr = 
            case untypedExpr of
    //            ListExpr listValue -> 
    
                //for binary functions, if only one arg is time const make sure 
                //all others are casted
                FunctionExpr dbFunc args ->
                    if (isBinaryFunction dbFunc) then 
                        let
                            lhs = convertionHelper (head args);
                            rhs = convertionHelper (head (tail args));
        
                            convertedExprs = map convertNonTimeConstExpr args;
                        in
                            if ((any isQueryFieldExpr args) && (any isTimeConstExpr args)) then
                                untypedFunctionExpr dbFunc convertedExprs
                            else
                                untypedFunctionExpr dbFunc [lhs, rhs]
                    else 
                        untypedExpr;
                _ -> untypedExpr;
            ;
    in
        toTypedExpr (convertionHelper (toUntypedExpr expr));
        
///**
// * The {@code replaceRestrictionExprs@} replaces a restriction of a query with a passed in values. 
// *  
// * @arg query
// * @arg newRestriction
// * @arg newGrpRestriction
// * @return transformed query
// * @see typeConstructor = Query 
// */           
//replaceRestrictionExprs :: Query -> Maybe (TypedExpr Boolean) -> Maybe (TypedExpr Boolean) -> Query;
//replaceRestrictionExprs query newRestriction newGrpRestriction = 
//    case query of
//        Query options columns restriction orderings joins groups groupRestriction ->
//            Query options columns newRestriction orderings joins groups newGrpRestriction;
//
//        _ -> error "unsupported query type for change of restrictions";
//    ;

/**
 * The {@code transformQueryRestrictionExpr@} takes a conversion function and executes it against 
 * the restriction expression of a query.
 * 
 * @arg conversionFunction
 * @arg query
 * @return transformed query
 */      
transformQueryRestrictionExpr :: (TypedExpr Boolean -> TypedExpr Boolean) -> Query -> Query;
public transformQueryRestrictionExpr conversionFunction query =
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        case restriction of
        Nothing -> query;
        Just restrictionExpr -> 
            let
                newRestriction = Just (conversionFunction restrictionExpr);
            in
                Query options columns newRestriction orderings joins groups groupRestriction;
        ;

    Union query1 query2 unionAll -> 
        // transform the restriction expressions in both queries.
        Union (transformQueryRestrictionExpr conversionFunction query1) 
              (transformQueryRestrictionExpr conversionFunction query2) 
              unionAll;
    ;


/**
 * The {@code isSubQueryExpr@} tests expression if it is of SubQueryExpr type.
 * 
 * @arg expr
 * @return True when Expr is a {@code SubQueryExpr@}
 * @see dataConstructor = SubQueryExpr  
 */
isSubQueryExpr :: Expr -> Boolean;
public isSubQueryExpr expr =
    case expr of
    SubQueryExpr {} -> True;
    _ -> False;
    ;

/**
 * The {@code isSubQueryExpr@} retrieves the {@code Query@} type from untyped expression. 
 * 
 * Throws error when argument is not of SubQueryType
 * 
 * @arg expr
 * @return Query part of the SubQueryExpr
 * @see dataConstructor = SubQueryExpr 
 * @see function = isSubQueryExpr
 */
getSubQueryFromExpr :: Expr -> Query;
public getSubQueryFromExpr expr =
    case expr of
    SubQueryExpr query -> query;
    _ -> error "unable to extract query from non SubQueryExpr";
    ;

/**
 * The {@code isSubQueryExpr@} tests passed in query if it going to retrieve single column and value in the result set.
 * 
 * @arg query to test
 * @return True when expected resultset is using single column with applied aggregate function and the query has no groupings.
 */
isSingletonResultQuery :: Query -> Boolean;
public isSingletonResultQuery query =
    let
        cols :: [Expr];
        cols = getProjectedColumns query;

        headCol :: Expr;
        headCol = head cols;

        dbFunc :: DbFunction;
        dbFunc = getFunctionFromFunctionExpr headCol;
    in
        List.isSingletonList cols 
            && isFunctionExpr headCol 
            && isEmpty (getGroups query)
            && isAggregationFunction dbFunc;

/**
 * The {@code assignMissingColumnAliases@} is a transformation function to assign the missing aliases for all columns 
 * of the passed in query
 * 
 * Use it in conjunction with {@code modifyQueries@} function which can help to perfrom the transaformation 
 * for all subqueries
 * 
 * @arg query to transform
 * @return transformed query
 * @see function = modifyQueries
 */
assignMissingColumnAliases :: Query -> Query;
public assignMissingColumnAliases query =
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            assignDefaultAlias :: (Expr, String) -> Int -> (Expr, String);
            assignDefaultAlias column aliasIndex = 
                case column of
                (columnExpr, columnAlias) -> 
                    let                         
                        newAlias = 
                            if (columnAlias == "") then
                                defaultColumnAlias aliasIndex
                            else
                                columnAlias; 
                    in
                        (columnExpr, newAlias);
                ;

            newColumns :: [(Expr, String)];
            newColumns = List.mapIndexed assignDefaultAlias columns;
        in
            Query options newColumns restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll ->              
        Union (assignMissingColumnAliases query1) (assignMissingColumnAliases query2) unionAll;

    _ -> error "unsupported type passed to assign missing aliases";
    ;

/**
 * The {@code convertQueryColumnsToCartesianJoins@} is a transformation function pushing the sub-queries 
 * nested as select items down to the from clause to perform cartesian join between datasources.
 *
 * It is useful on platforms like Teradata that do not support nested subqueries in select items. 
 * The conversion will be applied to the passed in query and all its subqueries. 
 * After all missign aliases have been assigned.
 *
 * It expects all aliases to be assigned therefore make sure {@code assignMissingColumnAliases@} is 
 * applied before this transform.
 * 
 * Use it in conjunction with {@code modifyQueries@} function which can help to perfrom 
 * the transaformation for all subqueries
 * 
 * @arg query to transform
 * @return transformed query
 * @see function = modifyQueries, assignMissingColumnAliases 
 */
convertQueryColumnsToCartesianJoins :: Query -> Query;    
public convertQueryColumnsToCartesianJoins !query =
    let
        convertToCartesianQuery :: Query -> Query;
        convertToCartesianQuery !queryToConvert =
            case queryToConvert of
            Query options columns restriction orderings joins groups groupRestriction ->
                let
                    // For a subquery column, replace it with a reference to a subquery table field.
                    // Ensure that the generated table aliases are unique, even from the other ones generated here.
                    updateSubQueryColumns :: [String] -> [(Expr, String)] -> [(Expr, String)];
                    updateSubQueryColumns reservedAliases !columns = 
                        case columns of
                        [] -> [];
                        headColumn : tailColumns -> 
                            case headColumn of
                            (columnExpr, columnAlias) -> 
                                if (isSubQueryExpr columnExpr) then
                                    let
                                        subQuery :: Query;
                                        subQuery = getSubQueryFromExpr columnExpr;
                                    in
                                        if (isSingletonResultQuery subQuery) then
                                            let
                                                singletonAlias :: String;
                                                singletonAlias = head $ projectedColumnAliases subQuery;

                                                // Find a unique alias for this table within the query.
                                                queryTableAlias :: String;
                                                queryTableAlias = makeUniqueTableAliasForQuery query reservedAliases "Q";

                                                newQueryTable :: QueryTable;
                                                newQueryTable = makeSubQueryTable subQuery queryTableAlias;

                                                // Apply MIN function on singleton query to avoid grouping.
                                                // Use MIN in case the data type is non-numeric.
                                                newColumnExpr :: Expr;
                                                newColumnExpr = 
                                                    untypedFunctionExpr AggrMin [untypedField newQueryTable singletonAlias];
                                            in
                                                (newColumnExpr, columnAlias) : updateSubQueryColumns (queryTableAlias : reservedAliases) tailColumns
                                        else
                                            headColumn : updateSubQueryColumns reservedAliases tailColumns
                                else
                                    headColumn : updateSubQueryColumns reservedAliases tailColumns;
                            ;
                        ;

                    newColumns :: [(Expr, String)];
                    newColumns = updateSubQueryColumns [] columns;
                in
                    Query options newColumns restriction orderings joins groups groupRestriction;

            Union query1 query2 unionAll ->              
                Union (convertToCartesianQuery query1) (convertToCartesianQuery query2) unionAll;

            _ -> error "invalid query type when converting joins";
            ;
    in
        convertToCartesianQuery query;

/**
 * Constructs a table alias from the base name which is distinct within the query.
 */
makeUniqueTableAliasForQuery :: Query -> [String] -> String -> String;
makeUniqueTableAliasForQuery !query !otherReservedAliases !baseAlias = 
    let
        // Get the list of all base alias and ID combinations from the query.
        allQueryTables :: [QueryTable];
        allQueryTables = getQueryTables True query;

        allUsedTableAliases :: Set String;
        allUsedTableAliases = Set.fromList (otherReservedAliases ++ map getQueryTableAlias allQueryTables);

        potentialAliases :: [String];
        potentialAliases = baseAlias : map (\!indx -> baseAlias ++ intToString indx) (upFrom 2);
    in
        head $ filter (\potentialAlias -> not $ Set.member potentialAlias allUsedTableAliases) potentialAliases;

/**
 * Convert a range of values for a field or expression into the equivalent restriction expression.
 * @arg makeConstantFn  a function to produce a database constant expression from a value
 * @arg field           the database field or expression to be restricted
 * @arg range           the range of values to which the field will be restricted
 * @return              a Boolean expression restricting the field to the specified range
 */
rangeToRestrictionExpr :: Ord a => (a -> TypedExpr a) -> TypedExpr a -> Range a -> TypedExpr Boolean;
public rangeToRestrictionExpr makeConstantFn field !range = 
    let
        startValue = makeConstantFn (leftEndpoint range);
        startOperator = if (includesLeftEndpoint range) then gtEqExpr else gtExpr;
        startRestriction = startOperator field startValue;

        endValue = makeConstantFn (rightEndpoint range);
        endOperator = if (includesRightEndpoint range) then ltEqExpr else ltExpr;
        endRestriction = endOperator field endValue;
    in
        if (hasLeftEndpoint range) then
            if (hasRightEndpoint range) then andExpr startRestriction endRestriction
            else startRestriction
        else
            if (hasRightEndpoint range) then endRestriction
            else trueConstant;


/////////////////////////////////////////////////////////////////////////////////////////
// Output CAL Queries and Expressions (and dependant types) to Java.
/////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////
// Output QueryTables.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.QueryTable" 
    JQueryTable deriving Outputable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.QueryTable$BaseTable"
    jMakeBaseTable :: String -> String -> JQueryTable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.QueryTable$SubQueryTable"
    jMakeSubQueryTable :: String -> JQuery -> JQueryTable;

instance Outputable QueryTable where
    output = outputQueryTableAsJObject;
    ;

outputQueryTable :: QueryTable -> JQueryTable;
outputQueryTable !queryTable =
    case queryTable of
    BaseTable {tableRef, tableAlias} -> 
        jMakeBaseTable tableAlias (getTableNameFromReference tableRef);

    SubQueryTable {subquery, tableAlias} -> 
        jMakeSubQueryTable tableAlias (outputQuery subquery);

    OpaqueSubQueryTable {subqueryText, tableAlias} -> 
        // The Java model doesn't have a class for an opaque subquery table.
        // TODO: would it be possible to parse the query and construct a regular query table object instead?
        error "case not implemented";
    ;

outputQueryTableAsJObject :: QueryTable -> JObject;
outputQueryTableAsJObject !queryTable = output $ outputQueryTable queryTable;


/////////////////////////////////////////////////////////////////////////////////////////
// Output QueryOptions.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.QueryOption" 
    JQueryOption deriving Outputable;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Sql.QueryOption.makeDistinctOption"
    jMakeDistinctOption :: JQueryOption;
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Sql.QueryOption.makeTopNOption"
    jMakeTopNOption :: Int -> Boolean -> Boolean -> JQueryOption;

instance Outputable QueryOption where
    output = outputQueryOptionAsJObject;
    ;

outputQueryOption :: QueryOption -> JQueryOption;
outputQueryOption !queryOption =
    case queryOption of
    Distinct {} -> jMakeDistinctOption;
    TopN {n, percent, withTies} -> jMakeTopNOption n percent withTies;
    ;

outputQueryOptionAsJObject :: QueryOption -> JObject;
outputQueryOptionAsJObject !queryOption = output $ outputQueryOption queryOption;


/////////////////////////////////////////////////////////////////////////////////////////
// Output JoinTypes.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.JoinType" 
    JJoinType deriving Outputable;

foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.JoinType.INNER_JOIN"       jINNER_JOIN       :: JJoinType;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.JoinType.LEFT_OUTER_JOIN"  jLEFT_OUTER_JOIN  :: JJoinType;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.JoinType.RIGHT_OUTER_JOIN" jRIGHT_OUTER_JOIN :: JJoinType;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.JoinType.FULL_OUTER_JOIN"  jFULL_OUTER_JOIN  :: JJoinType;

instance Outputable JoinType where
    output = outputJoinTypeAsJObject;
    ;

outputJoinType :: JoinType -> JJoinType;
outputJoinType !joinType =
    case joinType of
    InnerJoin      -> jINNER_JOIN;
    LeftOuterJoin  -> jLEFT_OUTER_JOIN;
    RightOuterJoin -> jRIGHT_OUTER_JOIN;
    FullOuterJoin  -> jFULL_OUTER_JOIN;
    ;

outputJoinTypeAsJObject :: JoinType -> JObject;
outputJoinTypeAsJObject !joinType = output $ outputJoinType joinType;


/////////////////////////////////////////////////////////////////////////////////////////
// Output JoinNodes.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.JoinNode" 
    JJoinNode deriving Outputable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.JoinNode$JoinTable"
    jMakeJoinTableNode :: JQueryTable -> JJoinNode;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.JoinNode$JoinSubtree"
    jMakeJoinSubtreeNode :: JJoinNode -> JJoinNode -> JExpression -> JJoinType -> JJoinNode;

instance Outputable JoinNode where
    output = outputJoinNodeAsJObject;
    ;

outputJoinNode :: JoinNode -> JJoinNode;
outputJoinNode !joinNode =
    case joinNode of
    JoinTable {table} -> 
        jMakeJoinTableNode $ outputQueryTable table;
    JoinSubtree {leftNode, rightNode, linkingExpr, joinType} -> 
        jMakeJoinSubtreeNode (outputJoinNode leftNode) 
                             (outputJoinNode rightNode) 
                             (outputExpression $ toUntypedExpr linkingExpr) 
                             (outputJoinType joinType);
    ;

outputJoinNodeAsJObject :: JoinNode -> JObject;
outputJoinNodeAsJObject !joinNode = output $ outputJoinNode joinNode;


/////////////////////////////////////////////////////////////////////////////////////////
// Output DbFunctions.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction" 
    JDatabaseFunction deriving Outputable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Function"
    jMakeDatabaseFunction :: String -> JDatabaseFunction;

foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.NOT_OPERATOR"                   jNotOperator                :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.BITWISE_NOT_OPERATOR"           jBitwiseNotOperator         :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.NEGATE_OPERATOR"                jNegateOperator             :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.ISNULL_OPERATOR"                jIsNullOperator             :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.ISNOTNULL_OPERATOR"             jIsNotNullOperator          :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.EXISTS_OPERATOR"                jExistsOperator             :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.EQUAL_OPERATOR"                 jEqualOperator              :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.LESS_THAN_OPERATOR"             jLessThanOperator           :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.LESS_THAN_OR_EQUAL_OPERATOR"    jLessThanOrEqualOperator    :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.GREATER_THAN_OPERATOR"          jGreaterThanOperator        :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.GREATER_THAN_OR_EQUAL_OPERATOR" jGreaterThanOrEqualOperator :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.NOT_EQUAL_OPERATOR"             jNotEqualOperator           :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.AND_OPERATOR"                   jAndOperator                :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.OR_OPERATOR"                    jOrOperator                 :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.LIKE_OPERATOR"                  jLikeOperator               :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.IN_OPERATOR"                    jInOperator                 :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.CONCAT_OPERATOR"                jConcatOperator             :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.PLUS_OPERATOR"                  jPlusOperator               :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.MINUS_OPERATOR"                 jMinusOperator              :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.MULTIPLY_OPERATOR"              jMultiplyOperator           :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.DIVIDE_OPERATOR"                jDivideOperator             :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.MODULUS_OPERATOR"               jModulusOperator            :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.BITWISE_AND_OPERATOR"           jBitwiseAndOperator         :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.BITWISE_OR_OPERATOR"            jBitwiseOrOperator          :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.BITWISE_XOR_OPERATOR"           jBitwiseXOrOperator         :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.BETWEEN_OPERATOR"               jBetweenOperator            :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.SIMPLE_CASE_OPERATOR"           jSimpleCaseOperator         :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.SEARCHED_CASE_OPERATOR"         jSearchedCaseOperator       :: JDatabaseFunction;

foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Conversion.CONVERSION_TO_STRING"         jConvertToString            :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Conversion.CONVERSION_TO_INT"            jConvertToInt               :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Conversion.CONVERSION_TO_DOUBLE"         jConvertToDouble            :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Conversion.CONVERSION_TO_TIME"           jConvertToTime              :: JDatabaseFunction;

instance Outputable DbFunction where
    output = outputDbFunctionAsJObject;
    ;

outputDbFunction :: DbFunction -> JDatabaseFunction;
outputDbFunction !func = 
    case func of
    // Handle operators specially.
    OpNot           -> jNotOperator;
    OpBitNot        -> jBitwiseNotOperator;
    OpNegate        -> jNegateOperator;
    OpIsNull        -> jIsNullOperator;
    OpIsNotNull     -> jIsNotNullOperator;
    OpExists        -> jExistsOperator;
    OpEq            -> jEqualOperator;
    OpLt            -> jLessThanOperator;
    OpLtEq          -> jLessThanOrEqualOperator;
    OpGt            -> jGreaterThanOperator;
    OpGtEq          -> jGreaterThanOrEqualOperator;
    OpNotEq         -> jNotEqualOperator;
    OpAnd           -> jAndOperator;
    OpOr            -> jOrOperator;
    OpLike          -> jLikeOperator;
    OpIn            -> jInOperator;
    OpCat           -> jConcatOperator;
    OpPlus          -> jPlusOperator;
    OpMinus         -> jMinusOperator;
    OpMul           -> jMultiplyOperator;
    OpDiv           -> jDivideOperator;
    OpMod           -> jModulusOperator;
    OpBitAnd        -> jBitwiseAndOperator;
    OpBitOr         -> jBitwiseOrOperator;
    OpBitXor        -> jBitwiseXOrOperator;
    OpBetween       -> jBetweenOperator;
    OpCase_Simple   -> jSimpleCaseOperator;
    OpCase_Searched -> jSearchedCaseOperator;

    // Handle conversion functions specially as well.
    ConvertToStringFunction -> jConvertToString;
    ConvertToIntFunction    -> jConvertToInt;
    ConvertToDoubleFunction -> jConvertToDouble;
    ConvertToTimeFunction   -> jConvertToTime;

    // For other functions, just output the default function name.
    _ -> jMakeDatabaseFunction $ defaultFunctionName func;
    ;

outputDbFunctionAsJObject :: DbFunction -> JObject;
outputDbFunctionAsJObject !func = output $ outputDbFunction func;


/////////////////////////////////////////////////////////////////////////////////////////
// Output Expressions.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.SqlExpression" 
    JExpression deriving Outputable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$QueryField"
    jMakeQueryFieldExpression :: String -> JQueryTable -> JExpression;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ConstantExpression$NullConstant.nullConstant"
    jMakeNullConstantExpression :: JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ConstantExpression$StringConstant"
    jMakeStringConstantExpression :: String -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ConstantExpression$NumericConstant"
    jMakeNumericConstantExpression :: Double -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ConstantExpression$BooleanConstant"
    jMakeBooleanConstantExpression :: Boolean -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ConstantExpression$TimeConstant"
    jMakeTimeConstantExpression :: Time -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ParameterExpression"
    jMakeParameterExpression :: JParameter -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ListExpression"
    jMakeListExpression :: JList -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$FunctionExpression"
    jMakeFunctionExpression :: JDatabaseFunction -> JList -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$SubQueryExpression"
    jMakeSubQueryExpression :: JQuery -> JExpression;

instance Outputable Expr where
    output = outputExprAsJObject;
    ;

outputExpression :: Expr -> JExpression;
outputExpression !expr = 
    case expr of
    QueryField {fieldName, queryTable} -> 
        jMakeQueryFieldExpression fieldName (outputQueryTable queryTable);
    ConstExpr {constantValue} -> 
        case constantValue of
        NullValue                -> jMakeNullConstantExpression;
        StringValue  {strValue}  -> jMakeStringConstantExpression strValue;
        NumberValue  {numValue}  -> jMakeNumericConstantExpression numValue;
        BooleanValue {boolValue} -> jMakeBooleanConstantExpression boolValue;
        TimeValue    {timeValue} -> jMakeTimeConstantExpression timeValue;
        ;
    ParameterExpr {parameter} -> 
        jMakeParameterExpression (outputParameter parameter);
    ListExpr {listValues} -> 
        jMakeListExpression (outputList listValues);
    FunctionExpr {func, arguments} -> 
        jMakeFunctionExpression (outputDbFunction func) (outputList arguments);
    SubQueryExpr {subquery} -> 
        jMakeSubQueryExpression (outputQuery subquery);
    ;

outputExprAsJObject :: Expr -> JObject;
outputExprAsJObject !expr = output $ outputExpression expr;


/////////////////////////////////////////////////////////////////////////////////////////
// Output Queries.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.SqlQuery" 
    JQuery deriving Outputable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlQuery$SelectQuery"
    jMakeSelectQuery :: JList -> JList -> JExpression -> JList -> JList -> JList -> JExpression -> JQuery;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlQuery$UnionQuery"
    jMakeUnionQuery :: JQuery -> JQuery -> Boolean -> JQuery;

data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.QueryColumn" 
    JQueryColumn deriving Outputable;

foreign unsafe import jvm "constructor"
    jMakeQueryColumn :: JExpression -> String -> JQueryColumn;

data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.SqlOrdering" 
    JSqlOrdering deriving Outputable;

foreign unsafe import jvm "constructor"
    jMakeSqlOrdering :: JExpression -> Boolean -> JSqlOrdering;

instance Outputable Query where
    output = outputQueryAsJObject;
    ;

outputQuery :: Query -> JQuery;
outputQuery !query = 
    case query of
    Query {options, columns, restriction, orderings, joins, groups, groupRestriction} -> 
        jMakeSelectQuery (outputList options)
                         (outputListWith columns outputProjectedColumn)
                         (outputExpression $ toUntypedExpr $ fromMaybe trueConstant restriction)
                         (outputListWith orderings outputOrdering)
                         (outputList joins)
                         (outputList groups)
                         (outputExpression $ toUntypedExpr $ fromMaybe trueConstant groupRestriction);
    Union {query1, query2, unionAll} -> 
        jMakeUnionQuery (outputQuery query1) (outputQuery query2) unionAll;
    ;

outputQueryAsJObject :: Query -> JObject;
outputQueryAsJObject !query = output $ outputQuery query;

outputProjectedColumn :: (Expr, String) -> JObject;
outputProjectedColumn !column = 
    case column of
    (expr, alias) -> output $ jMakeQueryColumn (outputExpression expr) alias;
    ;

outputOrdering :: (Expr, Boolean) -> JObject;
outputOrdering !ordering = 
    case ordering of
    (expr, ascending) -> output $ jMakeSqlOrdering (outputExpression expr) ascending;
    ;


/////////////////////////////////////////////////////////////////////////////////////////
// Output Parameters.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.SqlParameter" 
    JParameter deriving Outputable;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Sql.SqlParameter.makeParameter"
    jMakeUnnamedParameter :: JParameter;
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Sql.SqlParameter.makeParameter"
    jMakeNamedParameter :: String -> JParameter;

instance Outputable Parameter where
    output = outputParameterAsJObject;
    ;

outputParameter :: Parameter -> JParameter;
outputParameter !parameter =
    case parameter of
    UnnamedParameter -> jMakeUnnamedParameter;
    NamedParameter {name} -> jMakeNamedParameter name;
    ;

outputParameterAsJObject :: Parameter -> JObject;
outputParameterAsJObject !parameter = output $ outputParameter parameter;


